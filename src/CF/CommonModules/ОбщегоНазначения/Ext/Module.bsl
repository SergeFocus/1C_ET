//sza131211-1459 для совместимости с большим числом внешних разработок 

Процедура СообщитьПользователю(Знач ТекстСообщенияПользователю,
	Знач ОбъектИлиСсылка = Неопределено,
	Знач Поле = "",
	Знач ПутьКДанным = "",
	Отказ = ЛОЖЬ) Экспорт
	
	Если ОбщийМодульПовторВТеченииСервера.ВыводитьСообщенияМожно() Тогда
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = ТекстСообщенияПользователю;
		
		Если НЕ ПустаяСтрока(Поле) Тогда
			Сообщение.Поле = Поле;
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
			Сообщение.ПутьКДанным = ПутьКДанным;
		КонецЕсли;
		
		Если ОбъектИлиСсылка <> Неопределено Тогда
			Сообщение.УстановитьДанные(ОбъектИлиСсылка);
			#Если Сервер Тогда
				Если ОбъектИлиСсылка.Ссылка = ОбъектИлиСсылка Тогда
					Сообщение.КлючДанных = ОбъектИлиСсылка;
				КонецЕсли;
			#КонецЕсли
		КонецЕсли;
		
		Сообщение.Сообщить();	
	КонецЕсли;
	Отказ = ИСТИНА;
	
КонецПроцедуры

//////////////////////////////////////////////////////////////////////////////////
//// Общие процедуры и функции для работы с прикладными типами и коллекциями значений

//// Объединяет две таблицы значений по условию "И".
//// Возвращает таблицу значений, полученную в результате объединения двух таблиц по условию "И".
////
//// Параметры:
////  Таблица1         - ТаблицаЗначений - первая таблица значений для объединения
////  Таблица2         - ТаблицаЗначений - вторая таблица значений для объединения
////  ПоляТаблицы      - Строка - поля таблицы, перечисленные через запятую, по которым будут выполнятся объединение
////  ИмяПоляИтератора - Строка - имя служебной колонки таблицы значений.
////                              Это имя должно быть уникально во множестве имен колонок первой и второй таблиц.
////                              Переменная ПоляТаблицы не должна содержать этого имени. 
////                              Значение по умолчанию "ИтераторПоляТаблицы"
//// 
//// Возвращаемое значение:
////  ТаблицаЗначений -  таблица значений, полученная в результате объединения двух таблиц по условию "И"
////
//Функция ОбъединитьТаблицыПоУсловиюИ(Таблица1, Таблица2, Знач ПоляТаблицы, ИмяПоляИтератора = "ИтераторПоляТаблицы") Экспорт
//	
//	Таблица1.Свернуть(ПоляТаблицы);
//	Таблица2.Свернуть(ПоляТаблицы);
//	
//	ДобавитьИтераторТаблице(Таблица1, +1, ИмяПоляИтератора);
//	ДобавитьИтераторТаблице(Таблица2, -1, ИмяПоляИтератора);
//	
//	ТаблицаРезультат = Таблица1.Скопировать();
//	
//	ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(Таблица2, ТаблицаРезультат);
//	
//	ТаблицаРезультат.Свернуть(ПоляТаблицы, ИмяПоляИтератора);
//	
//	ТаблицаРезультат = ТаблицаРезультат.Скопировать(Новый Структура(ИмяПоляИтератора, 0));
//	
//	ТаблицаРезультат.Колонки.Удалить(ИмяПоляИтератора);
//	
//	Возврат ТаблицаРезультат;
//	
//КонецФункции

//// Добавляет колонку в таблицу значений. Заполняет колонку переданным значением
////
//// Параметры:
////  Таблица           - ТаблицаЗначений - таблица значений для добавления колонки
////  ЗначениеИтератора - Произвольный - значение, которым будет заполнено новое поле таблицы
////  ИмяПоляИтератора  - Строка - имя добавляемого поля
//// 
//Процедура ДобавитьИтераторТаблице(Таблица, ЗначениеИтератора, ИмяПоляИтератора) Экспорт
//	
//	Таблица.Колонки.Добавить(ИмяПоляИтератора);
//	
//	Таблица.ЗаполнитьЗначения(ЗначениеИтератора, ИмяПоляИтератора);
//	
//КонецПроцедуры

// Заполняет массив-приемник уникальными значениями из массива-источника.
// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
//
// Параметры:
//  МассивПриемник – Массив – массив, который заполняется уникальными значениями
//  МассивИсточник – Массив – массив, из которого подбираются элементы в массив-приемник.
// 
Процедура ЗаполнитьМассивУникальнымиЗначениями(МассивПриемник, МассивИсточник) Экспорт
	
	Для Каждого Элемент Из МассивИсточник Цикл
		
		Если МассивПриемник.Найти(Элемент) = Неопределено Тогда
			
			МассивПриемник.Добавить(Элемент);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам 
// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
//
// Параметры:
//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
	
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

////	Преобразует таблицу значений в массив.
////	Может использоваться для передачи на клиента данных, полученных
////	на сервере в виде таблицы значений в том случае, если таблица
////	значений содержит только такие значения, которые могут
////  быть переданы на клиента
////
////	Полученный массив содержит структуры, каждая из которых повторяет
////	структуру колонок таблицы значений.
////
////	Не рекомендуется использовать для преобразования таблиц значений
////	с большим количеством строк.
////
////	Параметры: ТаблицаЗначений
////	Возвращаемое значение: Массив
////
//Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
//	
//	Массив = Новый Массив();
//	СтруктураСтрокой = "";
//	НужнаЗапятая = Ложь;
//	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
//		Если НужнаЗапятая Тогда
//			СтруктураСтрокой = СтруктураСтрокой + ",";
//		КонецЕсли;
//		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
//		НужнаЗапятая = Истина;
//	КонецЦикла;
//	Для Каждого Строка Из ТаблицаЗначений Цикл
//		НоваяСтрока = Новый Структура(СтруктураСтрокой);
//		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
//		Массив.Добавить(НоваяСтрока);
//	КонецЦикла;
//	Возврат Массив;

//КонецФункции

//// Функция СтрокаТаблицыЗначенийВСтруктуру создает
//// структуру со свойствами, как колонки таблицы
//// значений передаваемой строки
//// и устанавливает этим свойствам значения
//// из строки таблицы значений
//// 
//// Параметры:
////  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений
////
//// ВозвращаемоеЗначение:
////  Структура
////
//Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
//	
//	Структура = Новый Структура;
//	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
//		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
//	КонецЦикла;
//	
//	Возврат Структура;
//	
//КонецФункции

//// Получает строку, содержащую ключи структуры, разделенные символом разделителя.
////
//// Параметры:
////	Структура - Структура - Структура, ключи которой преобразуются в строку
////	Разделитель - Строка - Разделитель, который вставляется в строку между ключами структуры
////
//// Возвращаемое значение:
////	Строка - Строка, содержащая ключи структуры разделенные резделителем
////
//Функция КлючиСтруктурыВСтроку(Структура, Разделитель = ",") Экспорт
//	
//	Результат = "";
//	
//	Для Каждого Элемент Из Структура Цикл
//		
//		СимволРазделителя = ?(ПустаяСтрока(Результат), "", Разделитель);
//		
//		Результат = Результат + СимволРазделителя + Элемент.Ключ;
//		
//	КонецЦикла;
//	
//	Возврат Результат;
//КонецФункции

//// Преобразует текст формата XML в таблицу значений,
//// при этом колонки таблицы формируются на основе описания в XML.
////
//// Параметры:
////  ТекстXML     - текст в формате XML.
////
//// Схема XML:
////<?xml version="1.0" encoding="utf-8"?>
////<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
////  <xs:element name="Items">
////	<xs:complexType>
////	  <xs:sequence>
////		<xs:element maxOccurs="unbounded" name="Item">
////		  <xs:complexType>
////			<xs:attribute name="Code" type="xs:integer" use="required" />
////			<xs:attribute name="Name" type="xs:string" use="required" />
////			<xs:attribute name="Socr" type="xs:string" use="required" />
////			<xs:attribute name="Index" type="xs:string" use="required" />
////		  </xs:complexType>
////		</xs:element>
////	  </xs:sequence>
////	  <xs:attribute name="Description" type="xs:string" use="required" />
////	  <xs:attribute name="Columns" type="xs:string" use="required" />
////	</xs:complexType>
////  </xs:element>
////</xs:schema>
////
//// Примеры XML-файлов см. в демонстрационной конфигурации.
//// 
//// Пример использования:
////   КлассификаторТаблица = ПрочитатьXMLВТаблицу(РегистрыСведений.АдресныйКлассификатор.
////       ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст());
////
//// Возвращаемое значение:
////  ТаблицаЗначений.
////
//Функция ПрочитатьXMLВТаблицу(ТекстXML) Экспорт
//	
//	Чтение = Новый ЧтениеXML;
//	Чтение.УстановитьСтроку(ТекстXML);
//	
//	// Прочитаем первый узел и проверим его
//	Если Не Чтение.Прочитать() Тогда
//		ВызватьИсключение("Пустой XML");
//	ИначеЕсли Чтение.Имя <> "Items" Тогда
//		ВызватьИсключение("Ошибка в структуре XML");
//	КонецЕсли;
//	
//	// Получим описание таблицы и создадим ее
//	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
//	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
//	Колонок = СтрЧислоСтрок(ИменаКолонок);
//	
//	ТаблицаЗначений = Новый ТаблицаЗначений;
//	Для Сч = 1 По Колонок Цикл
//		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
//	КонецЦикла;
//	
//	// Заполним значения в таблице
//	Пока Чтение.Прочитать() Цикл
//		
//		Если Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
//			Продолжить;
//		ИначеЕсли Чтение.Имя <> "Item" Тогда
//			ВызватьИсключение("Ошибка в структуре XML");
//		КонецЕсли;
//		
//		новСтр = ТаблицаЗначений.Добавить();
//		Для Сч = 1 По Колонок Цикл
//			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
//			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
//		КонецЦикла;
//		
//	КонецЦикла;
//	
//	// Заполним результат
//	Результат = Новый Структура;
//	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
//	Результат.Вставить("Данные", ТаблицаЗначений);
//	
//	Возврат Результат;
//	
//КонецФункции // ПрочитатьXMLВТаблицу()

//// Возвращает признак того, что реквизит входит в подмножество стандартных реквизитов
////
//// Параметры:
////  СтандартныеРеквизиты – ОписанияСтандартныхРеквизитов - тип и значение описывает коллекцию настроек различных стандартных реквизитов;
////  ИмяРеквизита – Строка – реквизит который необходимо проверить на принадлежность множеству стандартных реквизитов;
//// 
////  Возвращаемое значение:
//// Тип: Булево. Истина -  реквизит входит в подмножество стандартных реквизитов; Ложь – нет.
////
//Функция ЭтоСтандартныйРеквизит(СтандартныеРеквизиты, ИмяРеквизита) Экспорт
//	
//	Для Каждого Реквизит ИЗ СтандартныеРеквизиты Цикл
//		
//		Если Реквизит.Имя = ИмяРеквизита Тогда
//			
//			Возврат Истина;
//			
//		КонецЕсли;
//		
//	КонецЦикла;
//	
//	Возврат Ложь;
//	
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// Общие процедуры и функции для работы с данными в базе

//// Проверяет проведенность документов
////
//// Параметры:
////  Документы - Массив - документы, проведенность которых необходимо проверить
////
//// Возвращаемое значение:
////  Массив - непроведенные документы из массива Документы
////
//Функция ПроверитьПроведенностьДокументов(знач Документы) Экспорт
//	
//	Результат = Новый Массив;
//	
//	ШаблонЗапроса = 	
//		"ВЫБРАТЬ
//		|	Документ.Ссылка КАК Ссылка
//		|ИЗ
//		|	&ИмяДокумента КАК Документ
//		|ГДЕ
//		|	Документ.Ссылка В(&МассивДокументов)
//		|	И (НЕ Документ.Проведен)";
//	
//	ТекстОбъединитьВсе =
//		"
//		|
//		|ОБЪЕДИНИТЬ ВСЕ
//		|
//		|";
//		
//	ИменаДокументов = Новый Массив;
//	Для Каждого Документ Из Документы Цикл
//		ИмяДокумента = Документ.Метаданные().ПолноеИмя();
//		Если ИменаДокументов.Найти(ИмяДокумента) = Неопределено
//		   и Метаданные.Документы.Содержит(Метаданные.НайтиПоПолномуИмени(ИмяДокумента)) Тогда	
//			ИменаДокументов.Добавить(ИмяДокумента);
//		КонецЕсли;
//	КонецЦикла;
//	
//	ТекстЗапроса = "";
//	Для Каждого ИмяДокумента Из ИменаДокументов Цикл
//		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
//			ТекстЗапроса = ТекстЗапроса + ТекстОбъединитьВсе;
//		КонецЕсли;
//		ТекстПодзапроса = СтрЗаменить(ШаблонЗапроса, "&ИмяДокумента", ИмяДокумента);
//		ТекстЗапроса = ТекстЗапроса + ТекстПодзапроса;
//	КонецЦикла;
//		
//	Запрос = Новый Запрос;
//	Запрос.Текст = ТекстЗапроса;
//	Запрос.УстановитьПараметр("МассивДокументов", Документы);
//	
//	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
//		Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
//	КонецЕсли;
//	
//	Возврат Результат;
//	
//КонецФункции

//// Процедура выполняет проведение документов перед формированием печатной формы.
////
//// Параметры:
////	Документы                - Массив - документы, которые необходимо провести
////  ТипПроведенныхДокументов - Тип    - возвращает тип документов в массиве
////
//// Возвращаемое значение:
////	Массив - документы, которые провести не удалось, и описания ошибок.
////
//Функция ПровестиДокументы(Документы, ТипПроведенныхДокументов) Экспорт
//	
//	ИмяДокумента = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
//		Документы[0].Метаданные().ПолноеИмя(), ".")[1];
//	ТипПроведенныхДокументов = ТипЗнч(Документы[0]);
//	НепроведенныеДокументы = Новый Массив;
//	
//	Для Каждого ДокументСсылка Из Документы Цикл
//		
//		ВыполненоУспешно = Ложь;
//		ДокументОбъект = ДокументСсылка.ПолучитьОбъект();
//		Если ДокументОбъект.ПроверитьЗаполнение() Тогда
//			Попытка
//				ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
//				ВыполненоУспешно = Истина;
//			Исключение
//				ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
//				ТекстСообщенияОбОшибке = НСтр("ru = 'Ошибка при попытке проведения документа: %1'");
//				ТекстСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСообщенияОбОшибке, ПредставлениеОшибки);
//				ЗаписьЖурналаРегистрации(НСтр("ru = 'Проведение документов при печати'"),
//					УровеньЖурналаРегистрации.Информация, ДокументОбъект.Метаданные(), ДокументСсылка, 
//					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
//			КонецПопытки;
//		Иначе
//			ПредставлениеОшибки = НСтр("ru = 'Поля документа не заполнены.'");
//		КонецЕсли;
//		
//		Если Не ВыполненоУспешно Тогда
//			НепроведенныеДокументы.Добавить(Новый Структура("Ссылка,ОписаниеОшибки", ДокументСсылка, ПредставлениеОшибки));
//		КонецЕсли;
//		
//	КонецЦикла;
//	
//	Возврат НепроведенныеДокументы;
//	
//КонецФункции 

//// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
//// по ссылке на объект.
//// 
////  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
////  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
////  то следует использовать предварительный переход в привилегированный режим.
//// 
//// Параметры:
////  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
////  ИменаРеквизитов - Строка или Структура - если Строка, то имена реквизитов, 
////               перечисленные через запятую, в формате требований к свойствам структуры.
////               Например, "Код, Наименование, Родитель".
////               Если Структура, то в качестве ключа передается псевдоним поля для
////               возвращаемой структуры с результатом, а в качестве значения (опционально) 
////               - фактическое имя поля в таблице. 
////               Если значение не определено, то имя поля берется из ключа.
//// 
//// Возвращаемое значение:
////  Структура    - содержит список свойств, как список имен в строке
////                 ИменаРеквизитов, со значениям реквизитов, прочитанных
////                 из информационной базы.
//// 
//Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт

//	Если ТипЗнч(ИменаРеквизитов) = Тип("Структура") Тогда
//		СтруктураРеквизитов = ИменаРеквизитов;
//	ИначеЕсли ТипЗнч(ИменаРеквизитов) = Тип("Строка") Тогда
//		СтруктураРеквизитов = Новый Структура(ИменаРеквизитов);;
//	Иначе
//		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
//			НСтр("ru = 'Неверный тип второго параметра ИменаИлиСтруктураРеквизитов: %1'"), 
//			Строка(ТипЗнч(ИменаРеквизитов)));
//	КонецЕсли;

//	ТекстПолей = "";
//	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
//		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение), СокрЛП(КлючИЗначение.Значение), СокрЛП(КлючИЗначение.Ключ));
//		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
//		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
//			|	" + ИмяПоля + " КАК " + Псевдоним;
//	КонецЦикла;

//	Запрос = Новый Запрос(
//		"ВЫБРАТЬ
//		|" + ТекстПолей + "
//		|ИЗ
//		|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
//		|ГДЕ
//		|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
//		|");
//	Запрос.УстановитьПараметр("Ссылка", Ссылка);
//	Выборка = Запрос.Выполнить().Выбрать();
//	Выборка.Следующий();

//	Результат = Новый Структура;
//	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
//		Результат.Вставить(КлючИЗначение.Ключ);
//	КонецЦикла;
//	ЗаполнитьЗначенияСвойств(Результат, Выборка);

//	Возврат Результат;
//КонецФункции

//// Функция ПолучитьЗначениеРеквизита возвращает значение
//// реквизита, прочитанного из информационной базы по ссылке на объект.
//// 
////  Если доступа к реквизиту нет, возникнет исключение прав доступа.
////  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
////  то следует использовать предварительный переход в привилегированный режим.
//// 
//// Параметры:
////  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
////  ИмяРеквизита - Строка, например, "Код".
//// 
//// Возвращаемое значение:
////  Произвольный    - зависит от типа значения прочитанного реквизита.
//// 
//Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
//	
//	Результат = ПолучитьЗначенияРеквизитов(Ссылка, ИмяРеквизита);
//	Возврат Результат[ИмяРеквизита];
//	
//КонецФункции 

//// Выполняет сравнение версий двух однотипных объектов.
////
////  Параметры:
//// Данные1 (обязательный). Тип: 
////  СправочникОбъект,
////  ДокументОбъект,
////  ПланВидовХарактеристикОбъект,
////  ПланВидовРасчетаОбъект,
////  ПланСчетовОбъект,
////  ПланОбменаОбъект,
////  БизнесПроцессОбъект,
////  ЗадачаОбъект.
//// Первая версия данных для сравнения.
////
//// Данные2 (обязательный). Тип: см. тип параметра Данные1
//// Вторая версия данных для сравнения.
////
//// СписокСвойств (необязательный). Тип: Строка.
//// Список свойств объекта и табличных частей, разделенных запятыми. 
//// Если параметр задан, то сравнение версий данных будет выполняться согласно 
//// заданным свойствам, при этом параметр ИсключаяСвойства будет проигнорирован.
////
//// ИсключаяСвойства (необязательный). Тип: Строка.
//// Список свойств объекта и табличных частей, разделенных запятыми.
//// Если параметр задан, то сравнение версий данных будет выполняться 
//// для всех свойств и табличных частей, исключая заданные свойства.
////
//// Возвращаемое значение:
//// Тип: Булево.
//// Возвращает Истина, если версии данных различаются; Ложь, если версии совпадают.
////
//Функция ДанныеРазличаются(Данные1, Данные2, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
//	
//	Если ТипЗнч(Данные1) <> ТипЗнч(Данные2) Тогда
//		Возврат Истина;
//	КонецЕсли;
//	
//	ОбъектМетаданных = Данные1.Метаданные();
//	
//	Если ЭтоСправочник(ОбъектМетаданных) Тогда
//		
//		Если Данные1.ЭтоГруппа Тогда
//			Объект1 = Справочники[ОбъектМетаданных.Имя].СоздатьГруппу();
//		Иначе
//			Объект1 = Справочники[ОбъектМетаданных.Имя].СоздатьЭлемент();
//		КонецЕсли;
//		
//		Если Данные2.ЭтоГруппа Тогда
//			Объект2 = Справочники[ОбъектМетаданных.Имя].СоздатьГруппу();
//		Иначе
//			Объект2 = Справочники[ОбъектМетаданных.Имя].СоздатьЭлемент();
//		КонецЕсли;
//		
//	ИначеЕсли ЭтоДокумент(ОбъектМетаданных) Тогда
//		
//		Объект1 = Документы[ОбъектМетаданных.Имя].СоздатьДокумент();
//		Объект2 = Документы[ОбъектМетаданных.Имя].СоздатьДокумент();
//		
//	ИначеЕсли ЭтоПланВидовХарактеристик(ОбъектМетаданных) Тогда
//		
//		Если Данные1.ЭтоГруппа Тогда
//			Объект1 = ПланыВидовХарактеристик[ОбъектМетаданных.Имя].СоздатьГруппу();
//		Иначе
//			Объект1 = ПланыВидовХарактеристик[ОбъектМетаданных.Имя].СоздатьЭлемент();
//		КонецЕсли;
//		
//		Если Данные2.ЭтоГруппа Тогда
//			Объект2 = ПланыВидовХарактеристик[ОбъектМетаданных.Имя].СоздатьГруппу();
//		Иначе
//			Объект2 = ПланыВидовХарактеристик[ОбъектМетаданных.Имя].СоздатьЭлемент();
//		КонецЕсли;
//		
//	ИначеЕсли ЭтоПланВидовРасчета(ОбъектМетаданных) Тогда
//		
//		Объект1 = ПланыВидовРасчета[ОбъектМетаданных.Имя].СоздатьВидРасчета();
//		Объект2 = ПланыВидовРасчета[ОбъектМетаданных.Имя].СоздатьВидРасчета();
//		
//	ИначеЕсли ЭтоПланСчетов(ОбъектМетаданных) Тогда
//		
//		Объект1 = ПланыСчетов[ОбъектМетаданных.Имя].СоздатьСчет();
//		Объект2 = ПланыСчетов[ОбъектМетаданных.Имя].СоздатьСчет();
//		
//	ИначеЕсли ЭтоПланОбмена(ОбъектМетаданных) Тогда
//		
//		Объект1 = ПланыОбмена[ОбъектМетаданных.Имя].СоздатьУзел();
//		Объект2 = ПланыОбмена[ОбъектМетаданных.Имя].СоздатьУзел();
//		
//	ИначеЕсли ЭтоБизнесПроцесс(ОбъектМетаданных) Тогда
//		
//		Объект1 = БизнесПроцессы[ОбъектМетаданных.Имя].СоздатьБизнесПроцесс();
//		Объект2 = БизнесПроцессы[ОбъектМетаданных.Имя].СоздатьБизнесПроцесс();
//		
//	ИначеЕсли ЭтоЗадача(ОбъектМетаданных) Тогда
//		
//		Объект1 = Задачи[ОбъектМетаданных.Имя].СоздатьЗадачу();
//		Объект2 = Задачи[ОбъектМетаданных.Имя].СоздатьЗадачу();
//		
//	Иначе
//		
//		ВызватьИсключение НСтр("ru = 'Задано недопустимое значение параметра [1] метода ОбщегоНазначения.ЗначенияСвойствИзменены.'");
//		
//	КонецЕсли;
//	
//	ЗаполнитьЗначенияСвойств(Объект1, Данные1, СписокСвойств, ИсключаяСвойства);
//	ЗаполнитьЗначенияСвойств(Объект2, Данные2, СписокСвойств, ИсключаяСвойства);
//	
//	ТабличныеЧасти = ТабличныеЧастиОбъекта(ОбъектМетаданных);
//	
//	Если СписокСвойств <> Неопределено Тогда
//		
//		Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
//			
//			Если Найти(СписокСвойств, ТабличнаяЧасть) = 0 Тогда
//				Продолжить;
//			КонецЕсли;
//			
//			Объект1[ТабличнаяЧасть].Загрузить(Данные1[ТабличнаяЧасть].Выгрузить());
//			Объект2[ТабличнаяЧасть].Загрузить(Данные2[ТабличнаяЧасть].Выгрузить());
//			
//		КонецЦикла;
//		
//	ИначеЕсли ИсключаяСвойства <> Неопределено Тогда
//		
//		Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
//			
//			Если Найти(ИсключаяСвойства, ТабличнаяЧасть) <> 0 Тогда
//				Продолжить;
//			КонецЕсли;
//			
//			Объект1[ТабличнаяЧасть].Загрузить(Данные1[ТабличнаяЧасть].Выгрузить());
//			Объект2[ТабличнаяЧасть].Загрузить(Данные2[ТабличнаяЧасть].Выгрузить());
//			
//		КонецЦикла;
//		
//	Иначе
//		
//		Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
//			
//			Объект1[ТабличнаяЧасть].Загрузить(Данные1[ТабличнаяЧасть].Выгрузить());
//			Объект2[ТабличнаяЧасть].Загрузить(Данные2[ТабличнаяЧасть].Выгрузить());
//			
//		КонецЦикла;
//		
//	КонецЕсли;
//	
//	Возврат ДанныеИнформационнойБазыСтрокой(Объект1) <> ДанныеИнформационнойБазыСтрокой(Объект2);
//	
//КонецФункции

//Функция ДанныеИнформационнойБазыСтрокой(Данные)
//	
//	ЗаписьXML = Новый ЗаписьXML;
//	ЗаписьXML.УстановитьСтроку();
//	
//	ЗаписатьXML(ЗаписьXML, Данные, НазначениеТипаXML.Явное);
//	
//	Возврат ЗаписьXML.Закрыть();
//	
//КонецФункции

//Функция ТабличныеЧастиОбъекта(ОбъектМетаданных)
//	
//	Результат = Новый Массив;
//	
//	Для Каждого ТабличнаяЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
//		
//		Результат.Добавить(ТабличнаяЧасть.Имя);
//		
//	КонецЦикла;
//	
//	Возврат Результат;
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// Процедуры и функции для работы с внешним соединением

//// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
////
//Функция ИмяCOMСоединителя() Экспорт
//	
//	СистемнаяИнфо = Новый СистемнаяИнформация;
//	ПодстрокиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
//		СистемнаяИнфо.ВерсияПриложения, ".");
//	Возврат "v" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + ".COMConnector";
//	
//КонецФункции	

//// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
//// 
//// Параметры:
////  Параметры - Структура - содержит параметры для установки внешнего соединения с информационной базой.
////  Структура должна содержать следующие ключи (см. функция ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
////
////	  ВариантРаботыИнформационнойБазы             - (Число)  Вариант работы информационной базы: 0 – файловый; 1 – клиент-серверный
////	  КаталогИнформационнойБазы                   - (Строка) Каталог информационной базы для файлового режима работы
////	  ИмяСервера1СПредприятия                     - (Строка) Имя сервера1С:Предприятия
////	  ИмяИнформационнойБазыНаСервере1СПредприятия - (Строка) Имя информационной базы на сервере1С:Предприятия
////	  АутентификацияОперационнойСистемы           - (Булево) Признак аутентификации операционной системы при создании внешнего подключения к информационной базе
////	  ИмяПользователя                             - (Строка) Имя пользователя информационной базы
////	  ПарольПользователя                          - (Строка) Пароль пользователя информационной базы
//// 
////  СтрокаСообщенияОбОшибке (необязательный) – Строка – если в процессе установки внешнего соединения возникает ошибка,
////                                                     то подробное описание ошибки помещается в этот параметр
////
//// Возвращаемое значение:
////  Тип: COM-объект, Неопределенно.
////  в случае успешной установки внешнего соединения возвращается указатель на COM-объект соединения;
////  в случае ошибки возвращается Неопределенно.
////
//Функция УстановитьВнешнееСоединение(Параметры, СтрокаСообщенияОбОшибке = "", ОшибкаПодключенияКомпоненты = Ложь) Экспорт
//	
//	// возвращаемое значение функции (COM-объект)
//	Connection = Неопределено;
//	
//	Попытка
//		COMConnector = Новый COMObject(ИмяCOMСоединителя()); // "V82.COMConnector"
//	Исключение
//		СтрокаСообщенияОбОшибке = НСтр("ru = 'При установке внешнего соединения произошла ошибка: %1'");
//		СтрокаСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
//		ОшибкаПодключенияКомпоненты = Истина;
//		Возврат Неопределено;
//	КонецПопытки;
//	
//	Если Параметры.ВариантРаботыИнформационнойБазы = 0 Тогда
//		
//		Если ПустаяСтрока(Параметры.КаталогИнформационнойБазы) Тогда
//			
//			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не задано месторасположение каталога информационной базы.'");
//			Возврат Неопределено;
//			
//		КонецЕсли;
//		
//		Если Параметры.АутентификацияОперационнойСистемы Тогда
//			
//			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""";
//			
//			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
//			
//		Иначе
//			
//			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
//			
//			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
//			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",           Параметры.ИмяПользователя);
//			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",        Параметры.ПарольПользователя);
//			
//		КонецЕсли;
//		
//	Иначе // Клиент-серверный вариант работы информационной базы
//		
//		Если    ПустаяСтрока(Параметры.ИмяСервера1СПредприятия)
//			ИЛИ ПустаяСтрока(Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия) Тогда
//			
//			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не заданы обязательные параметры подключения: ""Имя сервера""; ""Имя информационной базы на сервере"".'");
//			Возврат Неопределено;
//			
//		КонецЕсли;
//		
//		Если Параметры.АутентификацияОперационнойСистемы Тогда
//			
//			СтрокаСоединения = "Srvr = &ИмяСервера1СПредприятия; Ref = &ИмяИнформационнойБазыНаСервере1СПредприятия";
//			
//			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
//			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
//			
//		Иначе
//			
//			СтрокаСоединения = "Srvr = &ИмяСервера1СПредприятия; Ref = &ИмяИнформационнойБазыНаСервере1СПредприятия; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
//			
//			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
//			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
//			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",                             Параметры.ИмяПользователя);
//			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",                          Параметры.ПарольПользователя);
//			
//		КонецЕсли;
//		
//	КонецЕсли;
//	
//	Попытка
//		Connection = COMConnector.Connect(СтрокаСоединения);
//	Исключение
//		
//		ПодробноеПредставлениеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
//		
//		СтрокаСообщенияОбОшибке = НСтр("ru = 'При установке внешнего соединения произошла ошибка: %1'");
//		СтрокаСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки);
//		Возврат Неопределено;
//	КонецПопытки;
//	
//	Возврат Connection;
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// Функции для работы с журналом регистрации

//// Процедура пакетной записи сообщений в журнал регистрации
//// 
//// Параметры: СобытияДляЖурналаРегистрации - массив структур, клиентская глобальная переменная 
//// Каждая структура - сообщение для журнала регистрации.
//// После записи переменная очищается.
//Процедура ЗаписатьСобытияВЖурналРегистрации(СобытияДляЖурналаРегистрации) Экспорт
//	
//	Если ТипЗнч(СобытияДляЖурналаРегистрации) <> Тип("СписокЗначений") Тогда
//		Возврат;
//	КонецЕсли;	
//	
//	Если СобытияДляЖурналаРегистрации.Количество() = 0 Тогда
//		Возврат;
//	КонецЕсли;
//	
//	Для Каждого СообщениеЖурнала Из СобытияДляЖурналаРегистрации Цикл
//		ЗначениеСообщения = СообщениеЖурнала.Значение;
//		ИмяСобытия = ЗначениеСообщения.ИмяСобытия;
//		УровеньСобытия = УровеньСобытияПоПредставлению(ЗначениеСообщения.ПредставлениеУровня);
//		Комментарий = ЗначениеСообщения.Комментарий;
//		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньСобытия,,, Комментарий);
//	КонецЦикла;
//	СобытияДляЖурналаРегистрации.Очистить();
//	
//КонецПроцедуры

//// Процедура ведения в журнале регистрации событий
////
//// Параметры: СписокУровней - список значений, 
//// Наименования уровней регистрации событий, которые необходимо включить
//Процедура ВключитьИспользованиеЖурналаРегистрации(СписокУровней = Неопределено) Экспорт
//	УстановитьПривилегированныйРежим(Истина);
//	Попытка
//		УстановитьМонопольныйРежим(Истина);
//		МассивУровней = Новый Массив();
//		
//		Если СписокУровней = Неопределено Тогда
//			МассивУровней.Добавить(УровеньЖурналаРегистрации.Информация);
//			МассивУровней.Добавить(УровеньЖурналаРегистрации.Ошибка);
//			МассивУровней.Добавить(УровеньЖурналаРегистрации.Предупреждение);
//			МассивУровней.Добавить(УровеньЖурналаРегистрации.Примечание);
//		Иначе
//			МассивУровней = УровниСобытияЖурналаРегистрацииПоСтроке(СписокУровней);
//		КонецЕсли;
//			
//		УстановитьИспользованиеЖурналаРегистрации(МассивУровней);	
//		УстановитьМонопольныйРежим(Ложь);
//	Исключение
//		УстановитьПривилегированныйРежим(Ложь);	
//		ВызватьИсключение
//	КонецПопытки;
//	УстановитьПривилегированныйРежим(Ложь);	
//КонецПроцедуры

//// Проверяет, включена ли регистрация событий в журнале регистрации
////
//// Параметры: 
//// СписокПроверок - СписокЗначений, список строк-представлений режимов использования журнала регистрации, которые надо проверить на включение.
////					Если Неопределено - тогда проверяются все режимы.
////
//// Возвращаемое значение: Истина, когда заданные режимы включены. Иначе - ложь.
//Функция ПроверитьВключениеЖурналаРегистрации(СписокПроверок = Неопределено) Экспорт	
//	МассивРежимов = ПолучитьИспользованиеЖурналаРегистрации();
//	Если СписокПроверок = Неопределено Тогда
//		Возврат МассивРежимов.Количество() = 4 ;
//	Иначе
//		МассивНазванийРежимов =  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СписокПроверок);
//		Для Каждого Название Из МассивНазванийРежимов Цикл
//			ТекущийПроверяемыйРежим = УровеньСобытияПоПредставлению(Название);
//			Если МассивРежимов.Найти(ТекущийПроверяемыйРежим) = Неопределено Тогда
//				Возврат Ложь;
//			КонецЕсли;
//		КонецЦикла;
//	КонецЕсли;
//	Возврат Истина;
//КонецФункции

//Функция УровеньСобытияПоПредставлению(ПредставлениеУровня)
//	Если ПредставлениеУровня = "Информация" Тогда
//		Возврат УровеньЖурналаРегистрации.Информация;
//	ИначеЕсли ПредставлениеУровня = "Ошибка" Тогда
//		Возврат УровеньЖурналаРегистрации.Ошибка;
//	ИначеЕсли ПредставлениеУровня = "Предупреждение" Тогда
//		Возврат УровеньЖурналаРегистрации.Предупреждение; 
//	ИначеЕсли ПредставлениеУровня = "Примечание" Тогда
//		Возврат УровеньЖурналаРегистрации.Примечание;
//	КонецЕсли;	
//КонецФункции

//Функция УровниСобытияЖурналаРегистрацииПоСтроке(СписокУровней)
//	МассивНазванийУровней = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СписокУровней);
//	МассивУровней = Новый Массив;
//	Для Каждого Название Из МассивНазванийУровней Цикл
//		МассивУровней.Добавить(УровеньСобытияПоПредставлению(Название));
//	КонецЦикла;
//	Возврат МассивУровней;
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// Процедуры и функции для работы с типами, объектами метаданных и их строковыми представлениями.

//// Получает дерево метаданных конфигурации с заданным отбором по объектам метаданных.
////
//// Параметры:
//// Отбор – Структура – содержит значения элементов отбора.
////						Если параметр задан, то будет получено дерево метаданных в соответствии с заданным отбором. 
////						Ключ (Строка) – имя свойства элемента метаданных;
////						Значение (Массив) – множество значений для отбора.
////
//// Пример инициализации переменной "Отбор":
////
//// Массив = Новый Массив;
//// Массив.Добавить("Константа.ИспользоватьОбменДанными");
//// Массив.Добавить("Справочник.Валюты");
//// Массив.Добавить("Справочник.Организации");
//// Отбор = Новый Структура;
//// Отбор.Вставить("ПолноеИмя", Массив);
//// 
////  Возвращаемое значение:
////  Тип: ДеревоЗначений - дерево описания метаданных конфигурации
////
//Функция ПолучитьДеревоМетаданныхКонфигурации(Отбор = Неопределено) Экспорт
//	
//	ИспользоватьОтбор = (Отбор <> Неопределено);
//	
//	КоллекцииОбъектовМетаданных = Новый ТаблицаЗначений;
//	КоллекцииОбъектовМетаданных.Колонки.Добавить("Имя");
//	КоллекцииОбъектовМетаданных.Колонки.Добавить("Синоним");
//	КоллекцииОбъектовМетаданных.Колонки.Добавить("Картинка");
//	КоллекцииОбъектовМетаданных.Колонки.Добавить("КартинкаОбъекта");
//	
//	НоваяСтрокаКоллекцииОбъектовМетаданных("Константы",               "Константы",                 БиблиотекаКартинок.Константа,              БиблиотекаКартинок.Константа,                    КоллекцииОбъектовМетаданных);
//	НоваяСтрокаКоллекцииОбъектовМетаданных("Справочники",             "Справочники",               БиблиотекаКартинок.Справочник,             БиблиотекаКартинок.Справочник,                   КоллекцииОбъектовМетаданных);
//	НоваяСтрокаКоллекцииОбъектовМетаданных("Документы",               "Документы",                 БиблиотекаКартинок.Документ,               БиблиотекаКартинок.ДокументОбъект,               КоллекцииОбъектовМетаданных);
//	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовХарактеристик", "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
//	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыСчетов",             "Планы счетов",              БиблиотекаКартинок.ПланСчетов,             БиблиотекаКартинок.ПланСчетовОбъект,             КоллекцииОбъектовМетаданных);
//	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовРасчета",       "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
//	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыСведений",        "Регистры сведений",         БиблиотекаКартинок.РегистрСведений,        БиблиотекаКартинок.РегистрСведений,              КоллекцииОбъектовМетаданных);
//	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыНакопления",      "Регистры накопления",       БиблиотекаКартинок.РегистрНакопления,      БиблиотекаКартинок.РегистрНакопления,            КоллекцииОбъектовМетаданных);
//	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыБухгалтерии",     "Регистры бухгалтерии",      БиблиотекаКартинок.РегистрБухгалтерии,     БиблиотекаКартинок.РегистрБухгалтерии,           КоллекцииОбъектовМетаданных);
//	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыРасчета",         "Регистры расчета",          БиблиотекаКартинок.РегистрРасчета,         БиблиотекаКартинок.РегистрРасчета,               КоллекцииОбъектовМетаданных);
//	НоваяСтрокаКоллекцииОбъектовМетаданных("БизнесПроцессы",          "Бизнес-процессы",           БиблиотекаКартинок.БизнесПроцесс,          БиблиотекаКартинок.БизнесПроцессОбъект,          КоллекцииОбъектовМетаданных);
//	НоваяСтрокаКоллекцииОбъектовМетаданных("Задачи",                  "Задачи",                    БиблиотекаКартинок.Задача,                 БиблиотекаКартинок.ЗадачаОбъект,                 КоллекцииОбъектовМетаданных);
//	
//	// возвращаемое значение функции
//	ДеревоМетаданных = Новый ДеревоЗначений;
//	ДеревоМетаданных.Колонки.Добавить("Имя");
//	ДеревоМетаданных.Колонки.Добавить("ПолноеИмя");
//	ДеревоМетаданных.Колонки.Добавить("Синоним");
//	ДеревоМетаданных.Колонки.Добавить("Картинка");
//	
//	Для Каждого СтрокаКоллекции Из КоллекцииОбъектовМетаданных Цикл
//		
//		СтрокаДерева = ДеревоМетаданных.Строки.Добавить();
//		
//		ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаКоллекции);
//		
//		Для Каждого ОбъектМетаданных Из Метаданные[СтрокаКоллекции.Имя] Цикл
//			
//			// ============================ {Фильтр}
//			Если ИспользоватьОтбор Тогда
//				
//				ОбъектПрошелФильтр = Истина;
//				
//				Для Каждого ЭлементОтбора Из Отбор Цикл
//					
//					Значение = ?(ВРег(ЭлементОтбора.Ключ) = ВРег("ПолноеИмя"), ОбъектМетаданных.ПолноеИмя(), ОбъектМетаданных[ЭлементОтбора.Ключ]);
//					
//					Если ЭлементОтбора.Значение.Найти(Значение) = Неопределено Тогда
//						
//						ОбъектПрошелФильтр = Ложь;
//						
//						Прервать;
//						
//					КонецЕсли;
//					
//				КонецЦикла;
//				
//				Если Не ОбъектПрошелФильтр Тогда
//					
//					Продолжить;
//					
//				КонецЕсли;
//				
//			КонецЕсли;
//			// ============================ {Фильтр}
//			
//			СтрокаДереваОМ = СтрокаДерева.Строки.Добавить();
//			СтрокаДереваОМ.Имя       = ОбъектМетаданных.Имя;
//			СтрокаДереваОМ.ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
//			СтрокаДереваОМ.Синоним   = ОбъектМетаданных.Синоним;
//			СтрокаДереваОМ.Картинка  = СтрокаКоллекции.КартинкаОбъекта;
//			
//		КонецЦикла;
//		
//	КонецЦикла;
//	
//	// удаляем строки без подчиненных элементов
//	Если ИспользоватьОтбор Тогда
//		
//		// используем обратный порядок обхода дерева значений
//		КолвоЭлементовКоллекции = ДеревоМетаданных.Строки.Количество();
//		
//		Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
//			
//			ТекущийИндекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
//			
//			СтрокаДерева = ДеревоМетаданных.Строки[ТекущийИндекс];
//			
//			Если СтрокаДерева.Строки.Количество() = 0 Тогда
//				
//				ДеревоМетаданных.Строки.Удалить(ТекущийИндекс);
//				
//			КонецЕсли;
//			
//		КонецЦикла;
//	
//	КонецЕсли;
//	
//	Возврат ДеревоМетаданных;
//	
//КонецФункции

//Процедура НоваяСтрокаКоллекцииОбъектовМетаданных(Имя, Синоним, Картинка, КартинкаОбъекта, Таб)
//	
//	НоваяСтрока = Таб.Добавить();
//	НоваяСтрока.Имя               = Имя;
//	НоваяСтрока.Синоним           = Синоним;
//	НоваяСтрока.Картинка          = Картинка;
//	НоваяСтрока.КартинкаОбъекта   = КартинкаОбъекта;
//	
//КонецПроцедуры

//// Возвращает строку реквизитов объекта метаданных с заданным типом
////
//// Параметры:
////  Ссылка – ЛюбаяСсылка – ссылка на элемент базы данных, для которого требуется получить результат функции
////  Тип    – Тип – тип значения реквизита
//// 
////  Возвращаемое значение:
//// Тип: Строка – строка реквизитов объекта метаданных конфигурации, разделенные символом ","
////
//Функция ИменаРеквизитовПоТипу(Ссылка, Тип) Экспорт
//	
//	Результат = "";
//	МетаданныеОбъекта = Ссылка.Метаданные();
//	
//	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
//		Если Реквизит.Тип.СодержитТип(Тип) Тогда
//			Результат = Результат + ?(ПустаяСтрока(Результат), "", ", ") + Реквизит.Имя;
//		КонецЕсли;
//	КонецЦикла;
//	
//	Возврат Результат;
//КонецФункции

//// Получает имя значения перечисления как объекта метаданных
////
//// Параметры:
////  Значение - значение перечисления для которого необходимо получить имя перечисления
////
//// Возвращаемое значение:
////  Строка - имя значения перечисления как объекта метаданных
////
//Функция ИмяЗначенияПеречисления(Значение) Экспорт
//	
//	ОбъектМетаданных = Значение.Метаданные();
//	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);
//	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
//	
//КонецФункции 

//// Возвращает менеджер объекта по полному имени объекта метаданных
////
//// Не обрабатываются точки маршрутов бизнес-процессов
////
//// Параметры:
////  ПолноеИмя    - Строка, полное имя объекта метаданных,
////                 например, "Справочник.Организации"
////
//// Возвращаемое значение:
////  СправочникМенеджер, ДокументМенеджер, ...
//// 
//Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
//	
//	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
//	
//	КлассОМ = ЧастиИмени[0];
//	ИмяОМ   = ЧастиИмени[1];
//	
//	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
//		Возврат ПланыОбмена[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
//		Возврат Справочники[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
//		Возврат Документы[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
//		Возврат ЖурналыДокументов[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
//		Возврат Перечисления[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
//		Возврат Отчеты[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
//		Возврат Обработки[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
//		Возврат ПланыВидовХарактеристик[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
//		Возврат ПланыСчетов[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
//		Возврат ПланЫВидовРасчета[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
//		Возврат РегистрыСведений[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
//		Возврат РегистрыНакопления[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
//		Возврат РегистрыБухгалтерии[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
//		Возврат РегистрыРасчета[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
//		Возврат БизнесПроцессы[ИмяОМ];
//		
//	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
//		Возврат Задачи[ИмяОМ];
//	Иначе
//		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
//			НСтр("ru='Неизвестный тип объекта метаданных (%1)'"), КлассОМ);
//	КонецЕсли;
//	
//КонецФункции

//// Возвращает менеджер объекта по ссылке на объект
////
//// Не обрабатываются точки маршрутов бизнес-процессов
////
//// Параметры:
////  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
////
//// Возвращаемое значение:
////  СправочникМенеджер, ДокументМенеджер, ...
//// 
//Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
//	
//	ИмяОбъекта = Ссылка.Метаданные().Имя;
//	ТипСсылки = ТипЗнч(Ссылка);
//	
//	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
//		Возврат Справочники[ИмяОбъекта];
//		
//	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
//		Возврат Документы[ИмяОбъекта];
//		
//	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
//		Возврат БизнесПроцессы[ИмяОбъекта];
//		
//	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
//		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
//		
//	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
//		Возврат ПланыСчетов[ИмяОбъекта];
//		
//	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
//		Возврат ПланыВидовРасчета[ИмяОбъекта];
//		
//	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
//		Возврат Задачи[ИмяОбъекта];
//		
//	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
//		Возврат ПланыОбмена[ИмяОбъекта];
//		
//	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
//		Возврат Перечисления[ИмяОбъекта];
//	Иначе
//		Возврат Неопределено;
//	КонецЕсли;
//	
//КонецФункции

//// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки
////
//// Параметры:
////  ЛюбаяСсылка - значение любой ссылки информационной базы данных
//// 
//// Возвращаемое значение:
////  Истина - ссылка физически существует;
////  Ложь   - ссылка физически не существует
////
//Функция СсылкаСуществует(ЛюбаяСсылка) Экспорт
//	
//	ТекстЗапроса = "
//		|ВЫБРАТЬ
//		|	Ссылка
//		|ИЗ
//		|	[ИмяТаблицы]
//		|ГДЕ
//		|	Ссылка = &Ссылка
//		|";
//	
//	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));
//	
//	Запрос = Новый Запрос;
//	Запрос.Текст = ТекстЗапроса;
//	Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
//	
//	УстановитьПривилегированныйРежим(Истина);
//	
//	Возврат НЕ Запрос.Выполнить().Пустой();
//	
//КонецФункции

//// Функция ВидОбъектаПоСсылке возвращает имя вида объектов метаданных
//// по ссылке на объект.
////
//// Не обрабатываются точки маршрутов бизнес-процессов.
////
//// Параметры:
////  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
////
//// Возвращаемое значение:
////  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
//// 
//Функция ВидОбъектаПоСсылке(Ссылка) Экспорт
//	
//	Возврат ВидОбъектаПоТипу(ТипЗнч(Ссылка));
//	
//КонецФункции 

//// Функция возвращает имя вида объектов метаданных по типу объекта.
////
//// Не обрабатываются точки маршрутов бизнес-процессов.
////
//// Параметры:
////  Тип       - Тип прикладного объекта, определенный в конфигурации
////
//// Возвращаемое значение:
////  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
//// 
//Функция ВидОбъектаПоТипу(Тип) Экспорт
//	
//	Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
//		Возврат "Справочник";
//	
//	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
//		Возврат "Документ";
//	
//	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
//		Возврат "БизнесПроцесс";
//	
//	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
//		Возврат "ПланВидовХарактеристик";
//	
//	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
//		Возврат "ПланСчетов";
//	
//	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
//		Возврат "ПланВидовРасчета";
//	
//	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
//		Возврат "Задача";
//	
//	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
//		Возврат "ПланОбмена";
//	
//	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
//		Возврат "Перечисление";
//	
//	Иначе
//		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
//			НСтр("ru='Неверный тип значения параметра (%1)'"), Строка(Тип));
//	
//	КонецЕсли;
//	
//КонецФункции 

//// Возвращает полное имя объекта метаданных по переданному значению ссылки
//// Например,
////  "Справочник.Номенклатура";
////  "Документ.ПриходнаяНакладная"
////
//// Параметры:
////  Ссылка - ЛюбаяСсылка - значение ссылки, для которого необходимо получить имя таблицы ИБ
//// 
//// Возвращаемое значение:
////  Строка - полное имя объекта метаданных для указанного значения ссылки
////
//Функция ИмяТаблицыПоСсылке(Ссылка) Экспорт
//	
//	Возврат Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).ПолноеИмя();
//	
//КонецФункции

//// Возвращает строковое представление типа. 
//// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта"
//// Для остальных типов приводит тип к строке, например "Число".
////
//Функция СтроковоеПредставлениеТипа(Тип) Экспорт
//	
//	Представление = "";
//	
//	Если ЭтоСсылка(Тип) Тогда
//	
//		ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
//		ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".")[1];
//		
//		Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
//			Представление = "СправочникСсылка";
//		
//		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
//			Представление = "ДокументСсылка";
//		
//		ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
//			Представление = "БизнесПроцессСсылка";
//		
//		ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
//			Представление = "ПланВидовХарактеристикСсылка";
//		
//		ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
//			Представление = "ПланСчетовСсылка";
//		
//		ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
//			Представление = "ПланВидовРасчетаСсылка";
//		
//		ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
//			Представление = "ЗадачаСсылка";
//		
//		ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
//			Представление = "ПланОбменаСсылка";
//		
//		ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
//			Представление = "ПеречислениеСсылка";
//		
//		КонецЕсли;
//		
//		Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
//		
//	Иначе
//		
//		Результат = Строка(Тип);
//		
//	КонецЕсли;
//	
//	Возврат Результат;
//	
//КонецФункции

//// Проверить, что значение имеет ссылочный тип данных.
////
//// Параметры:
////  Значение       - ссылка на объект, - элемент справочника, документ, ...
////
//// Возвращаемое значение:
////  Булево       - Истина, если тип значения ссылочный.
////
//Функция ЗначениеСсылочногоТипа(Значение) Экспорт
//	
//	Если Значение = Неопределено Тогда
//		Возврат Ложь;
//	КонецЕсли;
//	
//	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
//		Возврат Истина;
//	КонецЕсли;
//	
//	Если Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
//		Возврат Истина;
//	КонецЕсли;
//	
//	Если Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
//		Возврат Истина;
//	КонецЕсли;
//	
//	Если ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
//		Возврат Истина;
//	КонецЕсли;
//	
//	Если ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
//		Возврат Истина;
//	КонецЕсли;
//	
//	Если ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
//		Возврат Истина;
//	КонецЕсли;
//	
//	Если БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
//		Возврат Истина;
//	КонецЕсли;
//	
//	Если БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(ТипЗнч(Значение)) Тогда
//		Возврат Истина;
//	КонецЕсли;
//	
//	Если Задачи.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
//		Возврат Истина;
//	КонецЕсли;
//	
//	Если ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
//		Возврат Истина;
//	КонецЕсли;
//	
//	Возврат Ложь;
//	
//КонецФункции

//// Проверка того, что тип имеет ссылочный тип данных
////
//Функция ЭтоСсылка(Тип) Экспорт
//	
//	Возврат Справочники.ТипВсеСсылки().СодержитТип(Тип)
//		ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
//		ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
//		ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
//		ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
//		ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
//		ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
//		ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
//		ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
//		ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип);
//	
//КонецФункции

//// Является ли объект группой 
//// В качестве параметра может принимать только справочник или ПВХ
////
//Функция ОбъектЯвляетсяГруппой(Объект) Экспорт
//	
//	МетаданныеОбъекта = Объект.Метаданные();
//	
//	Если ЭтоСправочник(МетаданныеОбъекта)
//	И НЕ (МетаданныеОбъекта.Иерархический И МетаданныеОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов) Тогда
//		Возврат Ложь;
//	КонецЕсли;
//	
//	Если ЗначениеСсылочногоТипа(Объект) Тогда
//		Возврат Объект.ЭтоГруппа;
//	КонецЕсли;
//	
//	Ссылка = Объект.Ссылка;
//	
//	Если Не ЗначениеЗаполнено(Ссылка) Тогда
//		Возврат Ложь;
//	КонецЕсли;
//	
//	Возврат ПолучитьЗначениеРеквизита(Ссылка, "ЭтоГруппа");
//	
//КонецФункции

//// Проверяет наличие табличной части у справочника
////
////Параметры
////  ИмяСправочника    - Строка - имя справочника, для которого осуществляется проверка.
////  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
////
////Возвращаемое значение:
////  Булево   - Истина, если табличная часть есть, ложь в обратном случае
////
////Пример:
////  Если НЕ ОбщегоНазначения.НаличиеТабличнойЧастиУСправочника(ИмяСправочника,"КонтактнаяИнформация") Тогда
////  	Возврат;
////  КонецЕсли;
////
//Функция НаличиеТабличнойЧастиУСправочника(ИмяСправочника,ИмяТабличнойЧасти) Экспорт
//	
//	Возврат (Метаданные.Справочники[ИмяСправочника].ТабличныеЧасти.Найти(ИмяТабличнойЧасти) <> Неопределено);
//	
//КонецФункции 

//// Возвращает описание предмета в виде текстовой строки.
//// 
//// Параметры
////  СсылкаНаПредмет  – ЛюбаяСсылка – объект ссылочного типа.
////
//// Возвращаемое значение:
////   Строка 
//// 
//Функция ПредметСтрокой(СсылкаНаПредмет) Экспорт
//	
//	Результат = "";
//	СтандартныеПодсистемыПереопределяемый.УстановитьПредставлениеПредмета(СсылкаНаПредмет, Результат); 
//	ОбщегоНазначенияПереопределяемый.УстановитьПредставлениеПредмета(СсылкаНаПредмет, Результат); 
//	
//	Если ПустаяСтрока(Результат) Тогда
//		Если СсылкаНаПредмет = Неопределено или СсылкаНаПредмет.Пустая() Тогда
//			Результат = НСтр("ru = 'не задан'");
//		ИначеЕсли Метаданные.Документы.Содержит(СсылкаНаПредмет.Метаданные()) Тогда
//			Результат = Строка(СсылкаНаПредмет);
//		Иначе
//			ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().ПредставлениеОбъекта;
//			Если ПустаяСтрока(ПредставлениеОбъекта) Тогда
//				ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().Представление();
//			КонецЕсли;
//			Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
//				"%1 (%2)", Строка(СсылкаНаПредмет), ПредставлениеОбъекта);
//		КонецЕсли;
//	КонецЕсли;
//	
//	Возврат Результат;
//	
//КонецФункции

//// Формирует расширенное представление объекта.
//// Расширенное представление объекта складывается из представления объекта, кода и наименования.
//// Если для объекта не удалось получить расширенное представление,
//// то возвращается стандартное представление объекта, формируемое платформой.
////
//// Пример возвращаемого значения функции:
//// "Контрагент 0А-0001234, ООО Телекоммуникационные системы"
////
////  Параметры:
//// Объект. Тип: СправочникСсылка,
////				ПланСчетовСсылка,
////				ПланОбменаСсылка,
////				ПланВидовХарактеристикСсылка,
////				ПланВидовРасчетаСсылка.
//// Объект, для которого требуется получить расширенное представление.
////
////  Возвращаемое значение:
//// Тип. Строка.
//// Расширенное представление объекта.
////
//Функция РасширенноеПредставлениеОбъекта(Объект) Экспорт
//	
//	ОбъектМетаданных = Объект.Метаданные();
//	
//	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
//	
//	Если    ИмяБазовогоТипа = ИмяТипаСправочники()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета()
//		Тогда
//		
//		Если  ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Код")
//			И ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Наименование") Тогда
//			
//			ЗначенияРеквизитов = ПолучитьЗначенияРеквизитов(Объект, "Код, Наименование");
//			
//			ПредставлениеОбъекта = ?(ПустаяСтрока(ОбъектМетаданных.ПредставлениеОбъекта), 
//										?(ПустаяСтрока(ОбъектМетаданных.Синоним), ОбъектМетаданных.Имя, ОбъектМетаданных.Синоним
//										),
//									ОбъектМетаданных.ПредставлениеОбъекта
//			);
//			
//			Результат = "[ПредставлениеОбъекта] [Код], [Наименование]";
//			Результат = СтрЗаменить(Результат, "[ПредставлениеОбъекта]", ПредставлениеОбъекта);
//			Результат = СтрЗаменить(Результат, "[Код]",          ?(ПустаяСтрока(ЗначенияРеквизитов.Код), "<>", ЗначенияРеквизитов.Код));
//			Результат = СтрЗаменить(Результат, "[Наименование]", ?(ПустаяСтрока(ЗначенияРеквизитов.Наименование), "<>", ЗначенияРеквизитов.Наименование));
//			
//		Иначе
//			
//			Результат = Строка(Объект);
//			
//		КонецЕсли;
//		
//	Иначе
//		
//		Результат = Строка(Объект);
//		
//	КонецЕсли;
//	
//	Возврат Результат;
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// Функции определения типов объектов метаданных

//// Ссылочные типы данных

//// Определяет принадлежность объекта метаданных к общему типу "Документ"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоДокумент(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаДокументы();
//	
//КонецФункции

//// Определяет принадлежность объекта метаданных к общему типу "Справочник"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоСправочник(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаСправочники();
//	
//КонецФункции

//// Определяет принадлежность объекта метаданных к общему типу "Перечисление"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоПеречисление(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПеречисления();
//	
//КонецФункции

//// Определяет принадлежность объекта метаданных к общему типу "План обмена"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоПланОбмена(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыОбмена();
//	
//КонецФункции

//// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоПланВидовХарактеристик(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовХарактеристик();
//	
//КонецФункции

//// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоБизнесПроцесс(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаБизнесПроцессы();
//	
//КонецФункции

//// Определяет принадлежность объекта метаданных к общему типу "Задача"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоЗадача(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаЗадачи();
//	
//КонецФункции

//// Определяет принадлежность объекта метаданных к общему типу "План счетов"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоПланСчетов(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыСчетов();
//	
//КонецФункции

//// Определяет принадлежность объекта метаданных к общему типу "План видов расчета"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоПланВидовРасчета(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовРасчета();
//	
//КонецФункции

//// Регистры

//// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоРегистрСведений(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыСведений();
//	
//КонецФункции

//// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоРегистрНакопления(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыНакопления();
//	
//КонецФункции

//// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоРегистрБухгалтерии(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыБухгалтерии();
//	
//КонецФункции

//// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоРегистрРасчета(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыРасчета();
//	
//КонецФункции

//// Константы

//// Определяет принадлежность объекта метаданных к общему типу "Константа"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоКонстанта(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаКонстанты();
//	
//КонецФункции

//// Журналы документов

//// Определяет принадлежность объекта метаданных к общему типу "Журнал документов"
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоЖурналДокументов(ОбъектМетаданных) Экспорт
//	
//	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаЖурналыДокументов();
//	
//КонецФункции

//// Общие

//// Определяет принадлежность объекта метаданных к типу регистр
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоРегистр(ОбъектМетаданных) Экспорт
//	
//	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
//	
//	Возврат ИмяБазовогоТипа = ИмяТипаРегистрыСведений()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыНакопления()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыБухгалтерии()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыРасчета();
//	
//КонецФункции

//// Определяет принадлежность объекта метаданных к ссылочному типу
////
//// Параметры:
////  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
//// 
////  Возвращаемое значение:
////  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
////
//Функция ЭтоОбъектСсылочногоТипа(ОбъектМетаданных) Экспорт
//	
//	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
//	
//	Возврат ИмяБазовогоТипа = ИмяТипаСправочники()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаДокументы()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаБизнесПроцессы()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаЗадачи()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
//		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета();
//	
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
////  Сохранение и чтение настроек

//// Сохраняет массив пользовательских настроек МассивСтруктур. 
//// Может применяться для случаев вызова с клиента.
//// 
//// Параметры:
////    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
////    НужноОбновитьПовторноИспользуемыеЗначения - Булево - требуется обновить повторно используемые значения
////
//Процедура ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур, 
//	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
//	
//	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
//		Возврат;
//	КонецЕсли;
//	
//	Для Каждого Элемент Из МассивСтруктур Цикл
//		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, Элемент.Настройка, Элемент.Значение);
//	КонецЦикла;
//	
//	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
//		ОбновитьПовторноИспользуемыеЗначения();
//	КонецЕсли;
//	
//КонецПроцедуры

//// Сохраняет массив пользовательских настроек МассивСтруктур и 
//// обновляет повторно используемые значения.
//// Может применяться для случаев вызова с клиента.
//// 
//// Параметры:
////    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
////
//Процедура ХранилищеОбщихНастроекСохранитьМассивИОбновитьПовторноИспользуемыеЗначения(МассивСтруктур) Экспорт
//	
//	ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур, Истина);
//	
//КонецПроцедуры

//// Сохраняет пользовательскую настройку по имени.
//// 
//// Параметры:
////    соответствуют методу ХранилищеОбщихНастроек.Сохранить
////
//Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек = Неопределено, Значение,
//	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
//	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
//	
//	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
//		Возврат;
//	КонецЕсли;
//	
//	ХранилищеОбщихНастроек.Сохранить(КлючОбъекта, КлючНастроек, Значение, ОписаниеНастроек, ИмяПользователя);
//	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
//		ОбновитьПовторноИспользуемыеЗначения();
//	КонецЕсли;
//	
//КонецПроцедуры

//// Сохраняет пользовательскую настройку по имени и 
//// обновляет повторно используемые значения.
//// 
//// Параметры:
////    соответствуют методу ХранилищеОбщихНастроек.Сохранить
////
//Процедура ХранилищеОбщихНастроекСохранитьИОбновитьПовторноИспользуемыеЗначения(КлючОбъекта, КлючНастроек, Значение) Экспорт
//	
//	ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,,,Истина);
//	
//КонецПроцедуры

//// Возвращает значение пользовательской настройки по имени.
////
//// Параметры:
////    соответствуют методу ХранилищеОбщихНастроек.Загрузить
////
//Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек = Неопределено, ЗначениеПоУмолчанию = Неопределено, 
//		ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
//	
//	Результат = Неопределено;
//	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
//		Результат = ХранилищеОбщихНастроек.Загрузить(КлючОбъекта, КлючНастроек, ОписаниеНастроек, ИмяПользователя);
//	КонецЕсли;
//	
//	Если (Результат = Неопределено) И (ЗначениеПоУмолчанию <> Неопределено) Тогда
//		Результат = ЗначениеПоУмолчанию;
//	КонецЕсли;

//	Возврат Результат;
//	
//КонецФункции

//// Сохраняет пользовательскую настройку по имени.
//// 
//// Параметры:
////    соответствуют методу ХранилищеНастроекДанныхФорм.Сохранить
////
//Процедура ХранилищеНастроекДанныхФормСохранить(КлючОбъекта, КлючНастроек = Неопределено, Значение,
//	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
//	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
//	
//	ХранилищеСохранить(
//		ХранилищеНастроекДанныхФорм, 
//		КлючОбъекта, 
//		КлючНастроек, 
//		Значение,
//		ОписаниеНастроек, 
//		ИмяПользователя, 
//		НужноОбновитьПовторноИспользуемыеЗначения
//	);
//	
//КонецПроцедуры

//// Возвращает значение пользовательской настройки по имени.
////
//// Параметры:
////    соответствуют методу ХранилищеНастроекДанныхФорм.Загрузить
////
//Функция ХранилищеНастроекДанныхФормЗагрузить(КлючОбъекта, КлючНастроек = Неопределено, ЗначениеПоУмолчанию = Неопределено, 
//		ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
//	
//	Возврат ХранилищеЗагрузить(
//		ХранилищеНастроекДанныхФорм, 
//		КлючОбъекта, 
//		КлючНастроек = Неопределено, 
//		ЗначениеПоУмолчанию = Неопределено, 
//		ОписаниеНастроек = Неопределено, 
//		ИмяПользователя = Неопределено
//	);
//	
//КонецФункции

//// Сохраняет пользовательскую настройку по имени.
//// 
//Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Значение,
//	ОписаниеНастроек, ИмяПользователя, НужноОбновитьПовторноИспользуемыеЗначения)
//	
//	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
//		Возврат;
//	КонецЕсли;
//	
//	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек, Значение, ОписаниеНастроек, ИмяПользователя);
//	
//	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
//		ОбновитьПовторноИспользуемыеЗначения();
//	КонецЕсли;
//	
//КонецПроцедуры

//// Возвращает значение пользовательской настройки по имени.
////
//Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию, 
//	ОписаниеНастроек, ИмяПользователя)
//	
//	Результат = Неопределено;
//	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
//		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек, ОписаниеНастроек, ИмяПользователя);
//	КонецЕсли;
//	
//	Если (Результат = Неопределено) И (ЗначениеПоУмолчанию <> Неопределено) Тогда
//		Результат = ЗначениеПоУмолчанию;
//	КонецЕсли;

//	Возврат Результат;
//	
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// Общие процедуры и функции 

//// Функция возвращает ссылку на текущего пользователя базы данных,
//// установленного по учетной записи пользователя конфигурации.
////
//// Возвращаемое значение:
////  СправочникСсылка.Пользователи
////
//Функция ТекущийПользователь() Экспорт
//	
//	Возврат ПользователиСервер.ТекущийПользователь();
//	
//КонецФункции 

//// Выполнить экспортную процедуру без параметров по имени.
////
//// Параметры
////  ИмяЭкспортнойПроцедуры – Строка    – имя экспортной процедуры в формате 
////                                       <имя объекта>.<имя процедуры>, где <имя объекта> - это
////                                       общий модуль или модуль менеджера объекта.
////
//// Пример
////  ВыполнитьБезопасно("МойОбщийМодуль.МояПроцедура"); 
////
//Процедура ВыполнитьБезопасно(Знач ИмяЭкспортнойПроцедуры) Экспорт
//	
//	Перем ТекстСообщения;
//	
//	Если Не ПроверитьИмяЭкспортнойПроцедуры(ИмяЭкспортнойПроцедуры, ТекстСообщения) Тогда
//		ВызватьИсключение ТекстСообщения;
//	КонецЕсли;
//	
//	Выполнить ИмяЭкспортнойПроцедуры + "();";
//	
//КонецПроцедуры

//// Проверяет имя экспортной процедуры на валидность для использования
//// в инструкции Выполнить встроенного языка. При некорректном имени
//// вызывается исключение.
////
//Функция ПроверитьИмяЭкспортнойПроцедуры(Знач ИмяЭкспортнойПроцедуры, ТекстСообщения) Экспорт
//	
//	// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.
//	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");
//	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
//		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
//			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
//			ИмяЭкспортнойПроцедуры);
//		Возврат Ложь;
//	КонецЕсли;

//	ИмяОбъекта = ЧастиИмени[0];
//	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
//		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
//			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
//			ИмяЭкспортнойПроцедуры);
//		Возврат Ложь;
//	КонецЕсли;
//		
//	Если ЧастиИмени.Количество() = 3 Тогда
//		ДопустимыеИменаТипов = Новый Массив;
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаКонстанты()));
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыСведений()));
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыНакопления()));
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыБухгалтерии()));
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыРасчета()));
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаСправочники()));
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаДокументы()));
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаБизнесПроцессы()));
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЗадачи()));
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыСчетов()));
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыОбмена()));
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовХарактеристик()));
//		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовРасчета()));
//		ИмяТипа = ВРег(ЧастиИмени[0]);
//		Если ДопустимыеИменаТипов.Найти(ИмяТипа) = Неопределено Тогда
//			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
//				НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
//				ИмяЭкспортнойПроцедуры);
//			Возврат Ложь;
//		КонецЕсли;
//	КонецЕсли;
//	
//	Возврат Истина;
//	
//КонецФункции

//// Объединяет исключения поиска ссылок.
////
//Функция ПолучитьОбщийСписокИсключенийПоискаСсылок() Экспорт
//	
//	ОбщийМассивИсключенийСсылок = Новый Массив;
//	
//	ЗаполнитьМассивУникальнымиЗначениями(ОбщийМассивИсключенийСсылок, СтандартныеПодсистемыПереопределяемый.ИсключенияПоискаСсылок());
//	ЗаполнитьМассивУникальнымиЗначениями(ОбщийМассивИсключенийСсылок, ОбщегоНазначенияПереопределяемый.ПолучитьИсключенияПоискаСсылок());
//	
//	Возврат ОбщийМассивИсключенийСсылок;
//	
//КонецФункции	

//////////////////////////////////////////////////////////////////////////////////
//// Вспомогательные процедуры и функции

//// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
//// информационной базы файловый (Истина) или Серверный (Ложь).
////  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
//// можно указать явно.
////
//// Параметры:
////  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
////                 нужно проверить строку соединения не текущей информационной базы.
////
//// Возвращаемое значение:
////  Булево.
////
//Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
//			
//	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
//		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
//	КонецЕсли;
//	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
//	
//КонецФункции 

//// Получить представление информационной базы для отображения пользователю.
////
//// Возвращаемое значение:
////   Строка      - Представление информационной базы
////
//// Пример возвращаемого результата:
//// - для ИБ в файлом режиме: \\FileServer\1c_ib\
//// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
////
//Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
//	
//	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
//	
//	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
//		ПутьКБД = Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
//	Иначе
//		// надо к имени сервера прибавить имя пути информационной базы
//		ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "SRVR=");
//		
//		Если ПозицияПоиска <> 1 Тогда
//			Возврат Неопределено;
//		КонецЕсли;
//		
//		ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
//		НачальнаяПозицияКопирования = 6 + 1;
//		КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
//		
//		ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
//		
//		СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
//		
//		// позиция имени сервера
//		ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "REF=");
//		
//		Если ПозицияПоиска <> 1 Тогда
//			Возврат Неопределено;
//		КонецЕсли;
//		
//		НачальнаяПозицияКопирования = 6;
//		ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
//		КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
//		
//		ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
//		
//		ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;
//		
//	КонецЕсли;
//	
//	Возврат ПутьКБД;
//	
//КонецФункции

//// Проверить, что описание типа состоит из единственного типа значения и 
//// совпадает с нужным типом.
////
//// Возвращаемое значение:
////   Булево      - Совпадает или нет
////
//Функция ОписаниеТипаСостоитИзТипа(ОписаниеТипа, ТипЗначения) Экспорт
//	
//	Если ОписаниеТипа.Типы().Количество() = 1
//	   И ОписаниеТипа.Типы().Получить(0) = ТипЗначения Тогда
//		Возврат Истина;
//	КонецЕсли;
//	
//	Возврат Ложь;

//КонецФункции

//// Получает таблицу значений с описанием требуемых свойств всех реквизитов объекта метаданного
//// Получает значения свойств стандартных реквизитов и пользовательских реквизитов (созданных в режиме конфигуратора)
////
//// Параметры:
////  ОбъектМетаданных  - Объект метаданных конфигурации, для которого необходимо получить значение свойств реквизитов.
////                      Например: Метаданные.Документ.РеализацияТоваровИУслуг
////  Свойства - Строка - свойства реквизитов, перечисленных через запятую, значение которых необходимо получить.
////                      Например: "Имя, Тип, Синоним, Подсказка"
////
//// Возвращаемое значение:
////  ТаблицаЗначений - таблица значений с описанием требуемых свойств всех реквизитов объекта метаданного
////
//Функция ПолучитьТаблицуОписанияСвойствОбъекта(ОбъектМетаданных, Свойства) Экспорт
//	
//	МассивСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);
//	
//	// возвращаемое значение функции
//	ТаблицаОписанияСвойствОбъекта = Новый ТаблицаЗначений;
//	
//	// добавляем в таблицу поля согласно именам переданных свойств
//	Для Каждого ИмяСвойства ИЗ МассивСвойств Цикл
//		
//		ТаблицаОписанияСвойствОбъекта.Колонки.Добавить(СокрЛП(ИмяСвойства));
//		
//	КонецЦикла;
//	
//	// заполняем строку таблицы свойствами реквизитов объекта метаданных
//	Для Каждого Реквизит ИЗ ОбъектМетаданных.Реквизиты Цикл
//		
//		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
//		
//	КонецЦикла;
//	
//	// заполняем строку таблицы свойствами стандартных реквизитов объекта метаданных
//	Для Каждого Реквизит ИЗ ОбъектМетаданных.СтандартныеРеквизиты Цикл
//		
//		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
//		
//	КонецЦикла;
//	
//	Возврат ТаблицаОписанияСвойствОбъекта;
//	
//КонецФункции

//// Процедура предназначена для заполнения реквизита формы типа «ДеревоЗначений»
////
//// Параметры:
//// КоллекцияЭлементовДерева – реквизит формы, который имеет тип «ДеревоЗначений»;
//// 							  реквизит заполняется значениями из второго параметра процедуры.
//// ДеревоЗначений           – ДеревоЗначений – параметр содержит данные для заполнения.
//// 
//Процедура ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(КоллекцияЭлементовДерева, ДеревоЗначений) Экспорт
//	
//	Для Каждого Строка Из ДеревоЗначений.Строки Цикл
//		
//		ЭлементДерева = КоллекцияЭлементовДерева.Добавить();
//		
//		ЗаполнитьЗначенияСвойств(ЭлементДерева, Строка);
//		
//		Если Строка.Строки.Количество() > 0 Тогда
//			
//			ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(ЭлементДерева.ПолучитьЭлементы(), Строка);
//			
//		КонецЕсли;
//		
//	КонецЦикла;
//	
//КонецПроцедуры

//// Проверяет наличие табличной части у документа
////
////Параметры
////  ИмяДокумента      - Строка - имя документа, для которого осуществляется проверка.
////  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
////
////Возвращаемое значение:
////  Булево   - Истина, если табличная часть есть, ложь в обратном случае
////
//Функция НаличиеТабличнойЧастиУДокумента(ИмяДокумента, ИмяТабличнойЧасти) Экспорт
//	
//	Возврат (Метаданные.Документы[ИмяДокумента].ТабличныеЧасти.Найти(ИмяТабличнойЧасти) <> Неопределено);
//	
//КонецФункции 

//Функция СравнитьТипСсылкиДокумента(Ссылка, ИмяДокумента) Экспорт
//	
//	Если Метаданные.Документы.Найти(ИмяДокумента) = Неопределено Тогда
//		Возврат Ложь; 
//	КонецЕсли;
//	
//	Возврат ТипЗнч(Ссылка) = Тип("ДокументСсылка." + ИмяДокумента);
//	
//КонецФункции

//// Переадресация вызова функции ПолучитьЗначениеПеременной
////
//Функция ПолучитьЗначениеПеременной(ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь) Экспорт
//	
//	Возврат РаботаСОбщимиПеременными.ПолучитьЗначениеПеременной(ИмяПараметра)
//	
//КонецФункции
//// Получение представления для документа, удостоверяющего личность
////
//// Параметры
////  ДанныеФизЛица  – Коллекция данных физ. лица (структура, строка таблицы, ...), содержащая значения: 
////                   ДокументВид, ДокументСерия, ДокументНомер, ДокументДатаВыдачи, ДокументКемВыдан  
////
//// Возвращаемое значение:
////   Строка   – Представление документа, удостоверяющего личность
////
//Функция ПолучитьПредставлениеДокументаФизЛица(ДанныеФизЛица)

//	Возврат Строка(ДанныеФизЛица.ДокументВид) + " серия " +
//			ДанныеФизЛица.ДокументСерия       + ", номер " +
//			ДанныеФизЛица.ДокументНомер       + ", выданный " +
//			Формат(ДанныеФизЛица.ДокументДатаВыдачи, "ДФ=dd.MM.yyyy")  + " " +
//			ДанныеФизЛица.ДокументКемВыдан;

//КонецФункции // ПолучитьПредставлениеДокументаФизЛица()

//// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
////  либо по переданным строкам.
////  Если передан Объект, то извлеченная из него строка считается совокупностью 
////  Фамилия + Имя + Отчество, разделенными пробелами.
////
//// Параметры
////  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
////  Фамилия		- фамилия физ. лица.
////  Имя			- имя физ. лица.
////  Отчество	- отчество физ. лица.
////
//// Возвращаемое значение 
////  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
////  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
////  отдельным Фамилии,Имени и Отчеству
////
//Функция ФамилияИнициалыФизЛица(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт
//	
//	Если Не ЗначениеЗаполнено(Фамилия) И Не ЗначениеЗаполнено(Имя) Тогда 
//		
//		ФИО = ФамилияИмяОтчествоФизЛица(Объект);
//		
//		Фамилия = ФИО.Фамилия;
//		Имя		= ФИО.Имя;
//		Отчество= ФИО.Отчество;
//		
//	КонецЕсли;	
//	
//	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
//				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
//				"");

//КонецФункции

//// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
////  либо по переданным строкам.
////  Если передан Объект, то извлеченная из него строка считается совокупностью 
////  Фамилия + Имя + Отчество, разделенными пробелами.
////
//// Параметры
////  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
////  Фамилия		- фамилия физ. лица.
////  Имя			- имя физ. лица.
////  Отчество	- отчество физ. лица.
////
//// Возвращаемое значение 
////  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
////  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
////  отдельным Фамилии,Имени и Отчеству
////
//Функция ИнициалыФизЛицаФамилия(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт
//	
//	Если НЕ ЗначениеЗаполнено("" + Фамилия + Имя + Отчество) Тогда
//		
//		ФИО = ФамилияИмяОтчествоФизЛица(Объект);
//		
//		Фамилия = ФИО.Фамилия;
//		Имя		= ФИО.Имя;
//		Отчество= ФИО.Отчество;

//	КонецЕсли;

//	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
//				"" + ?(НЕ ПустаяСтрока(Имя),Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), "") + " " + Фамилия,
//				"");

//КонецФункции

//Функция ФамилияИмяОтчествоФизЛица(Объект)
//	
//	ТипОбъекта = ТипЗнч(Объект);
//	
//	ФИО = Новый Массив;
//	
//	Если ТипОбъекта <> Тип("Неопределено") Тогда
//	
//		СписокТиповСсылок	= ОбщегоНазначенияПереопределяемый.ВернутьСписокТиповСсылокДляФормированияФИО();
//		СписокТиповОбъектов	= ОбщегоНазначенияПереопределяемый.ВернутьСписокТиповОбъектовДляФормированияФИО();

//		Если ТипОбъекта = Тип("Строка") Тогда
//		
//			ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
//			
//		ИначеЕсли СписокТиповСсылок.СодержитТип(ТипОбъекта) Или СписокТиповОбъектов.СодержитТип(ТипОбъекта) Тогда
//		
//			Если ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или 
//				ТипОбъекта = Тип("СправочникСсылка.СотрудникиОрганизаций") Тогда
//				Наименование = ПолучитьЗначениеРеквизита(Объект, "Наименование");
//			Иначе
//				Наименование = Объект.Наименование;
//			КонецЕсли;
//		
//			// Избавление от возможных выражений в скобках, например (осн.), (вн. совм.).
//			НачальнаяПозиция	= Найти(Наименование,"(");
//			КонечнаяПозиция		= Найти(Наименование,")");
//			ДлинаСтроки			= СтрДлина(Наименование);
//			Если НачальнаяПозиция > 0 Тогда
//				СтрокаДляОбработки = Лев(Наименование, НачальнаяПозиция - 1) + ?(КонечнаяПозиция > 0,Прав(Наименование, ДлинаСтроки - КонечнаяПозиция),"")
//			Иначе
//				СтрокаДляОбработки = Наименование;
//			КонецЕсли; 
//			
//			ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(СтрокаДляОбработки)," ");
//			
//		КонецЕсли;
//		
//	КонецЕсли;
//	
//	КоличествоПодстрок = ФИО.Количество();
//	
//	Результат = Новый Структура;
//	
//	Результат.Вставить("Фамилия",	?(КоличествоПодстрок > 0,ФИО[0],""));
//	Результат.Вставить("Имя",		?(КоличествоПодстрок > 1,ФИО[1],""));
//	Результат.Вставить("Отчество",	?(КоличествоПодстрок > 2,ФИО[2],""));
//	
//	Возврат Результат
//	
//КонецФункции

//// Функция формирует фамилию и инициалы работника в заданном падеже 
//// по переданным данным о работнике.
////  либо по переданным строкам.
////
//// Параметры
////  Работник	- строка (Фамилия + Имя + Отчество, разделенными пробелами) 
////                или ссылка на элемент справочника ФизическиеЛица или Сотрудники.
////  Падеж (необязательный), тип число
////   Падеж, в который необходимо поставить ФИО.
////   1 - Именительный
////   2 - Родительный
////   3 - Дательный
////   4 - Винительный
////   5 - Творительный
////   6 - Предложный
////
////  Пол (необязательный), тип ПеречислениеСсылка.ПолФизическихЛиц
////   Данный параметр предназначен для разрешения возможных неоднозначностей
////   В остальных случаях рекомендуется опускать этот параметр.
//// Возвращаемое значение 
////  Фамилия и Инициалы одной строкой.
////
//Функция ПредставлениеРаботника(Работник, Знач Падеж = 1, Знач Пол = Неопределено) Экспорт

//	ТипДанных = ТипЗнч(Работник);
//	Если ТипДанных = Тип("Строка") Тогда
//		РаботникФИО = Работник;
//		РаботникПол = Пол;
//	Иначе
//		Запрос = Новый Запрос;
//		Запрос.УстановитьПараметр("Работник", Работник);
//		Если ТипДанных = Тип("СправочникСсылка.СотрудникиОрганизаций") Тогда
//			Запрос.Текст = 
//			"ВЫБРАТЬ
//			|	СотрудникиОрганизаций.Наименование,
//			|	СотрудникиОрганизаций.Физлицо.Пол КАК Пол
//			|ИЗ
//			|	Справочник.СотрудникиОрганизаций КАК СотрудникиОрганизаций
//			|ГДЕ
//			|	СотрудникиОрганизаций.Ссылка = &Работник";
//		Иначе
//			Запрос.Текст = 
//			"ВЫБРАТЬ
//			|	ФизическиеЛица.Наименование,
//			|	ФизическиеЛица.Пол
//			|ИЗ
//			|	Справочник.ФизическиеЛица КАК ФизическиеЛица
//			|ГДЕ
//			|	ФизическиеЛица.Ссылка = &Работник";
//		КонецЕсли;
//		
//		Выборка = Запрос.Выполнить().Выбрать();
//		Если Выборка.Следующий() Тогда
//			РаботникФИО = Выборка.Наименование;
//			РаботникПол = Выборка.Пол;
//		Иначе
//			Возврат ""
//		КонецЕсли;
//	КонецЕсли;
//	
//	ФИО = ОбщегоНазначения.ФамилияИнициалыФизЛица(РаботникФИО);
//	
//	ПозицияПервогоПробела = Найти(ФИО + " "," ");
//	Фамилия  = Лев(ФИО,ПозицияПервогоПробела-1);
//	Инициалы = Сред(ФИО,ПозицияПервогоПробела+1);
//	
//	РезультатСклонения = "";
//	Если УниверсальныеМеханизмы.Просклонять(глЗначениеПеременной("глКомпонентаСклоненияФИО"), Фамилия, Падеж, РаботникПол, РезультатСклонения) Тогда
//		ФИО = РезультатСклонения + " " + Инициалы;	
//	КонецЕсли;
//	
//	Возврат ФИО
//	
//КонецФункции

//// Функция возвращает совокупность данных о физическом лице в виде структуры, 
//// В совокупность данных входит ФИО, должность в заданной организации, 
//// паспортные данные и др.
////
//// Параметры:
////  Организация  - СправочникСсылка.Организации - организация, по которой
////                 определяется должность и подразделение работника
////  ФизЛицо      - СправочникСсылка.ФизическиеЛица - физическое лицо,
////                 по которому возвращается совокупность данных
////  ДатаСреза    - Дата - дата, на которую считываются данные
////  ФИОКратко    - Булево - если Истина (по умолчанию), Представление физ.лица включает фамилию и инициалы, если Ложь - фамилию и полностью имя и отчество
////
//// Возвращаемое значение:
////  Структура    - Структура с совокупностью данных о физическом лице:
////                 - Фамилия
////                 - Имя
////                 - Отчетсво
////                 - Представление (Фамилия И.О.)
////                 - Подразделение
////                 - ДокументВид
////                 - ДокументСерия
////                 - ДокументНомер
////                 - ДокументДатаВыдачи
////                 - ДокументКемВыдан
////                 - ДокументКодПодразделения
////
//Функция ДанныеФизЛица(Организация, ФизЛицо, ДатаСреза, ФИОКратко = Истина) Экспорт
//	
//	ЗапросПоЛицам = Новый Запрос();
//	ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
//	ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
//	ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
//	ЗапросПоЛицам.Текст =
//	"ВЫБРАТЬ
//	|	ФизическиеЛица.Ссылка КАК ФизЛицо
//	|ПОМЕСТИТЬ ФизЛица
//	|ИЗ
//	|	Справочник.ФизическиеЛица КАК ФизическиеЛица
//	|ГДЕ
//	|	ФизическиеЛица.Ссылка = &ФизЛицо
//	|;
//	|
//	|////////////////////////////////////////////////////////////////////////////////
//	|ВЫБРАТЬ
//	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
//	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Физлицо КАК ФизЛицо,
//	|	ВЫБОР
//	|		КОГДА РаботникиОрганизацийСрезПоследних.ПериодЗавершения <= &ДатаСреза
//	|				И РаботникиОрганизацийСрезПоследних.ПериодЗавершения <> ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
//	|			ТОГДА РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизацииЗавершения
//	|		ИНАЧЕ РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации
//	|	КОНЕЦ КАК ПодразделениеОрганизации,
//	|	ВЫБОР
//	|		КОГДА РаботникиОрганизацийСрезПоследних.ПериодЗавершения <= &ДатаСреза
//	|				И РаботникиОрганизацийСрезПоследних.ПериодЗавершения <> ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
//	|			ТОГДА РаботникиОрганизацийСрезПоследних.ДолжностьЗавершения
//	|		ИНАЧЕ РаботникиОрганизацийСрезПоследних.Должность
//	|	КОНЕЦ КАК Должность
//	|ПОМЕСТИТЬ СведенияПоРаботникамОрганизации
//	|ИЗ
//	|	РегистрСведений.РаботникиОрганизаций.СрезПоследних(
//	|			&ДатаСреза,
//	|			Сотрудник.ФизЛицо = &ФизЛицо
//	|				И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
//	|ГДЕ
//	|	РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
//	|;
//	|
//	|////////////////////////////////////////////////////////////////////////////////
//	|ВЫБРАТЬ
//	|	ФИОФизЛицСрезПоследних.Фамилия,
//	|	ФИОФизЛицСрезПоследних.Имя,
//	|	ФИОФизЛицСрезПоследних.Отчество,
//	|	СведенияПоРаботникамОрганизации.ТабельныйНомер,
//	|	СведенияПоРаботникамОрганизации.Должность,
//	|	СведенияПоРаботникамОрганизации.ПодразделениеОрганизации,
//	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
//	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
//	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
//	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
//	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
//	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКодПодразделения
//	|ИЗ
//	|	ФизЛица КАК ФизЛица
//	|		
//	|		ЛЕВОЕ СОЕДИНЕНИЕ 
//	|			РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ФИОФизЛицСрезПоследних
//	|		ПО 
//	|			ФизЛица.ФизЛицо = ФИОФизЛицСрезПоследних.ФизЛицо
//	|		
//	|		ЛЕВОЕ СОЕДИНЕНИЕ 
//	|			РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ПаспортныеДанныеФизЛицСрезПоследних
//	|		ПО 
//	|			ФизЛица.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо
//	|		
//	|		ЛЕВОЕ СОЕДИНЕНИЕ 
//	|			СведенияПоРаботникамОрганизации КАК СведенияПоРаботникамОрганизации
//	|		ПО 
//	|			ФизЛица.ФизЛицо = СведенияПоРаботникамОрганизации.ФизЛицо";
//	
//	Данные = ЗапросПоЛицам.Выполнить().Выбрать();
//	Данные.Следующий();
//	
//	Результат = Новый Структура("Фамилия, Имя, Отчество, Представление, 
//								|ТабельныйНомер, Должность, ПодразделениеОрганизации, 
//								|ДокументВид, ДокументСерия, ДокументНомер,  
//								|ДокументДатаВыдачи, ДокументКемВыдан, ДокументКодПодразделения, 
//								|ПредставлениеДокумента");

//	ЗаполнитьЗначенияСвойств(Результат, Данные);

//	Результат.Представление          = ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество, ФИОКратко);
//	Результат.ПредставлениеДокумента = ПолучитьПредставлениеДокументаФизЛица(Данные);
//	
//	Возврат Результат;
//	
//КонецФункции // ДанныеФизЛица

//// Функция возвращает совокупность данных о физических лицах в виде таблицы
//// значений. В совокупность данных входит ФИО, должность в заданной 
//// организации, паспортные данные и др.
////
//// Параметры:
////  Организация  - СправочникСсылка.Организации - организация, по которой
////                 определяется должность и подразделение работника(ов)
////  ФизЛицо      - СправочникСсылка.ФизическиеЛица или Массив - физическое лицо
////                 или список физ. лиц, по которым возвращается совокупность 
////                 данных
////  ДатаСреза    - Дата - дата, на которую считываются данные
////
//// Возвращаемое значение:
////  ТаблицаЗначений - Таблица с совокупностью данных о физическом лице. 
////                  Колонки: возвращаемой таблицы:
////                  - Фамилия
////                  - Имя
////                  - Отчетсво
////                  - Представление (Фамилия И.О.)
////                  - Подразделение
////                  - ДокументВид
////                  - ДокументСерия
////                  - ДокументНомер
////                  - ДокументДатаВыдачи
////                  - ДокументКемВыдан
////                  - ДокументКодПодразделения
////
//Функция ДанныеФизЛиц(Организация, ФизЛицо, ДатаСреза) Экспорт

//	ЗапросПоЛицам = Новый Запрос();
//	ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
//	ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
//	ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
//	ЗапросПоЛицам.Текст =
//	"ВЫБРАТЬ
//	|	ФизическиеЛица.Ссылка КАК ФизЛицо
//	|ПОМЕСТИТЬ ФизЛица
//	|ИЗ
//	|	Справочник.ФизическиеЛица КАК ФизическиеЛица
//	|ГДЕ
//	|	ФизическиеЛица.Ссылка В(&ФизЛицо)
//	|;
//	|
//	|////////////////////////////////////////////////////////////////////////////////
//	|ВЫБРАТЬ
//	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
//	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Физлицо КАК ФизЛицо,
//	|	ВЫБОР
//	|		КОГДА РаботникиОрганизацийСрезПоследних.ПериодЗавершения <= &ДатаСреза
//	|				И РаботникиОрганизацийСрезПоследних.ПериодЗавершения <> ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
//	|			ТОГДА РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизацииЗавершения
//	|		ИНАЧЕ РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации
//	|	КОНЕЦ КАК ПодразделениеОрганизации,
//	|	ВЫБОР
//	|		КОГДА РаботникиОрганизацийСрезПоследних.ПериодЗавершения <= &ДатаСреза
//	|				И РаботникиОрганизацийСрезПоследних.ПериодЗавершения <> ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
//	|			ТОГДА РаботникиОрганизацийСрезПоследних.ДолжностьЗавершения
//	|		ИНАЧЕ РаботникиОрганизацийСрезПоследних.Должность
//	|	КОНЕЦ КАК Должность
//	|ПОМЕСТИТЬ СведенияПоРаботникамОрганизации
//	|ИЗ
//	|	РегистрСведений.РаботникиОрганизаций.СрезПоследних(
//	|			&ДатаСреза,
//	|			Сотрудник.ФизЛицо В (&ФизЛицо)
//	|				И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
//	|ГДЕ
//	|	РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
//	|;
//	|
//	|////////////////////////////////////////////////////////////////////////////////
//	|ВЫБРАТЬ
//	|	ФИОФизЛицСрезПоследних.Фамилия,
//	|	ФИОФизЛицСрезПоследних.Имя,
//	|	ФИОФизЛицСрезПоследних.Отчество,
//	|	СведенияПоРаботникамОрганизации.ТабельныйНомер,
//	|	СведенияПоРаботникамОрганизации.Должность,
//	|	СведенияПоРаботникамОрганизации.ПодразделениеОрганизации,
//	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
//	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
//	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
//	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
//	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
//	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКодПодразделения
//	|ИЗ
//	|	ФизЛица КАК ФизЛица
//	|		
//	|		ЛЕВОЕ СОЕДИНЕНИЕ 
//	|			РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В (&ФизЛицо)) КАК ФИОФизЛицСрезПоследних
//	|		ПО 
//	|			ФизЛица.ФизЛицо = ФИОФизЛицСрезПоследних.ФизЛицо
//	|		
//	|		ЛЕВОЕ СОЕДИНЕНИЕ 
//	|			РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В (&ФизЛицо)) КАК ПаспортныеДанныеФизЛицСрезПоследних
//	|		ПО 
//	|			ФизЛица.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо
//	|		
//	|		ЛЕВОЕ СОЕДИНЕНИЕ 
//	|			СведенияПоРаботникамОрганизации КАК СведенияПоРаботникамОрганизации
//	|		ПО 
//	|			ФизЛица.ФизЛицо = СведенияПоРаботникамОрганизации.ФизЛицо";
//	
//	Данные = ЗапросПоЛицам.Выполнить().Выбрать();
//	
//	ТабРезультат = Новый ТаблицаЗначений();
//	ТабРезультат.Колонки.Добавить("Фамилия");
//	ТабРезультат.Колонки.Добавить("Имя");
//	ТабРезультат.Колонки.Добавить("Отчество");
//	ТабРезультат.Колонки.Добавить("Представление");
//	ТабРезультат.Колонки.Добавить("ТабельныйНомер");
//	ТабРезультат.Колонки.Добавить("Должность");
//	ТабРезультат.Колонки.Добавить("ПодразделениеОрганизации");
//	ТабРезультат.Колонки.Добавить("ДокументВид");
//	ТабРезультат.Колонки.Добавить("ДокументСерия");
//	ТабРезультат.Колонки.Добавить("ДокументНомер");
//	ТабРезультат.Колонки.Добавить("ДокументДатаВыдачи");
//	ТабРезультат.Колонки.Добавить("ДокументКемВыдан");
//	ТабРезультат.Колонки.Добавить("ДокументКодПодразделения");
//	ТабРезультат.Колонки.Добавить("ПредставлениеДокумента");
//								
//	Пока Данные.Следующий() Цикл
//		
//		Результат = ТабРезультат.Добавить();
//		
//		ЗаполнитьЗначенияСвойств(Результат, Данные);

//		Результат.Представление          = ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество);
//		Результат.ПредставлениеДокумента = ПолучитьПредставлениеДокументаФизЛица(Данные);
//		
//	КонецЦикла;

//	Возврат ТабРезультат;
//	
//КонецФункции // ДанныеФизЛиц

//// Функция формирует фамилию и инициалы
////
//// Параметры
////  Фамилия  - фамилия физ. лица.
////  Имя      - имя физ. лица.
////  Отчество - отчество физ. лица.
////
//// Возвращаемое значение 
////  Фамилия, имя, отчество одной строкой.
////
//Функция ПолучитьФамилиюИмяОтчество(Фамилия = " ", Имя = " ", Отчество = " ", ФИОКратко = Истина) Экспорт

//	Если ФИОКратко Тогда
//		Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + 
//				?(НЕ ПустаяСтрока(Отчество) , 
//				Лев(Отчество,1)+".", ""), ""), "");
//	Иначе
//		Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Имя + 
//				?(НЕ ПустаяСтрока(Отчество) , " " + Отчество, ""), ""), "");
//	КонецЕсли;

//КонецФункции // ПолучитьФамилиюИмяОтчество()

//Функция ПолучитьМассивПрефиксовРИБ()
//	
//	МассивПрефиксов = Новый Массив();
//	
//	Запрос = Новый Запрос();
//	Запрос.Текст = "ВЫБРАТЬ Различные
//	               |	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
//	               |ИЗ
//	               |	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз";
//	
//	ВыборкаУзлов = Запрос.Выполнить().Выбрать();
//	Пока ВыборкаУзлов.Следующий() Цикл
//		
//		Если Не ПустаяСтрока(ВыборкаУзлов.Префикс) Тогда
//			
//			МассивПрефиксов.Добавить(ВыборкаУзлов.Префикс);
//			
//		КонецЕсли;
//		
//	КонецЦикла;	
//	
//	Возврат МассивПрефиксов;
//	
//КонецФункции

//Функция СформироватьМассивПрефиксовДляРИБИОрганизации(Организация) Экспорт
//	
//	МассивПрефиксов = ПолучитьМассивПрефиксовРИБ();	
//	
//	Если ЗначениеЗаполнено(Организация) Тогда
//		
//		Префикс = СокрЛП(Организация.Префикс);
//		
//		Если Префикс <> "" Тогда
//			МассивПрефиксов.Добавить(Префикс);
//		КонецЕсли;
//		
//	КонецЕсли;
//	
//	Если МассивПрефиксов.Количество() = 0 Тогда
//		МассивПрефиксов.Добавить("");
//	КонецЕсли;
//	
//	Возврат МассивПрефиксов;
//	
//КонецФункции

//// Заполнение отбора значениями из таблицы значений.
//// Соответствие полей устанавливается по представлению и типам значений
////
//// Параметры
////  Отбор  – Отбор           – Отбор, который требуется заполнить значениями
////  ТЗ     – ТаблицаЗначений – Таблица содержит значения для отбора.
////                             Структура колонок повторяет структуру отбора
////
//Процедура ЗаполнитьОтборПоТаблицеЗначений(Отбор, ТЗ) Экспорт

//	Для каждого ЭлементОтбора Из ТЗ Цикл
//	
//		СтрокаТаблицы = Неопределено;
//		
//		Для каждого стр Из Отбор Цикл
//			
//			Если стр.Представление = ЭлементОтбора.Представление
//				И стр.ТипЗначения = ЭлементОтбора.ТипЗначения Тогда
//				Если ПустаяСтрока(стр.Представление)
//					И ПустаяСтрока(стр.ПутьКданным) Тогда
//					
//					Продолжить;
//					
//				КонецЕсли;
//				СтрокаТаблицы = стр;
//				
//				Прервать;
//				
//			КонецЕсли;
//			
//		КонецЦикла;
//		
//		Если ПустаяСтрока(ЭлементОтбора.ПутьКданным) Тогда
//			Продолжить;
//		КонецЕсли;
//		
//		Если СтрокаТаблицы = Неопределено Тогда
//			
//			СтрокаТаблицы = Отбор.Добавить(ЭлементОтбора.ПутьКданным, ЭлементОтбора.Имя, ЭлементОтбора.Представление);		
//					
//		КонецЕсли;
//		
//		СтрокаТаблицы.ВидСравнения = ЭлементОтбора.ВидСравнения;
//		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, ЭлементОтбора, "Значение, ЗначениеПо, ЗначениеС, Использование");
//			
//	КонецЦикла;

//КонецПроцедуры // УстановитьОтборИзТаблицы(Отбор, ТЗ)

//// Функция выделяет первое слово в предложении
//Функция ВыделитьСлово(ИсходнаяСтрока) Экспорт
//	
//	Буфер = СокрЛ(ИсходнаяСтрока);
//	ПозицияПослПробела = Найти(Буфер, " ");

//	Если ПозицияПослПробела = 0 Тогда
//		ИсходнаяСтрока = "";
//		Возврат Буфер;
//	КонецЕсли;
//	
//	ВыделенноеСлово = СокрЛП(Лев(Буфер, ПозицияПослПробела));
//	ИсходнаяСтрока = Сред(ИсходнаяСтрока, ПозицияПослПробела + 1);
//	
//	Возврат ВыделенноеСлово;
//	
//КонецФункции

//// Функция преобразует строку к множественному числу
////
//// Параметры: 
////  Слово1 - форма слова в ед числе      ("шкаф")
////  Слово2 - форма слова для числит 2-4  ("шкафа")
////  Слово3 - форма слова для числит 5-10 ("шкафов")
////  ЦелоеЧисло - целое число
////
//// Возвращаемое значение:
////  строку - одну из строк в зависимости от параметра ЦелоеЧисло
////
//// Описание:
////  Предназначена для формирования "правильной" подписи к числительным
////
//Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, Знач ЦелоеЧисло) Экспорт
//	
//	// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться
//	Если ЦелоеЧисло < 0 Тогда
//		ЦелоеЧисло = -1 * ЦелоеЧисло;
//	КонецЕсли;
//	
//	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
//		// для нецелых чисел - всегда вторая форма
//		Возврат Слово2;
//	КонецЕсли;
//	
//	// остаток
//	Остаток = ЦелоеЧисло%10;
//	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
//		// для второго десятка - всегда третья форма
//		Возврат Слово3;
//	ИначеЕсли Остаток=1 Тогда
//		Возврат Слово1;
//	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
//		Возврат Слово2;
//	Иначе
//		Возврат Слово3;
//	КонецЕсли;

//КонецФункции

//// Процедура вычисляет количество лет, месяцев и дней между двумя датами
////
//// Параметры
////  Дата1	– дата, первая дата (более поздняя, часто текущая, стаж определяется по состоянию на эту дату)
////  Дата2	– дата, вторая дата (ранняя дата, с нее начинается "течение" стажа)
////  Лет		– Число, в этот параметр будет записано кол-во лет между двумя датами (Дата1-Дата2)
////  Месяцев	– Число, в этот параметр будет записано кол-во месяцев между двумя датами (Дата1-Дата2)
////  Дней	– Число, в этот параметр будет записано кол-во дней между двумя датами (Дата1-Дата2)
////
//Процедура РазобратьРазностьДат(Дата1, Дата2, Лет = 0, Месяцев = 0, Дней = 0) Экспорт
//	
//	Лет		= 0;
//	Месяцев	= 0;
//	Дней	= 0;
//	Если Дата1 > Дата2 Тогда
//		
//		ВременнаяДата = Дата1;
//		Если День(ВременнаяДата) < День(Дата2) Тогда
//			Дней = (ВременнаяДата - ДобавитьМесяц(ВременнаяДата,-1))/86400;
//			ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-1);
//		КонецЕсли;
//		Если Месяц(ВременнаяДата) < Месяц(Дата2) Тогда
//			ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-12);
//			Месяцев = 12;
//		КонецЕсли;
//		Лет		= Макс(			 Год(ВременнаяДата)		- Год(Дата2),	0);
//		Месяцев	= Макс(Месяцев	+ Месяц(ВременнаяДата)	- Месяц(Дата2),	0);
//		Дней	= Макс(Дней		+ День(ВременнаяДата)	- День(Дата2),	0);
//		
//		// скорректируем отображаемое значение, если "вмешалось" разное количество дней в месяцах
//		Если Дата2 <> (ДобавитьМесяц(Дата1,-Лет*12-Месяцев)-Дней*86400) Тогда
//			Дней = Дней + ((ДобавитьМесяц(Дата1,-Лет*12-Месяцев)-Дней*86400) - Дата2)/86400;
//			//(День(КонецМесяца(Дата2)) - День(НачалоМесяца(Дата2))) - (День(КонецМесяца(ДобавитьМесяц(Дата1,-1))) - День(НачалоМесяца(ДобавитьМесяц(Дата1,-1))));
//		КонецЕсли;
//		
//	КонецЕсли;

//КонецПроцедуры	// РазобратьРазностьДат

//// Функция определяет дату и время начала календарной декады для указанной даты.
////
//// Параметры:
////  ТекущаяДата - Исходная дата.
////
//// Возвращаемое значение:
////  Дата.
////
//Функция ПолучитьНачалоДекады(ИсходнаяДата) Экспорт

//	ДеньМесяца = День(ИсходнаяДата);

//	Если ДеньМесяца <= 10 Тогда
//		Результат = НачалоМесяца(ИсходнаяДата);
//	ИначеЕсли ДеньМесяца <= 20 Тогда
//		Результат = НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 10;
//	Иначе
//		Результат = НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 20;
//	КонецЕсли;

//	Возврат Результат;

//КонецФункции // ПолучитьНачалоДекады()

//// Функция определяет дату и время конца календарной декады для указанной даты.
////
//// Параметры:
////  ТекущаяДата - Исходная дата.
////
//// Возвращаемое значение:
////  Дата.
////
//Функция ПолучитьКонецДекады(ИсходнаяДата) Экспорт

//	ДеньМесяца = День(ИсходнаяДата);

//	Если ДеньМесяца <= 10 Тогда
//		Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 9);
//	ИначеЕсли ДеньМесяца <= 20 Тогда
//		Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 19);
//	Иначе
//		Результат = КонецМесяца(ИсходнаяДата);
//	КонецЕсли;

//	Возврат Результат;

//КонецФункции // ПолучитьКонецДекады()

//// Функция определяет дату и время начала полугодия для указанной даты.
////
//// Параметры:
////  ТекущаяДата - Исходная дата.
////
//// Возвращаемое значение:
////  Дата.
////
//Функция ПолучитьНачалоПолугодия(ИсходнаяДата) Экспорт

//	Если Месяц(ИсходнаяДата) < 7 Тогда
//		Результат = НачалоГода(ИсходнаяДата);
//	Иначе
//		Результат = ДобавитьМесяц(НачалоГода(ИсходнаяДата), 6);
//	КонецЕсли;

//	Возврат Результат;

//КонецФункции // ПолучитьНачалоПолугодия()

//// Функция определяет дату и время конца полугодия для указанной даты.
////
//// Параметры:
////  ТекущаяДата - Исходная дата.
////
//// Возвращаемое значение:
////  Дата.
////
//Функция ПолучитьКонецПолугодия(ИсходнаяДата) Экспорт

//	Если Месяц(ИсходнаяДата) < 7 Тогда
//		Результат = ДобавитьМесяц(КонецГода(ИсходнаяДата), -6);
//	Иначе
//		Результат = КонецГода(ИсходнаяДата);
//	КонецЕсли;

//	Возврат Результат;

//КонецФункции // ПолучитьКонецПолугодия()

//// функция из исходной строки формирует строку для поиска данных в запросе
//Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
//	
//	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
//	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
//	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
//	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
//	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
//	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");

//	Возврат ИтоговаяСтрокаДляПоиска;
//	
//КонецФункции

//// Функция формирует представление заголовка документа
////
//// Возвращаемое значение:
////  Строка - представление номера документа
////
//Функция СформироватьЗаголовокДокумента(ДокументОбъект, НазваниеДокумента = "") Экспорт

//	Если ДокументОбъект = Неопределено Тогда
//		Возврат "";
//	Иначе
//			Возврат ?(НЕ ЗначениеЗаполнено(НазваниеДокумента), ДокументОбъект.Метаданные().Синоним, НазваниеДокумента ) + " № " + ПолучитьНомерНаПечать(ДокументОбъект)
//	                          + " от " + Формат(ДокументОбъект.Дата, "ДФ='дд ММММ гггг'");
//	КонецЕсли;

//КонецФункции // СформироватьЗаголовокДокумента()

//// Функция формирует представление суммы прописью в указанной валюте
////
//// Возвращаемое значение:
////  Строка - сумма прописью
////
//Функция СформироватьСуммуПрописью(Сумма, Валюта) Экспорт

//	Если Валюта.ПараметрыПрописиНаРусском = "" Тогда
//		Возврат ФорматСумм(Сумма);
//	Иначе
//		Возврат ЧислоПрописью(Сумма, "L=ru_RU", Валюта.ПараметрыПрописиНаРусском);
//	КонецЕсли;

//КонецФункции // СформироватьСуммуПрописью()

//Процедура ДобавитьПрефиксОрганизации(ДокументОбъект, Префикс) Экспорт
// 	
//	// Если в документе нет реквизита "Организация" или для организации не задан префикс,
//	// то используем пустой префикс, иначе используем префикс организации.
//	Префикс = "0";
//	
//	Если ДокументОбъект.Метаданные().Реквизиты.Найти("Организация") <> Неопределено Тогда
//		ПрефиксОрганизации = ПолучитьЗначениеРеквизита(ДокументОбъект.Организация, "Префикс");
//		Если ЗначениеЗаполнено(ПрефиксОрганизации) Тогда
//			Префикс = ПрефиксОрганизации;
//		КонецЕсли;
//	КонецЕсли;
//	
//КонецПроцедуры

//// процедура формирования номера документа
//Процедура ПриУстановкеНовогоНомераДляДокументов(Источник, СтандартнаяОбработка, Префикс) Экспорт
//	ДобавитьПрефиксОрганизации(Источник, Префикс);
//	ДобавитьПрефиксУзла(Префикс);
//КонецПроцедуры

////Процедура выполняет удаление движений документа по регистрам при отмене проведения
////	Является обработчиком подписки на событие "ОбработкаУдаленияПроведенияДокумента"
////
//Процедура ОбработкаУдаленияПроведенияДокумента(Источник, Отказ) Экспорт
//	
//	УдалитьДвиженияРегистратора(Источник, Отказ);
//	
//	Если Источник.ДополнительныеСвойства.Свойство("ТаблицаСтаройРегистрацииВПоследовательности")
//	  И Источник.ДополнительныеСвойства.ТаблицаСтаройРегистрацииВПоследовательности.Количество() > 0 Тогда
//		УправлениеЗапасамиПартионныйУчет.СдвинутьГраницуПоследовательностиНазад(Источник.Дата, Источник.Ссылка, Источник.ДополнительныеСвойства.ТаблицаСтаройРегистрацииВПоследовательности);
//	КонецЕсли;	
//	
//КонецПроцедуры

//Процедура ПриУстановкеНовогоКодаДляСправочникаИлиПВХ(Источник, СтандартнаяОбработка, Префикс) Экспорт
// 	ДобавитьПрефиксУзла(Префикс);
//КонецПроцедуры

//// Проверяет дату на заполненность по аналогии с системной функцией "ПустаяСтрока".
//// 
//Функция ПустаяДата(ПроверяемаяДата) Экспорт
//	
//	Если ТипЗнч(ПроверяемаяДата) = Тип("Дата") 
//	   И ПроверяемаяДата = Дата(1,1,1) Тогда
//	   
//		Возврат Истина;
//		
//	Иначе
//		
//		Возврат Ложь;
//		
//	КонецЕсли;
//	
//КонецФункции // ПустаяДата()

//// Функция возвращает массив вышестоящих групп указанного элемента.
//// 
//// Переметры:
////  Элемент      - Элемент справочника, для которого ищется родитель
////
//// Возвращаемое значение
////  Массив вышестояших групп
////
//Функция ПолучитьСписокВышеСтоящихГрупп(ЭлементСправочника) Экспорт
//	
//	Результат = Новый Массив;		
//	
//	Если НЕ ЗначениеЗаполнено(ЭлементСправочника) Тогда
//		Возврат Результат;
//	КонецЕсли;
//	
//	МетаданныеСправочника = ЭлементСправочника.Метаданные();
//	Если НЕ МетаданныеСправочника.Иерархический Тогда
//		Возврат Результат;
//	КонецЕсли;
//	ИмяСправочника = МетаданныеСправочника.Имя;	
//	Запрос = Новый Запрос;
//	Запрос.Текст = "
//	|ВЫБРАТЬ
//	|	Справочник1.Родитель КАК Родитель1,
//	|	Справочник2.Родитель КАК Родитель2,
//	|	Справочник3.Родитель КАК Родитель3,
//	|	Справочник4.Родитель КАК Родитель4,
//	|	Справочник5.Родитель КАК Родитель5
//	|ИЗ
//	|	Справочник." + ИмяСправочника + " КАК Справочник1
//	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник2
//	|		ПО (Справочник2.Ссылка = Справочник1.Родитель)
//	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник3
//	|		ПО (Справочник3.Ссылка = Справочник2.Родитель)
//	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник4
//	|		ПО (Справочник4.Ссылка = Справочник3.Родитель)
//	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник5
//	|		ПО (Справочник5.Ссылка = Справочник4.Родитель)
//	|ГДЕ
//	|	Справочник1.Ссылка = &Ссылка";
//	
//	ТекущийЭлемент = ЭлементСправочника;
//	
//	Пока ЗначениеЗаполнено(ТекущийЭлемент) Цикл		
//		Запрос.УстановитьПараметр("Ссылка", ТекущийЭлемент);
//		Выборка = Запрос.Выполнить().Выбрать();
//		Если Выборка.Следующий() Тогда
//			Для Индекс = 1 по 5 Цикл
//				ТекущийЭлемент = Выборка["Родитель" + Индекс];
//				Если ЗначениеЗаполнено(ТекущийЭлемент) Тогда
//					Результат.Добавить(ТекущийЭлемент);
//				Иначе
//					Прервать;
//				КонецЕсли;				
//			КонецЦикла;
//		Иначе
//			ТекущийЭлемент = Неопределено;
//		КонецЕсли;
//	КонецЦикла;	
//	
//	Возврат Результат;
//	
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПИСИ НАБОРОВ ЗАПИСЕЙ РЕГИСТРОВ, КОНСТАНТ

//// Проверяет значения констант из коллекции с текущим значением в ИБ,
//// не проверяется для типа данных ХранилищеЗначений
//// 
//// Параметры: 
////  КоллекцияКонстантДляПроверки  - структура
////									ключ 		- строка, имя константы
////									значение 	- значение константы
////
//// Возвращаемое значение:
////  Массив констант значение которых изменилось по сравнению с переданной коллекцией
////
//Функция СоздатьМассивИзмененныхКонстант(КоллекцияКонстантДляПроверки) Экспорт
//	
//	МассивИзмененныхКонстант = Новый Массив;
//	
//	Для каждого ЭлементКоллекции Из КоллекцияКонстантДляПроверки Цикл
//		
//		ИмяКонстанты 	  = ЭлементКоллекции.Ключ;
//		ЗначениеКонстанты = ЭлементКоллекции.Значение;
//		
//		ТекущееЗначение   = Константы[ИмяКонстанты].Получить();
//		Если  ТипЗнч(ТекущееЗначение) = Тип("ХранилищеЗначения") Тогда
//			// не сравниваем значения констант, у которых Тип данных - Хранилище значений
//			Продолжить;
//		КонецЕсли;	
//		
//		Если ЗначениеКонстанты <> ТекущееЗначение Тогда
//			МассивИзмененныхКонстант.Добавить(Метаданные.Константы[ИмяКонстанты]);
//		КонецЕсли;
//	
//	КонецЦикла;
//	
//	Возврат МассивИзмененныхКонстант;
//	
//КонецФункции

//// Функция выполняет запись переданного набора записей и 
//// формирует сообщение об ошибке, если не удалось записать набор
////
//// Параметры
////  НаборЗаписей  - набор записей регистра сведений, который необходимо записать
////
//// Возвращаемое значение:
////   Булево   - Истина, когда набор записей записан
////
//Функция ЗаписатьНабор(НаборЗаписей) Экспорт

//	Попытка
//		НаборЗаписей.Записать();
//	Исключение
//		ВывестиИнформациюОбОшибке(ПолучитьПричинуОшибки(ИнформацияОбОшибке()).Описание);
//		Возврат Ложь;
//	КонецПопытки;

//	Возврат Истина;
//	
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ НАСТРОЙКИ ПОРЯДКА ЭЛЕМЕНТОВ СПРАВОЧНИКА

//// Вспомогательная функция для определнения условий запроса в механизме
//// изменения порядка следования элементов. Ставит условия на родителя и владельца
////
//// Параметры
////  Элемент - СправочникСсылка, для которого необходимо изменить порядок
////  Запрос - Запрос, в который дописываем условия
//// 
////  Возвращаемое значение:
////   Строка - условие запроса
//// 
//Функция ПолучитьДополнениеЗапроса(Элемент, Запрос, БезПервогоИ = Ложь)

//	ТекстЗапроса = "";
//	
//	Если Элемент.Метаданные().Иерархический = Истина Тогда
//		Запрос.УстановитьПараметр("ТекущийРодитель", Элемент.Родитель);
//		Если НЕ БезПервогоИ Тогда
//			ТекстЗапроса = ТекстЗапроса + "
//			|	И
//			|";
//		КонецЕсли; 
//		ТекстЗапроса = ТекстЗапроса + "
//		|	СправочникПорядка.Родитель = &ТекущийРодитель
//		|";
//	КонецЕсли; 
//	
//	Если Элемент.Метаданные().Владельцы.Количество() > 0 Тогда
//		Запрос.УстановитьПараметр("ТекущийВладелец", Элемент.Владелец);
//		Если НЕ (ПустаяСтрока(ТекстЗапроса) И БезПервогоИ) Тогда
//			ТекстЗапроса = ТекстЗапроса + "
//			|	И
//			|";
//		КонецЕсли; 
//		ТекстЗапроса = ТекстЗапроса + "
//		|	СправочникПорядка.Владелец = &ТекущийВладелец
//		|";
//	КонецЕсли; 

//	Возврат ТекстЗапроса;
//	
//КонецФункции

//// Возвращает значение порядка для нового элемента справочника.
////
//// Параметры
////  ЭлементОбъект - СправочникОбъект - новый объект
////
//// Возвращаемое значение:
////   Число - новый порядок
////
//Функция НазначитьНовыйПорядок(ЭлементОбъект)

//	ИмяТаблицы = ЭлементОбъект.Метаданные().Имя;
//	
//	Запрос = Новый Запрос;
//	
//	Запрос.Текст = "
//	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
//	|	СправочникПорядка.Порядок
//	|ИЗ
//	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка";
//	
//	ДополнениеЗапроса = ПолучитьДополнениеЗапроса(ЭлементОбъект, Запрос, Истина);
//	
//	Если НЕ ПустаяСтрока(ДополнениеЗапроса) Тогда
//		Запрос.Текст = Запрос.Текст + "
//		|ГДЕ
//		|" + ДополнениеЗапроса + "
//		|";
//	КонецЕсли; 
//	
//	Запрос.Текст = Запрос.Текст + "
//	|УПОРЯДОЧИТЬ ПО
//	|	СправочникПорядка.Порядок УБЫВ
//	|";
//	
//	РезультатЗапроса = Запрос.Выполнить();
//	
//	Если РезультатЗапроса.Пустой() Тогда
//		Возврат 0;
//	Иначе
//		Выборка = РезультатЗапроса.Выбрать();
//		Выборка.Следующий();
//		Возврат (Выборка.Порядок + 1)
//	КонецЕсли; 

//КонецФункции

//// Процедура вызывается перед записью объекта, для которого необходимо
//// контролировать порядок элементов.
//// 
//// Параметры
////  Отказ - Булево, отказ от записи объекта
////  ЭтотОбъект - СправочникОбъект
////  КонтролироватьПорядок - Булево, контролировать порядок при записи объекта или нет
////
//Процедура ПередЗаписьюОбъектаПорядка(Отказ, ЭтотОбъект, КонтролироватьПорядок) Экспорт

//	Если ЭтотОбъект.ЭтоНовый() Тогда
//		ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
//	Иначе
//		Если ЭтотОбъект.Ссылка.Родитель <> ЭтотОбъект.Родитель ИЛИ ЭтотОбъект.Ссылка.Владелец <> ЭтотОбъект.Владелец Тогда
//			ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
//		КонецЕсли;
//	КонецЕсли;
//	
//	Если КонтролироватьПорядок Тогда
//	
//		ИмяТаблицы = ЭтотОбъект.Метаданные().Имя;
//		
//		Запрос = Новый Запрос;
//		
//		Запрос.УстановитьПараметр("ТекущийПорядок", ЭтотОбъект.Порядок);
//		
//		Запрос.Текст = "
//		|ВЫБРАТЬ ПЕРВЫЕ 1
//		|	СправочникПорядка.Порядок
//		|ИЗ
//		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
//		|ГДЕ
//		|	СправочникПорядка.Порядок = &ТекущийПорядок
//		|";
//		
//		Если НЕ ЭтотОбъект.ЭтоНовый() Тогда
//			Запрос.УстановитьПараметр("ТекущаяСсылка", ЭтотОбъект.Ссылка);
//			Запрос.Текст = Запрос.Текст + "
//			|И
//			|	СправочникПорядка.Ссылка <> &ТекущаяСсылка
//			|";
//		КонецЕсли; 
//		
//		Запрос.Текст = Запрос.Текст + ПолучитьДополнениеЗапроса(ЭтотОбъект, Запрос);
//		
//		Если НЕ Запрос.Выполнить().Пустой() Тогда
//			Отказ = Истина;
//			#Если Клиент Тогда
//				Сообщить("Не уникальный порядок элемента справочника.");
//			#КонецЕсли
//		КонецЕсли;
//	
//	КонецЕсли; 

//КонецПроцедуры

//// Процедура изменяет порядок следования объектов с настраиваемым из ВЯ
//// порядком следования.
//// 
//// Параметры:
////  ЭлементСсылка - СправочникСсылка, элемент для которого необходимо изменить порядок
////  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
////
//Процедура ИзменитьПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг = Истина) Экспорт
//	
//	ЭлементЗамены = ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг);
//	
//	Если ЭлементЗамены = Неопределено Тогда
//		Возврат;
//	КонецЕсли;
//	
//	НовыйПорядокЗамены   = ЭлементЗамены.Порядок;
//	НовыйПорядокЭлемента = ЭлементСсылка.Порядок;
//	
//	Если НаправлениеПорядка = "Вверх" Тогда
//		Если НовыйПорядокЗамены < НовыйПорядокЭлемента Тогда
//			ПромежуточныйПорядок = НовыйПорядокЗамены;
//			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
//			НовыйПорядокЭлемента = ПромежуточныйПорядок;
//		Иначе
//			НовыйПорядокЭлемента = НовыйПорядокЗамены + 1;
//		КонецЕсли; 
//	Иначе
//		Если НовыйПорядокЗамены > НовыйПорядокЭлемента Тогда
//			ПромежуточныйПорядок = НовыйПорядокЗамены;
//			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
//			НовыйПорядокЭлемента = ПромежуточныйПорядок;
//		Иначе
//			НовыйПорядокЭлемента = НовыйПорядокЗамены - 1;
//		КонецЕсли;
//	КонецЕсли;
//	
//	НачатьТранзакцию();
//	
//	ФиксироватьТранзакцию = Истина;
//	
//	Если НовыйПорядокЗамены <> ЭлементЗамены.Порядок Тогда
//		ОбъектЗамены = ЭлементЗамены.ПолучитьОбъект();
//		ОбъектЗамены.Порядок = НовыйПорядокЗамены;
//		ОбъектЗамены.КонтролироватьПорядок = Ложь;
//		Попытка
//			ОбъектЗамены.Записать();
//		Исключение
//			СообщитьОбОшибке(ОписаниеОшибки());
//			ФиксироватьТранзакцию = Ложь;
//		КонецПопытки;
//	КонецЕсли; 
//	
//	Если ФиксироватьТранзакцию Тогда
//		ОбъектЭлемента = ЭлементСсылка.ПолучитьОбъект();
//		ОбъектЭлемента.Порядок = НовыйПорядокЭлемента;
//		Попытка
//			ОбъектЭлемента.Записать();
//		Исключение
//			СообщитьОбОшибке(ОписаниеОшибки());
//			ФиксироватьТранзакцию = Ложь;
//		КонецПопытки;
//	КонецЕсли;
//	
//	Если ФиксироватьТранзакцию Тогда
//		ЗафиксироватьТранзакцию();
//	Иначе
//		ОтменитьТранзакцию();
//	КонецЕсли; 
//	
//КонецПроцедуры

//// Функция определяет элемент справочника, с которым необходимо
//// произвести "рокировку" текущего элемента
////
//// Параметры
////  ЭлементСсылка - СпраовочникСсылка, элемент для изменения порядка
////  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
////
//// Возвращаемое значение:
////   СправочникСсылка
////
//Функция ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг)

//	ТекущийПорядок = ЭлементСсылка.Порядок;
//	
//	ИмяТаблицы = ЭлементСсылка.Метаданные().Имя;
//	
//	Запрос = Новый Запрос;
//	
//	Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
//	
//	Запрос.Текст = "
//	|ВЫБРАТЬ ПЕРВЫЕ 1
//	|	СправочникПорядка.Ссылка
//	|ИЗ
//	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
//	|ГДЕ
//	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "<", ">") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
//	|УПОРЯДОЧИТЬ ПО
//	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
//	|";
//	
//	РезультатЗапроса = Запрос.Выполнить();
//	
//	Если НЕ РезультатЗапроса.Пустой() Тогда
//		
//		Выборка = РезультатЗапроса.Выбрать();
//		Выборка.Следующий();
//		Возврат Выборка.Ссылка;
//		
//	ИначеЕсли ЦиклическийСдвиг Тогда
//		// Текущий элемент или первый (при движении вверх)
//		// или последний (при движении вниз)
//		// или вообще единственный
//		
//		Запрос = Новый Запрос;
//		
//		Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
//	
//		Запрос.Текст = "
//		|ВЫБРАТЬ ПЕРВЫЕ 1
//		|	СправочникПорядка.Ссылка
//		|ИЗ
//		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
//		|ГДЕ
//		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", ">", "<") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
//		|УПОРЯДОЧИТЬ ПО
//		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
//		|";
//		
//		РезультатЗапроса = Запрос.Выполнить();
//		
//		Если РезультатЗапроса.Пустой() Тогда
//			Возврат Неопределено;
//		Иначе
//			Выборка = РезультатЗапроса.Выбрать();
//			Выборка.Следующий();
//			Возврат Выборка.Ссылка;
//		КонецЕсли; 
//	Иначе
//		Возврат Неопределено;
//	КонецЕсли;

//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

//// Предназначена для получения пустого значения заданного типа:
////	примитивного, или ссылочного. Используется
////
//// Параметры:
////	ЗаданныйТип   - тип, пустое значение которого нужно получить
////
//Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
//	
//	Если ЗаданныйТип = Тип("Число") Тогда
//		Возврат 0;
//	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
//		Возврат "";
//	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
//		Возврат '00010101000000';
//	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
//		Возврат Ложь;
//	Иначе
//		Возврат Новый (ЗаданныйТип);
//	КонецЕсли;
//	
//КонецФункции // ПустоеЗначениеТипа();

////Предназначена для получения массива пустых значений, содержащих значение Неопределено и значения переданного типа или описания типов
//Функция МассивПустыхЗначений(ОписаниеТипов) Экспорт
//	МассивЗначений = новый Массив;
//	МассивЗначений.Добавить(неопределено);
//	Если ТипЗнч(ОписаниеТипов)=Тип("ОписаниеТипов") Тогда
//		Для каждого Тип из ОписаниеТипов.Типы() Цикл
//			МассивЗначений.Добавить(ПустоеЗначениеТипа(Тип));
//		КонецЦикла;
//	ИначеЕсли ТипЗнч(ОписаниеТипов)=Тип("Тип") Тогда	
//		МассивЗначений.Добавить(ПустоеЗначениеТипа(ОписаниеТипов));
//	КонецЕсли;
//	
//	Возврат МассивЗначений;

//КонецФункции

//// Позволяет определить есть ли среди реквизитов табличной части документа
//// реквизит с переданным именем.
////
//// Параметры: 
////  ИмяРеквизита - строковое имя искомого реквизита, 
////  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
////  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
////
//// Возвращаемое значение:
////  Истина - нашли реквизит с таким именем, Ложь - не нашли.
////
//Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт

//	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
//	// есть таб. часть в документе
//	Возврат ТабЧасть <> Неопределено И ТабЧасть.Реквизиты.Найти(ИмяРеквизита) <> Неопределено

//КонецФункции // ЕстьРеквизитТабЧастиДокумента()


//// Функция проверяет наличие в строке только цифр
////
//// Параметры
////  СтрокаПроверки - Строка для проверки только цифр
////
//// Возвращаемое значение:
////   Булево
////
//Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

//	СписокКодовЧисел = Новый СписокЗначений;
//	Для а = 48 По 57 Цикл
//		СписокКодовЧисел.Добавить(а);
//	КонецЦикла; 
//	
//	СтрокаПроверки = СокрЛП(СтрокаПроверки);
//	
//	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
//		
//		Возврат Истина;
//		
//	Иначе
//		
//		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
//			Если СписокКодовЧисел.НайтиПоЗначению(КодСимвола(Сред(СтрокаПроверки, а, 1))) = Неопределено Тогда
//				Возврат Истина;
//			КонецЕсли; 
//		КонецЦикла; 
//		
//	КонецЕсли; 

//	Возврат Ложь;
//	
//КонецФункции

//// Если в шапке переданного документа есть реквизит с указанным именем, то возвращается его значение.
//// Если такого реквизита нет - возвращается Неопределено.
////
//// Параметры:
////  ИмяРеквизита - Строка. Имя искомого реквизита.
////  ДокументОбъект - объект переданного документа.
////  МетаданныеДокумента - Метаданные переданного документа.
////  ПустоеЗначение - значение, которое должно вернуться, если в шапке нет такого реквизита,
////  если не передано, то возвращается значение Неопределено.
////
//// Возвращаемое значение:
////  Значение реквизита - значение найденного реквизита или ПустоеЗначение.
////
//Функция ПолучитьРеквизитШапки(ИмяРеквизита, ДокументОбъект, МетаданныеДокумента, ПустоеЗначение = Неопределено) Экспорт

//	ЗначениеРеквизита = ?(МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) <> Неопределено,
//	                      ДокументОбъект[ИмяРеквизита], ПустоеЗначение);

//	Возврат ЗначениеРеквизита;

//КонецФункции // ПолучитьРеквизитШапки()

/////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ ЗАГРУЗКИ КЛАССИФИКАТОРОВ

//Процедура ЗагрузитьКлассификаторИзXML(ПустойЭлементСправочника, ИмяФайлаПоУмолчанию) Экспорт
//	
//	ФормаЗагрузки = ПолучитьОбщуюФорму("ФормаЗагрузкиКлассификатораИзXML");
//	ФормаЗагрузки.ПустойЭлементСправочника = ПустойЭлементСправочника;
//	ФормаЗагрузки.ИмяФайлаПоУмолчанию = ИмяФайлаПоУмолчанию;
//	ФормаЗагрузки.Открыть();
//	
//КонецПроцедуры


//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

//// Функнция проверяет заполнения обязательных параметров для отправки сообщения
////  в отдел технической поддержки.
////
//// Параметры
////  ТаблицаДанных - Таблица значений
////
//// Возвращаемое значение:
////   Булево - результат корректости проверки
////
//Функция ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(ТаблицаДанных, ПубликоватьСообщения = Истина) Экспорт

//	ЗначениеПроверки = Истина;
//	СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";
//	
//	СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
//	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
//	СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
//	СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
//	
//	Для каждого СтрокаРаздела Из ТаблицаДанных Цикл
//		Для каждого ЭлементЗначения Из СтрокаРаздела.ДанныеРаздела Цикл
//			Если СписокИменОбязательныхРеквизитов.НайтиПоЗначению(ЭлементЗначения.Ключ) <> Неопределено И НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
//				Если ПубликоватьСообщения Тогда
//					СообщитьОбОшибке("Не указан """ + Лев(ЭлементЗначения.Значение[0], (СтрДлина(ЭлементЗначения.Значение[0]) - 1)) + """.",, СтрокаЗаголовкаОшибки);
//				КонецЕсли; 
//				ЗначениеПроверки = Ложь;
//			КонецЕсли; 
//		КонецЦикла; 
//	КонецЦикла;
//	
//	Возврат ЗначениеПроверки;

//КонецФункции // ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()

//// Процедура формирует таблицу значений со структурой для заполнения данными
//// с информацией обращения в отдел технической поддержки
////
//// Параметры:
////  ТаблицаДанных - таблица значений для заполнения
////  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
////
//Процедура ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(ТаблицаДанных, ФормаНастройкиПараметров = Неопределено) Экспорт

//	// Структура данных - таблица значений:
//	//  Колонки:
//	//   ИмяРездела
//	//   ПредставлениеРаздела
//	//   ДанныеРаздела
//	
//	// Структура данных раздела
//	//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
//	//  Значение - Массив значений
//	// 
//	// Массив значений:
//	//  [0] - Представление наименования параметра для печати
//	//  [1] - Значение параметра

//	Если ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений") Тогда
//		ТаблицаДанных = Новый ТаблицаЗначений;
//	КонецЕсли;
//	
//	Если ТаблицаДанных.Колонки.Количество() = 0 Тогда
//		ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));
//		ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));
//		ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));
//		ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));
//	КонецЕсли;
//	
//	ТаблицаДанных.Индексы.Добавить("ИмяРаздела");
//	
//	Если ФормаНастройкиПараметров = Неопределено Тогда
//		ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");
//	КонецЕсли;
//	
//	Для каждого ЭлементФормы Из ФормаНастройкиПараметров.ЭлементыФормы Цикл
//		
//		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеВвода")
//		   И ТипЗнч(ЭлементФормы) <> Тип("ПолеВыбора")
//		   И ТипЗнч(ЭлементФормы) <> Тип("Флажок") Тогда
//			Продолжить;
//		КонецЕсли;
//		
//		ПозицияРазделителяРаздела = Найти(ЭлементФормы.Имя, "_");
//		Если ПозицияРазделителяРаздела = 0 Тогда
//			Продолжить;
//		КонецЕсли;
//		
//		ИмяРаздела = Сред(ЭлементФормы.Имя, 1, (ПозицияРазделителяРаздела - 1));
//		СтрокаРаздела = ТаблицаДанных.Найти(ИмяРаздела, "ИмяРаздела");
//		Если СтрокаРаздела = Неопределено Тогда
//			СтрокаРаздела = ТаблицаДанных.Добавить();
//			СтрокаРаздела.ИмяРаздела           = ИмяРаздела;
//			Попытка
//				СтрокаРаздела.ПредставлениеРаздела = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела].Заголовок;
//				СтрокаРаздела.ИндексСортировки     = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы.Индекс(ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела]);
//			Исключение
//				СтрокаРаздела.ПредставлениеРаздела = ИмяРаздела;
//			КонецПопытки;
//		КонецЕсли;
//		
//		МассивЗначений = Новый Массив;
//		Попытка
//			Если ТипЗнч(ЭлементФормы) = Тип("Флажок") Тогда
//				МассивЗначений.Добавить((ЭлементФормы.Заголовок + ":"));
//			Иначе
//				МассивЗначений.Добавить(ФормаНастройкиПараметров.ЭлементыФормы["Надпись_" + ЭлементФормы.Имя].Заголовок);
//			КонецЕсли; 
//		Исключение
//			МассивЗначений.Добавить(ЭлементФормы.Имя);
//		КонецПопытки;
//		МассивЗначений.Добавить("");
//		
//		СтрокаРаздела.ДанныеРаздела.Вставить(ЭлементФормы.Имя, МассивЗначений);
//		
//	КонецЦикла;
//	
//	ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");
//	
//КонецПроцедуры

//// Функция формирует текст сообщения на линию техподдержки
////
//// Параметры
////  НЕТ
////
//// Возвращаемое значение:
////   Текст сообщения
////
//Функция ПолучитьТекстСообщенияВОтделТехническойПоддержки() Экспорт

//	ТекстВозврата = "";
//	
//	ТекстВозврата = ТекстВозврата + Символы.ПС;
//	ТекстВозврата = ТекстВозврата + Символы.ПС;
//	ТекстВозврата = ТекстВозврата + Символы.ПС + "============ Сведения об использовании ПП 1С:Предприятие 8 ============";
//	
//	ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
//	
//	// Сформируем обязательный информационный раздел
//	
//	СистемИнфо = Новый СистемнаяИнформация;
//	
//	ТекстВозврата = ТекстВозврата + Символы.ПС;
//	ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
//	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8: "   + СистемИнфо.ВерсияПриложения;
//	ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
//	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия конфигурации: "       + Метаданные.Версия;
//	ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
//	ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
//	ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
//	ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;

//	НомерСтрокиРаздела = 1;
//	
//	Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
//		
//		Для каждого СтрокаТаблицыРаздела Из ТаблицаДанных Цикл
//			
//			СтрокаРаздела = "";
//			
//			Если СтрокаТаблицыРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения" Тогда
//				Продолжить;
//			КонецЕсли;
//			
//			Для каждого ЭлементЗначения Из СтрокаТаблицыРаздела.ДанныеРаздела Цикл
//				Если НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
//					Продолжить;
//				КонецЕсли; 
//				СтрокаРаздела = СтрокаРаздела + Символы.ПС + ЭлементЗначения.Значение[0] + " " + ?(ТипЗнч(ЭлементЗначения.Значение[1]) = Тип("Булево"), ?(ЭлементЗначения.Значение[1], "Да", "Нет"), ЭлементЗначения.Значение[1]);
//			КонецЦикла; 
//			
//			Если НЕ ЗначениеЗаполнено(СтрокаРаздела) Тогда
//				Продолжить;
//			КонецЕсли;
//			
//			НомерСтрокиРаздела = НомерСтрокиРаздела + 1;
//			
//			СтрокаРаздела = Строка(НомерСтрокиРаздела) + ". " + ВРег(СтрокаТаблицыРаздела.ПредставлениеРаздела) + СтрокаРаздела;
//			
//			ТекстВозврата = ТекстВозврата + Символы.ПС;
//			ТекстВозврата = ТекстВозврата + Символы.ПС + СтрокаРаздела;
//		
//		КонецЦикла;
//		
//	КонецЕсли;
//	
//	Возврат ТекстВозврата;

//КонецФункции // ПолучитьТекстСообщенияВОтделТехническойПоддержки()

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

//// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
//// 
//// Параметры:
////  ДлинаСтроки - число, длина строки.
////
//// Возвращаемое значение:
////  Объект "ОписаниеТипов" для строки указанной длины.
////
//Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт

//	Возврат Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная));

//КонецФункции // ПолучитьОписаниеТиповСтроки()

//// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
//// 
//// Параметры:
////  Разрядность 			- число, разряд числа.
////  РазрядностьДробнойЧасти - число, разряд дробной части.
////
//// Возвращаемое значение:
////  Объект "ОписаниеТипов" для числа указанной разрядности.
////
//Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт

//	Если ЗнакЧисла = Неопределено Тогда
//		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
//	Иначе
//		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
//	КонецЕсли;

//	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);

//КонецФункции // ПолучитьОписаниеТиповЧисла()

//// Служебная функция, предназначенная для получения описания типов даты
//// 
//// Параметры:
////  ЧастиДаты - системное перечисление ЧастиДаты.
//// 
//Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

//	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));

//КонецФункции // ПолучитьОписаниеТиповДаты()

////функция выполняет приведение строки к числу
//// Параметры:
////  ЧислоСтрокой           - Строка - Строка приводимая к числу
////  ВозвращатьНеопределено - Булево - Если Истина и строка содержит некорректное значение, то возвращать Неопределено
////
//// Возвращаемое значение:
////  Число
////
//Функция ПривестиСтрокуКЧислу(ЧислоСтрокой, ВозвращатьНеопределено = Ложь) Экспорт
//	
//	ОписаниеТипаЧисла = Новый ОписаниеТипов("Число");
//	ЗначениеЧисла = ОписаниеТипаЧисла.ПривестиЗначение(ЧислоСтрокой);
//	
//	Если ВозвращатьНеопределено И (ЗначениеЧисла = 0) Тогда
//		
//		Стр = Строка(ЧислоСтрокой);
//		Если Стр = "" Тогда
//			Возврат Неопределено;
//		КонецЕсли;
//		
//		Стр = СтрЗаменить(СокрЛП(Стр), "0", "");
//		Если (Стр <> "") И (Стр <> ".") И (Стр <> ",") Тогда
//			Возврат Неопределено;
//		КонецЕсли;
//	КонецЕсли;
//	
//	Возврат ЗначениеЧисла;	
//	
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СВОЙСТВАМИ И КАТЕГОРИЯМИ ОБЪЕКТОВ

////Функция возвращает список доступных назначений для "Свойств и категорий объектов" 
////по переданной ссылке
//// Параметры:
////	Ссылка - Ссылка на справочник или документ
////
//// Возвращаемое значение:
//// Список значений: доступные назначения для свойств и категорий
//Функция ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке(Ссылка) Экспорт

//	Результат = Новый СписокЗначений;
//	
//	Если Ссылка = Неопределено Тогда
//		Возврат Результат;
//	КонецЕсли;

//	ТипСсылки = ТипЗнч(Ссылка);
//	ЭтоХарактеристика = (ТипСсылки = Тип("СправочникСсылка.ХарактеристикиНоменклатуры"));

//	Запрос = Новый Запрос;
//	Запрос.УстановитьПараметр("НазначениеХарактеристика", ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ХарактеристикиНоменклатуры);

//	ТекстЗапроса = "
//	|ВЫБРАТЬ
//	|	Назначения.Ссылка КАК Ссылка,
//	|	Назначения.ТипЗначения КАК ТипЗначения
//	|ИЗ
//	|	ПланВидовХарактеристик.НазначенияСвойствКатегорийОбъектов КАК Назначения
//	|ГДЕ
//	|	НЕ Назначения.ЭтоГруппа
//	|";

//	Если ЭтоХарактеристика Тогда
//		ТекстЗапроса = ТекстЗапроса + "
//		|	И Назначения.Ссылка = &НазначениеХарактеристика
//		|";
//	Иначе
//		ТекстЗапроса = ТекстЗапроса + "
//		|	И Назначения.Ссылка <> &НазначениеХарактеристика
//		|";
//	КонецЕсли;

//	Запрос.Текст = ТекстЗапроса;

//	Выборка = Запрос.Выполнить().Выбрать();
//	Пока Выборка.Следующий() Цикл
//		Если ЭтоХарактеристика Или Выборка.ТипЗначения.СодержитТип(ТипСсылки) Тогда
//			Результат.Добавить(Выборка.Ссылка);
//		КонецЕсли;
//	КонецЦикла;

//	Возврат Результат;

//КонецФункции // ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке()

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

//// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
//Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 
//	
//	Если МассивДанные = Неопределено Тогда
//		Возврат -1;
//	КонецЕсли;
//	
//	Для ИндексЭлемента = 0 По МассивДанные.ВГраница() Цикл
//		
//		Если  (МассивДанные[ИндексЭлемента] = Элемент) Тогда
//			Возврат ИндексЭлемента;
//		КонецЕсли;	
//		
//	КонецЦикла;
//	
//	// не нашли элемент
//	Возврат -1;
//	
//КонецФункции

//// Удаление из массива пустых элементов
////
//// Параметры:
////   МассивЭлементов - Массив
////
//Процедура УдалитьНеЗаполненныеЭлементыМассива(МассивЭлементов) Экспорт

//	Колво = МассивЭлементов.Количество();
//	Для н=1 По Колво Цикл
//		Если НЕ ЗначениеЗаполнено(МассивЭлементов[Колво-н]) Тогда
//			МассивЭлементов.Удалить(Колво-н);
//		КонецЕсли;
//	КонецЦикла;

//КонецПроцедуры

//////////////////////////////////////////////////////////////////////////////////
////  ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УНИВЕРСАЛЬНЫМИ КОЛЛЕКЦИЯМИ ЗНАЧЕНИЙ

//// Создает копию переданного массива, структуры или соответствия
////
//// Параметры:
////  КоллекцияИсходная: тип Массив, Структура, Соответствие - исходная коллекция
//// Возвращаемое значение:
////  КоллекцияКопия:  тип Массив, Структура, Соответствие - копия исходной коллекции
////
//Функция СкопироватьУниверсальнуюКоллекцию(КоллекцияИсходная) Экспорт
//	
//	Если ТипЗнч(КоллекцияИсходная)=Тип("Массив") Тогда
//		
//		КоллекцияКопия=Новый Массив;
//		
//		Для Каждого Элемент Из КоллекцияИсходная Цикл
//			
//			КоллекцияКопия.Добавить(Элемент);
//			
//		КонецЦикла;
//		
//		Возврат КоллекцияКопия;
//		
//	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Структура") Тогда
//		
//		КоллекцияКопия=Новый Структура;
//		
//		Для Каждого Элемент Из КоллекцияИсходная Цикл
//			
//			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
//			
//		КонецЦикла;
//		
//		Возврат КоллекцияКопия; 
//		
//	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Соответствие") Тогда
//		
//		КоллекцияКопия=Новый Соответствие;
//		
//		Для Каждого Элемент Из КоллекцияИсходная Цикл
//			
//			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
//			
//		КонецЦикла;
//		
//		Возврат КоллекцияКопия;
//		
//	Иначе
//		
//		Сообщить("Неверный тип универсальной коллекции для копирования");
//		Возврат Неопределено
//		
//	КонецЕсли;
//	
//КонецФункции // СкопироватьУниверсальнуюКоллекцию()

//// Разворачивает таблицу  значений по вложенной таблице
////
//// Параметры
////  ТаблицаЗначений  – <ТаблицаЗначений> – базовая таблица
////  КолонкаВложеннойТаблицы  – <Строка> – Наименование колонки влолженной таблицы
////  СписокРаспределяемыхКолонок  – <Структура> – Структура с именами колонок базовой таблицы, значения которых будут распределяться по колонке вложенной таблицы
////         						Ключ - Имя колонки базовой таблицы
////         						Значение - Имя колонки вложенной таблицы. Если во вложенной таблице колонка не обнаружена - обработка прекращается.
//// Возвращаемое значение:
////   <ТаблицаЗначений>   – таблица значений, развернутая по значениям вложенной таблицы.
////
//// При совпадении имен базовой и вложенной таблиц - если  
//Функция РазвернутьПоВложеннойТаблице(ТаблицаЗначений, КолонкаВложеннойТаблицы,СписокРаспределяемыхКолонок, СписокИсключаемыхКолонок, СообщатьОбОшибке = Истина) Экспорт

//	Если ТаблицаЗначений.Количество()=0 Тогда
//		// Таблица не заполнена, софрмировать новую таблицу не представляется возможнным
//		// Отсуттствует вложенная таблица, структуру данных выходной таблицы сформировать невозможно
//		Если СообщатьОбОшибке Тогда
//			СообщитьОбОшибке("Отсутствуют строки в базовой таблице, распределение по вложенной таблице невозможно.",,,СтатусСообщения.Внимание);
//		КонецЕсли; 
//		Возврат Неопределено;
//	КонецЕсли; 
//	
//	КолонкиВложеннойТаблицы = ТаблицаЗначений[0][КолонкаВложеннойТаблицы].Колонки;
//	//Заполним значения по тем колонкам, по которым не были заполены значения ранее
//	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
//		Если НЕ ЗначениеЗаполнено(Колонка.Значение) Тогда
//			СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
//		КонецЕсли;
//		Если КолонкиВложеннойТаблицы.Найти(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено Тогда
//			// Во вложенной таблице не обнаружена колонка, по которой производится распределение.
//			Если СообщатьОбОшибке Тогда
//				СообщитьОбОшибке("Во вложенной таблице не обнаружена колонка ("+?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+"), по которой производится распределение.",,,СтатусСообщения.Внимание);
//			КонецЕсли; 
//			Возврат Неопределено;
//		КонецЕсли; 
//	КонецЦикла;
//	
//	НоваяТаблицаЗначений = Новый ТаблицаЗначений();
//	Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
//	    Если Колонка.Имя = КолонкаВложеннойТаблицы Тогда
//			Продолжить;
//	    ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
//			Продолжить;
//		КонецЕсли; 
//		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
//	КонецЦикла; 
//	
//	Для каждого Колонка Из КолонкиВложеннойТаблицы Цикл
//		Если не НоваяТаблицаЗначений.Колонки.Найти(Колонка.Имя) = неопределено Тогда
//			Продолжить;
//		ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
//			Продолжить;
//		КонецЕсли; 
//		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
//	КонецЦикла; 
//	
//	Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 

//		ТаблицаДляРаспределения = СтрокаБазовойТаблицы[КолонкаВложеннойТаблицы];

//		Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл

//			СтрокаНовойТаблицы = НоваяТаблицаЗначений.Добавить();

//			Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл

//				Если СписокРаспределяемыхКолонок.Свойство(Колонка.Имя) тогда
//					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[СписокРаспределяемыхКолонок[Колонка.Имя]];

//				ИначеЕсли не КолонкиВложеннойТаблицы.Найти(Колонка.Имя) = Неопределено тогда
//					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[Колонка.Имя];

//				ИначеЕсли Не(ТаблицаЗначений.Колонки.Найти(Колонка.Имя)=Неопределено) тогда
//					СтрокаНовойТаблицы[Колонка.Имя] = СтрокаБазовойТаблицы[Колонка.Имя];

//				Иначе
//					// Колонка не найдена - ошибка при выполнении распределения по вложенной таблице
//		  			Если СообщатьОбОшибке Тогда
//						СообщитьОбОшибке("при распределении по вложенной таблице невозможно определить значение для колонки :"+Колонка.Имя+".",,,СтатусСообщения.Внимание);
//					КонецЕсли; 

//				КонецЕсли;

//			КонецЦикла; // Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл

//		КонецЦикла; // Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл

//	КонецЦикла; // Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 
//	
//	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
//		СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
//	КонецЦикла;
//	
//	// Распределение базовых данных по распределяемым колонкам
//	НоваяТаблицаЗначений = СформироватьКорректирующиеЗаписи(ТаблицаЗначений,НоваяТаблицаЗначений,СписокРаспределяемыхКолонок);
//	
//	Возврат НоваяТаблицаЗначений;

//КонецФункции // РазвернутьПоВложеннойТаблице()

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ ВЫВОДА СООБЩЕНИЙ


//Функция ОпределитьВажностьСобытияЖурналаРегистрации(Статус)
//	ВидСобытия = УровеньЖурналаРегистрации.Информация;
//	Если Статус = СтатусСообщения.Внимание Тогда
//		ВидСобытия = УровеньЖурналаРегистрации.Предупреждение;
//	ИначеЕсли Статус = СтатусСообщения.Важное или  Статус = СтатусСообщения.ОченьВажное Тогда
//		ВидСобытия = УровеньЖурналаРегистрации.Ошибка;
//	КонецЕсли;
//    Возврат  ВидСобытия;
//КонецФункции

////Процедура проверяет необходимость вывода сообщения в журнал регистрации, при необходимости выводит сообщение в журнал регистрации
//// Параметры:
////	ТекстСообщения - Строка - Текст сообщения
////	Статус - ПеречислениеСсылка.ВидыСообщений - Вид сообщения
////		   - СтатусСообщения - Статус сообщения (используется для совместимости со старыми вызовами процедуры Сообщить)
////	Заголовок - Строка - Текст заголовка
////
//Процедура ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок="")
//	//Если сообщение выводится во внешнем соединении, оно всегда должно быть выведено в журнал регистрации (независимо от настроек)
//	//Это необходимо для того, чтобы в ЖР были видны сообщения при автоматическом обновлении
//	#Если НЕ ВнешнееСоединение Тогда
//	ДублироватьСообщенияВЖурналРегистрации = глЗначениеПеременной("ДублироватьСообщенияВЖурналРегистрации");
//	Если НЕ ДублироватьСообщенияВЖурналРегистрации Тогда
//		Возврат;
//	КонецЕсли;
//	#КонецЕсли
//	Важность = ОпределитьВажностьСобытияЖурналаРегистрации(Статус);
//	Если Заголовок <> "" Тогда
//		//вывод заголовка как отдельной записи в журнал
//		ЗаписьЖурналаРегистрации("Сообщение", УровеньЖурналаРегистрации.Примечание, , ,Заголовок);
//	КонецЕсли;
//	
//	ЗаписьЖурналаРегистрации("Сообщение", Важность, , ,ТекстСообщения);

//КонецПроцедуры

//// Процедура выводит пользователю сообщение: в журнал регистрации, в панель комментариев, в окно сообщений (в зависимости от настроек).
////
//// Параметры:
////	ТекстСообщения - Строка - Текст сообщения
////	Статус - ПеречислениеСсылка.ВидыСообщений - Вид сообщения
////		   - СтатусСообщения - Статус сообщения (используется для совместимости со старыми вызовами процедуры Сообщить)
////	Заголовок - Строка - Текст заголовка
////	РасшифровкаСообщения - Массив - Массив с данными расшифровки
////						 - Ссылка - Ссылка на объект
////	СтрокаРодитель - Родительская строка дерева значений для вывода сообщения
////	РаскрытьСообщение - Булево - Признак раскрытия строки дерева сообщений
////
//// Возвращаемое значение:
////	СтрокаДереваЗначенний - Строка дерева значений, в которую записано текущее сообщение
////Если вывод сообщений в панель комментариев не предусмотрен, возвращается Неопределено
//Функция Сообщение(Знач ТекстСообщения, Статус = Неопределено, Заголовок = "", РасшифровкаСообщения = Неопределено, СтрокаРодитель = Неопределено, РаскрытьСообщение = Истина, ЭтоСообщениеОбОшибке = Ложь) Экспорт
//	
//	ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок);
//	СтрокаДереваЗначений = ВыводСообщений.ВывестиСообщениеВПанельКомментариев(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, СтрокаРодитель, РаскрытьСообщение);
//	Если СтрокаДереваЗначений = Неопределено Тогда //Сообщение в панель комментариев не выведено, значит необходимо вывести его в окно сообщений
//		ВыводСообщений.ВывестиСообщениеВОкноСообщений(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, ЭтоСообщениеОбОшибке);
//	КонецЕсли;
//	
//	Возврат СтрокаДереваЗначений;
//	
//КонецФункции // Сообщение()

//////////////////////////////////////////////////////////////////////////////////
//// ВЫВОД ТРАССИРОВОЧНЫХ СООБЩЕНИЙ
//Процедура СообщитьОСостоянииОбновления(Подсистема, Действие, Комментарий="", Уровень=0, флЗавершающее=ложь) Экспорт
//	СтрокаТабуляций = "";
//	Для ш = 1 По Уровень Цикл
//		СтрокаТабуляций = СтрокаТабуляций + Символы.Таб;
//	КонецЦикла;	
//	Если флЗавершающее Тогда
//		ВидСообщенияе = СтатусСообщения.Информация;
//	Иначе
//		ВидСообщения = СтатусСообщения.Внимание;
//	КонецЕсли;
//	
//	ОбщегоНазначения.Сообщение(СтрокаТабуляций + Подсистема + ": " + Действие + ?(Комментарий = "",""," (" + Комментарий + ")"),ВидСообщения);
//КонецПроцедуры	


//Процедура СообщитьОСостоянииИзмененияНастройки(ИмяНастройки,Действие, Комментарий="", Уровень=0,текСтатусСообщения=неопределено) Экспорт
//	Если текСтатусСообщения = неопределено Тогда
//		СтатусСообщенияДляВывода = СтатусСообщения.Информация;
//	Иначе
//		СтатусСообщенияДляВывода = текСтатусСообщения;
//	КонецЕсли;
//		
//	СтрокаТабуляций = "";
//	Для ш = 1 По Уровень Цикл
//		СтрокаТабуляций = СтрокаТабуляций + Символы.Таб;
//	КонецЦикла;	
//	ОбщегоНазначения.Сообщение(СтрокаТабуляций + "Настройка учета: "+ИмяНастройки+". "+Действие + ?(Комментарий = "",""," (" + Комментарий + ")"),СтатусСообщенияДляВывода);
//КонецПроцедуры	

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

//// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
//// В случае работы на клиенте вывобит сообщение в обработку комментирования
//// на сервере выводит в окно сообщений,
//// в случае внешнего соединения вызывает исключение.
////
//// Параметры:
////  ТекстСообщения  - строка, текст сообщения.
////					  Строка может содержать символы %%, которые при формировании 
////					  сообщения заменяются на представления элементов расшифровки
////  Отказ           - булево, признак отказа (необязательный).
////  Заголовок	    - Заголовок сообщения, для вывода сообщения если работа на сервере или внешнее соединение
////	Расшифровки 	- массив расшифровок для переданного ТекстСообщения
////					  Представляет собой массив структур с полями Представление и Расшифровка
////					  Поле Представление - текст, дополняющий ТекстСообщения
////					  Поле Расшифровка - действие, выполняемое по расшифровке
////
//Процедура ВывестиИнформациюОбОшибке(Знач ТекстСообщения, Отказ = Истина, Заголовок = "", ВидСообщения = Неопределено, Расшифровки = Неопределено, РодительскаяСтрока = НеОпределено, РаскрытьСообщение = Истина) Экспорт
//	
//	Отказ = Истина;
//	
//	#Если Клиент Тогда
//	
//		Если ВидСообщения = Неопределено Тогда
//			ВидСообщения = Перечисления.ВидыСообщений.Ошибка;
//		КонецЕсли;
//		Обработка = глЗначениеПеременной("глОбработкаСообщений");
//		Обработка.ДобавитьСообщение(ТекстСообщения, ВидСообщения, Расшифровки, РодительскаяСтрока, РаскрытьСообщение);
//		
//	#ИначеЕсли ВнешнееСоединение Тогда
//		
//		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
//		Если ЗначениеЗаполнено(Заголовок) Тогда
//			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
//			Заголовок = "";
//		КонецЕсли;
//		
//		ВызватьИсключение (ТекстСообщения);
//		
//	#Иначе
//		
//		Если ЗначениеЗаполнено(Заголовок) Тогда
//			Сообщить(Заголовок);
//			Заголовок = "";
//		КонецЕсли;
//		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
//		Сообщить(ТекстСообщения, СтатусСообщения.Важное);
//		
//	#КонецЕсли
//	
//КонецПроцедуры // ВывестиИнформациюОбОшибке()

//// Функция убирает из текста сообщения служебную информацию.
////
//// Параметры:
////  ТекстСообщения, Строка, исходный текст сообщения
////
//// Возвращаемое значение:
////   Строка
////
//Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

//	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
//	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
//	
//	Если ОкончаниеСлужебногоСообщения > 0 
//		И НачалоСлужебногоСообщения > 0 
//		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
//		
//		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
//		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
//						 
//	КонецЕсли;
//	
//	Возврат СокрЛП(ТекстСообщения);

//КонецФункции

//Процедура СообщитьИнформациюПользователю(СтрокаСообщенияПользователю) Экспорт
//	
//	#Если Клиент Тогда
//	Сообщить(СтрокаСообщенияПользователю);
//	#КонецЕсли
//	
//КонецПроцедуры

//// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
//// В случае работы на клиенте или на сервере выводит в окно сообщений,
//// в случае внешнего соединения вызывает исключение.
////
//// Параметры:
////  ТекстСообщения - строка, текст сообщения.
////  Отказ          - булево, признак отказа (необязательный).
////	Заголовок - Строка - Текст заголовка
////          (выводится пользователю в режиме обычного приложения; 
////           в заголовке должен быть описан контекст выполняемых действий, например "Проведение документа №... от ...")
////	Статус - СтатусСообщения - Статус сообщения
////	РасшифровкаСообщения - Массив - Массив с данными расшифровки
////						 - Ссылка - Ссылка на объект
////
//Процедура СообщитьОбОшибке(
//	Знач ТекстСообщения, 
//	Отказ = Ложь, 
//	Заголовок = "",
//	Статус = Неопределено,
//	РасшифровкаСообщения = Неопределено
//	) Экспорт

//	Если Статус = Неопределено Тогда
//		Статус = СтатусСообщения.Важное;
//	КонецЕсли;
//	
//	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);

//	Отказ = Истина;
//	
//	#Если ВнешнееСоединение Тогда
//		//Для клиента и сервера запись в журнал регистрации попадет внутри процедуры Сообщение
//		ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок);
//		
//		Если ЗначениеЗаполнено(Заголовок) Тогда
//			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
//			Заголовок = "";
//		КонецЕсли;
//		
//		ВызватьИсключение (ТекстСообщения);
//		
//	#Иначе
//		
//		Сообщение(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, Неопределено, Истина, Истина);
//		
//	#КонецЕсли
//	
//КонецПроцедуры // СообщитьОбОшибке()

//Процедура ПоказатьДиалогСИнформациейОбОшибке(ИнформацияОбОшибке) Экспорт
//	
//	#Если Клиент Тогда
//		ПоказатьИнформациюОбОшибке(ИнформацияОбОшибке);
//	#Иначе
//		СообщитьОбОшибке(ПолучитьПричинуОшибки(ИнформацияОбОшибке).Описание);
//	#КонецЕсли
//	
//КонецПроцедуры

//// Выводит сообщение "пользовательского" вида о невозможности заблокировать объект
////
//Процедура СообщитьОбъектЗаблокирован(ПредставлениеОбъекта, ПредставлениеТипа, Отказ = Ложь) Экспорт
//	
//	ТекстСообщения = "Не удалось записать " + ПредставлениеТипа + " " + ПредставлениеОбъекта + "!" + Символы.ПС + "Возможно, его данные редактируются другим пользователем.";
//	ТекстЗаголовка = "Ошибка блокировки объекта";
//	
//	Отказ = Истина;
//	
//	#Если Клиент Тогда
//		РаботаСДиалогами.ВывестиПредупреждение(ТекстСообщения, ТекстЗаголовка);
//	#Иначе
//		СообщитьОбОшибке(ТекстСообщения, , ТекстЗаголовка);
//	#КонецЕсли
//	
//КонецПроцедуры // СообщитьОбъектЗаблокирован

//// Формирует строку представления документа для сообщений при проведении.
////
//// Параметры
////  Источник - структура шапки или ссылка на проводимый документ.
////
//// Возвращаемое значение
////  Строка с представлением документа
////
//Функция ПредставлениеДокументаПриПроведении(Источник) Экспорт
//	
//	Если ТипЗнч(Источник) = Тип("Структура") Тогда
//		ПредставлениеДокумента = Источник.ПредставлениеДокумента;
//		Если Источник.Свойство("ВидОперации") Тогда
//			ПредставлениеДокумента = ПредставлениеДокумента + " (" + Источник.ВидОперации + ")";
//		КонецЕсли; 
//	Иначе
//		МетаданныеДокумента = Источник.Метаданные();
//		ВидОперацииСтр = "";
//		Если МетаданныеДокумента.Реквизиты.Найти("ВидОперации") <> Неопределено Тогда
//			ВидОперацииСтр = " (" + Источник.ВидОперации + ")";
//		КонецЕсли;
//		ПредставлениеДокумента = СокрЛП(Источник) + ВидОперацииСтр;
//	КонецЕсли; 
//	
//	ПредставлениеДокумента = "Проведение документа: " + ПредставлениеДокумента;
//	
//	Возврат ПредставлениеДокумента;
//	
//КонецФункции // ПредставлениеДокументаПриПроведении


//// Предназначена для получения запросом представлений объектов
//// Поддерживает два синтаксиса
//// 1.
//// Параметры:
////	СсылкиОбъектовПарам - массив ссылок
//// Возвращаемое значение
////	Соответствие в котором ключ - одна из переданных ссылок, 
////  а значение - представление этой ссылки
//// 2. 
//// Параметры:
////	СсылкиОбъектовПарам - ссылка
//// Возвращаемое значение
////	Строка предсатвления ссылки
////
//// Пример использования:
//// 	МассивСсылок = Новый Массив;
//// 	МассивСсылок.Добавить(НоваяОрганизация);
//// 	МассивСсылок.Добавить(СтараяОрганизация);
//// 	Представления = ПолучитьПредставленияОбъектов(МассивСсылок);
////	НоваяОрганизацияСтрокой = Представления[НоваяОрганизация];
////	СтараяОрганизацияСтрокой = Представления[СтараяОрганизация];
////
//Функция ПолучитьПредставленияОбъектов(СсылкиОбъектовПарам) Экспорт
//	// соответствие возвращается если передан массив ссылок
//	ПереданМассив = Истина;
//	
//	// Если передано одиночное значение - "превратим" его в массив
//	Если ТипЗнч(СсылкиОбъектовПарам) <> Тип("Массив") Тогда
//		Ссылка = СсылкиОбъектовПарам;
//		СсылкиОбъектов = Новый Массив;
//		СсылкиОбъектов.Добавить(Ссылка);
//		ПереданМассив = Ложь;
//		
//	Иначе
//		СсылкиОбъектов = СсылкиОбъектовПарам;
//		
//	КонецЕсли;
//	
//	// Обработаем массив СсылкиОбъектов и сформируем 
//	// соответствие ссылок по их типам
//	СсылкиПоТипам = Новый Соответствие;
//	Для Каждого СсылкаНаОбъект Из СсылкиОбъектов Цикл
//		ПолноеИмя = СсылкаНаОбъект.Метаданные().ПолноеИмя();
//		Если СсылкиПоТипам[ПолноеИмя] = НеОпределено Тогда
//			СсылкиПоТипам[ПолноеИмя] = Новый Массив;
//		КонецЕсли;
//		СсылкиПоТипам[ПолноеИмя].Добавить(СсылкаНаОбъект);
//	КонецЦикла;
//	
//	// формирование запроса
//	ТекстЗапроса = "";
//	Запрос = Новый Запрос;
//	ПервоеЗначение = Истина;
//	Для Каждого ЭлементСоответствия Из СсылкиПоТипам Цикл
//		ИмяПараметра = "Массив" + СтрЗаменить(ЭлементСоответствия.Ключ, ".", "_");
//		Если Не ПервоеЗначение Тогда
//			ТекстЗапроса = ТекстЗапроса + "
//			|ОБЪЕДИНИТЬ ВСЕ";
//			
//		КонецЕсли;
//		ТекстЗапроса = ТекстЗапроса + "
//		|ВЫБРАТЬ 
//		|	Ссылка КАК Ссылка,
//		|	ПРЕДСТАВЛЕНИЕ(Ссылка) КАК Представление
//		|ИЗ " + ЭлементСоответствия.Ключ + "
//		|ГДЕ Ссылка В (&" + ИмяПараметра + ")";
//		Запрос.УстановитьПараметр(ИмяПараметра, ЭлементСоответствия.Значение);
//		ПервоеЗначение = Ложь;
//	КонецЦикла;
//	// обработка запроса
//	Запрос.Текст = ТекстЗапроса;
//	Выборка = Запрос.Выполнить().Выбрать();
//	Если ПереданМассив Тогда
//		ВозвращаемоеСоответствие = Новый Соответствие;
//		Пока Выборка.Следующий() Цикл
//			ВозвращаемоеСоответствие[Выборка.Ссылка] = Выборка.Представление;
//		КонецЦикла;
//		
//		// дополним пустыми представлениями неполученных запросом ссылок
//		Для Каждого СсылкаНаОбъект Из СсылкиОбъектов Цикл
//			Если ВозвращаемоеСоответствие[СсылкаНаОбъект] = НеОпределено Тогда
//				ВозвращаемоеСоответствие[СсылкаНаОбъект] = "";
//			КонецЕсли;
//			
//		КонецЦикла;
//		Возврат ВозвращаемоеСоответствие;
//		
//	Иначе
//		Если Выборка.Следующий() Тогда
//			Возврат Выборка.Представление;
//		Иначе
//			// если ссылки не нашлось - пустое представление
//			Возврат "";
//		КонецЕсли;
//		
//	КонецЕсли; 
//	
//КонецФункции

//// Проверяет принадлежность документа к видам учета
////
//// Параметры: 
////  СтруктураШапкиДокумента - структура, содержащая реквизиты шапки документа
////  Отказ                   - флаг отказа в проведении.
////  Заголовок               - строка, заголовок сообщения об ошибке проведения.
////  МожетБытьТолькоНалоговый- строка, заголовок сообщения об ошибке проведения.
////
//Процедура ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь) Экспорт
//	
//	Перем Упр, Бух, Нал;
//	
//	ЕстьУпр = СтруктураШапкиДокумента.Свойство("ОтражатьВУправленческомУчете", Упр);
//	ЕстьБух = СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете", Бух);
//	ЕстьНал = СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете", Нал);
//	
//	Если ЕстьУпр ИЛИ ЕстьБух ИЛИ ЕстьНал Тогда
//		Если НЕ МожетБытьТолькоНалоговый Тогда
//			Если Упр <> Истина И Бух <> Истина  Тогда
//				СообщитьОбОшибке("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"" и (или)  ""Бухгалтерский"".", Отказ, Заголовок);
//			ИначеЕсли Бух <> Истина И Нал = Истина Тогда
//				СообщитьОбОшибке("Документ не может проводиться  по налоговому учету, если он не проводится по бухгалтерскому учету." , Отказ, Заголовок);
//			КонецЕсли;
//		Иначе
//			Если Упр <> Истина И Бух <> Истина И Нал <> Истина Тогда
//				СообщитьОбОшибке("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"", ""Бухгалтерский"", ""Налоговый"".", Отказ, Заголовок);
//			КонецЕсли;
//		КонецЕсли;
//	КонецЕсли;

//КонецПроцедуры

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ

//// Функция формирует список элементов перечисления
////
//// Параметры
////  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
////
//// Возвращаемое значение:
////   СписокЗначений - список элементов перечисления
////
//Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт

//	СписокЭлементовПеречисления = Новый СписокЗначений;
//	
//	Попытка
//		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
//	Исключение
//		Возврат СписокЭлементовПеречисления;
//	КонецПопытки;
//	
//	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
//		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
//	КонецЦикла;
//	
//	Возврат СписокЭлементовПеречисления;

//КонецФункции // ПолучитьСписокЭлементовПеречисления()

//// Процедура проверяет переданный параметр, если он не соответствует значению, 
//// то присваивает ему указанное значение.
////
//// Параметры:
////  Параметр - параметр, значение которого проверяется и заполняется.
////  Значение - значение для заполнения пустого параметра.
////
//Процедура УстановитьНовоеЗначение(Параметр, Значение) Экспорт

//	Если Параметр <> Значение Тогда
//		Параметр = Значение;
//	КонецЕсли;

//КонецПроцедуры

//// Предназначена для получения имени элемента перечисления по значению.
////
//// Параметры:
////	Элемент перечисления.
////
//// Возвращаемое значение:
////	Строка - имя элемента перечисления в метаданных.
////
//Функция ПолучитьИмяЭлементаПеречисленияПоЗначению(ЗначениеПеречисления) Экспорт
//	
//	ИмяЭлемента = Строка(ЗначениеПеречисления);
//	Для каждого ЭлементПеречисления Из Метаданные.Перечисления[ЗначениеПеречисления.Метаданные().Имя].ЗначенияПеречисления Цикл
//		Если ЭлементПеречисления.Синоним = Строка(ЗначениеПеречисления) Тогда
//			ИмяЭлемента = ЭлементПеречисления.Имя;
//			Прервать;
//		КонецЕсли; 
//	КонецЦикла;
//	
//	Возврат ИмяЭлемента;
//	
//КонецФункции // ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()

//// сравнение значений перечислений на больше/меньше
//// применяется для перечислений, для которых последовательность 
//// значений имеет определяющее значение
////
//// Параметры:
////  Значение1, Значение2 - сравниваемые значения перечислений
////
//// Возвращаемое значение: число
////   1 - если Значение1 > Значение2
////  -1 - если Значение1 < Значение2
////   0 - если Значение1 = Значение2
////
//Функция СравнениеПеречислений(Значение1, Значение2) Экспорт
//    ИмяПеречисления = Метаданные.НайтиПоТипу(ТипЗнч(Значение1)).Имя;
//    Менеджер = Перечисления[ИмяПеречисления];
//    Если Менеджер.Индекс(Значение1) > Менеджер.Индекс(Значение2) Тогда
//        Возврат 1;
//    ИначеЕсли Менеджер.Индекс(Значение1) < Менеджер.Индекс(Значение2) Тогда
//        Возврат -1;
//    Иначе
//        Возврат 0;
//    КонецЕсли;
//    
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

//// Функция возвращает имя табличной части, к которой принадлежит переданная строка
////
//// Параметры
////  СтрокаТабличнойЧасти - ссылка на строку табличной части
////
//// Возвращаемое значение:
////   Строка - имя табличной части, как оно задано в конфигураторе
////
//Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

//	ИмяТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;
//	Возврат ИмяТабличнойЧасти;

//КонецФункции // ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

//// Функция возвращает массив, который содержит имена регистров 
//// движения которых не надо удалять при очистке движений перед перепроведением
////	Остатки, движения по таким регистрам не используются 
//// 		ни в процедурах контроля остатков (товаров, задолженностей)
//// 		ни в логике формирования других движений (например, партии, авансы)
////
//Функция ПолучитьРегистрыДляОптимизацииПерезаписиДвижений(ТекущийРежимПроведенияДокумента)
//	
//	МассивРегистров = Новый Массив;
//	
//	//В список регистров могут быть включены только те, движения которых записываются через коллекцию движений (Движения.<...>), 
//	//а не через набор записей 
//	
//	// Регистры вида "Обороты", которые 
//	//- не используются для формирования движений 
//	//- двигаются документами, для которых применяется выборочное удаление движений
//	МассивРегистров.Добавить("ДвиженияДенежныхСредств");
//	МассивРегистров.Добавить("Закупки");
//	МассивРегистров.Добавить("Продажи");

//	// Далее перечислены регистры, которые используются для контроля остатков, формирования движений 
//	// только при оперативном проведении. Их 
//	// - следует очищать если документ проводится оперативно
//	// - можно не очищать, если документ проводится неоперативно
//	Если ТекущийРежимПроведенияДокумента = РежимПроведенияДокумента.Неоперативный Тогда
//		МассивРегистров.Добавить("ВзаиморасчетыСКонтрагентами");
//		МассивРегистров.Добавить("ДенежныеСредства");
//		МассивРегистров.Добавить("ЗаказыПоставщикам");
//		МассивРегистров.Добавить("РазмещениеЗаказовПокупателей");
//		МассивРегистров.Добавить("РасчетыСКонтрагентами");
//		МассивРегистров.Добавить("ТоварыВНТТ");
//		МассивРегистров.Добавить("ТоварыВРезервеНаСкладах");
//		МассивРегистров.Добавить("ТоварыВРознице");
//		МассивРегистров.Добавить("ТоварыКПередачеОрганизаций");
//		МассивРегистров.Добавить("ТоварыКПередачеСоСкладов");
//		МассивРегистров.Добавить("ТоварыКПеремещениюВНТТ");
//		МассивРегистров.Добавить("ТоварыКПолучениюНаСклады");
//		МассивРегистров.Добавить("ТоварыНаСкладах");
//		МассивРегистров.Добавить("ТоварыОрганизаций");
//		МассивРегистров.Добавить("ТоварыПереданные");
//		МассивРегистров.Добавить("ТоварыПолученные");
//	КонецЕсли;
//	
//	Возврат МассивРегистров;
//	
//КонецФункции // ПолучитьРегистрыДляОптимизацииПерезаписиДвижений

//// Процедура удаления движений документа при перепроведении (отмене проведения)
////
//// Параметры:
////	ДокументОбъект 				- документ, движения которого удаляются
////	Отказ 						- булево, признак отказа
////	ВыборочноОчищатьРегистры 	- булево, признак выборочной очистки наборов записей 
////								Если Истина - часть наборов записей не будут очищены, будут очищены только коллекции движений
////	РежимПроведенияДокумента 	- режим проведения (оперативный / неоперативный), 
////								нужен для составления списка регистров, которые не надо очищать
////	Для документа ПринятиеКУчетуОС предусмотрена отдельная процедура УдалитьДвиженияПринятиеКУчетуОС
//Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ, ВыборочноОчищатьРегистры = Ложь, РежимПроведенияДокумента = Неопределено) Экспорт
//	
//	// Удалим те движения, которые уже записаны
//	УдалитьЗаписанныеДвиженияДокумента(ДокументОбъект, Отказ, ВыборочноОчищатьРегистры, РежимПроведенияДокумента);
//	
//	// Очистим непустые коллекции движений документа
//	ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект);
//	
//	// Удаление записей регистрации из всех последовательностей - после удаления движений по регистрам
//	УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, Истина);
//	
//КонецПроцедуры

//// Процедура очистки записанных движений документа
////
//// Параметры:
////	ДокументОбъект 				- документ, движения которого удаляются
////	Отказ 						- булево, признак отказа
////	ВыборочноОчищатьРегистры 	- булево, признак выборочной очистки наборов записей 
////								Если Истина - часть наборов записей не будут очищены, будут очищены только коллекции движений
////	РежимПроведенияДокумента 	- режим проведения (оперативный / неоперативный), 
////								нужен для составления списка регистров, которые не надо очищать
//Процедура УдалитьЗаписанныеДвиженияДокумента(ДокументОбъект, Отказ, ВыборочноОчищатьРегистры, РежимПроведенияДокумента)
//	
//	// Получим перечень регистров, движения по которым нужно очистить
//	МассивРегистров = ПроведениеДокументов.МассивРегистровНужноОчистить(ДокументОбъект);
//	
//	Если МассивРегистров.Количество() = 0 Тогда
//		Возврат;
//	КонецЕсли;
//	
//	// Если очищать регистры надо выборочно, то подготовим список таких регистров, 
//	//	которые можно не очищать при перепроведении
//	Если ВыборочноОчищатьРегистры Тогда
//		РегистрыДляОптимизацииПерезаписиДвижений = ПолучитьРегистрыДляОптимизацииПерезаписиДвижений(РежимПроведенияДокумента);
//	КонецЕсли;
//	
//	// Переменные логики отложенного проведения
//	ДокументИспользуетсяВОтложенномПроведении = Ложь;
//	ВыполняетсяДопроведение                   = Ложь;
//	ПроведениеПоВсемВидамУчета                = Ложь;
//	
//	СтруктураПараметровПроведения = ОтложенноеПроведениеДокументов.ПолучитьПараметрыПроведенияДокумента(ДокументОбъект);
//	ДокументИспользуетсяВОтложенномПроведении = СтруктураПараметровПроведения.ДокументИспользуетсяВОтложенномПроведении;
//	
//	Если ДокументИспользуетсяВОтложенномПроведении Тогда
//		ВыполняетсяДопроведение = СтруктураПараметровПроведения.ВыполняетсяДопроведение;
//		ПроведениеПоВсемВидамУчета = СтруктураПараметровПроведения.ПроведениеПоВсемВидамУчета;
//		РегистрыОтложенногоПроведения = ОтложенноеПроведениеДокументов.ПолучитьРегистрыОтложенногоПроведения();
//	КонецЕсли;
//	
//	//Обойдем список регистров, по которым существуют движения, и выполним очистку необходимых регистров
//	Для Каждого ПолноеИмяРегистра ИЗ МассивРегистров Цикл
//		
//		// Имя регистра передается как значение, 
//		// полученное с помощью функции ПолноеИмя() метаданных регистра
//		ПозицияТочки = Найти(ПолноеИмяРегистра, ".");
//		ТипРегистра = Лев(ПолноеИмяРегистра, ПозицияТочки - 1);
//		ИмяРегистра = СокрП(Сред(ПолноеИмяРегистра, ПозицияТочки + 1));
//		
//		// Используется для оптимизации перезаписи движений платформой
//		//	Если значение Ложь, набор записей не будет очищен
//		// По умолчанию все движения надо удалять
//		УдалятьДвижения = Истина;
//		
//		Если ВыборочноОчищатьРегистры И РегистрыДляОптимизацииПерезаписиДвижений.Найти(ИмяРегистра) <> Неопределено Тогда
//			УдалятьДвижения = Ложь;
//		КонецЕсли;
//		
//		Если ДокументИспользуетсяВОтложенномПроведении Тогда
//			Если ВыполняетсяДопроведение Тогда
//				//	Если выполняется допроведение, то удаляются только движения по регистрам, 
//				//	которые формируются при отложенном проведении
//				Если РегистрыОтложенногоПроведения.Найти(СокрЛП(ПолноеИмяРегистра)) = Неопределено Тогда
//					Продолжить;
//				КонецЕсли;
//			Иначе
//				// Документ проводится в режиме отложенного проведения
//				
//				// Если для документа выключен режим проведения "по всем видам учета", 
//				// то всегда удаляются движения по регистрам, которые формируются при допроведении
//				//	(независимо от того, входят ли они в список РегистрыДляОптимизацииПерезаписиДвижений)
//				Если НЕ УдалятьДвижения
//					И НЕ ПроведениеПоВсемВидамУчета 
//					И РегистрыОтложенногоПроведения.Найти(СокрЛП(ПолноеИмяРегистра)) <> Неопределено Тогда
//					
//					УдалятьДвижения = Истина;
//				КонецЕсли;
//			КонецЕсли; 
//		КонецЕсли; 
//		
//		Если УдалятьДвижения Тогда
//			// Удаление движений происходит без контроля доступа - передаем пустую таблицу движений
//			ПолныеПрава.ЗаписатьНаборЗаписейНаСервере(ИмяРегистра, ДокументОбъект.Ссылка,, ТипРегистра);
//		Иначе
//			//Установим признак модифицированности набора записей, чтобы записались все коллекции движений, по которым
//			//были записи на момент проведения
//			ДокументОбъект.Движения[ИмяРегистра].Очистить();
//		КонецЕсли;
//	КонецЦикла;	
//	
//КонецПроцедуры

//// Процедура удаления существующих движений документа ПринятиеКУчетуОС при перепроведении
////	Отличается от универсальной процедуры УдалитьДвиженияРегистратора:
////	- содержит специфичную для данного документа логику раздельного удаления движений по видам учета
////	- не учитывает отложенное проведение (т.к. документ в отложенном проведении не участвует)
////
//// Параметры
////	ДокументОбъект 			- документ ПринятиеКУчетуОС, движения которого необходимо удалить
////	СтруктураВидовУчета 	- Структура, содержащая перечень видов учета
////								Для видов учета, по которым необходимо удалить движения, установлено значение Истина
////								Движения документа удаляются выборочно - по выбранным видам учета
////								Это необходимо при проведении по партиям (раздельное проведение документа по УУ, БУ + НУ)
//Процедура УдалитьЗаписанныеДвиженияДокументаПринятиеКУчетуОС(ДокументОбъект, СтруктураВидовУчета)
//	
//	// Получим перечень регистров, движения по которым нужно очистить
//	МассивРегистров = ПроведениеДокументов.МассивРегистровНужноОчистить(ДокументОбъект);
//	
//	Если МассивРегистров.Количество() = 0 Тогда
//		Возврат;
//	КонецЕсли;
//	
//	//Признак - передана ли структура видов учета, в соответствии с которой надо выборочно удалять движения
//	ПроверитьПринадлежностьРегистраКВидамУчета = (СтруктураВидовУчета <> Неопределено И ТипЗНЧ(СтруктураВидовУчета) = Тип("Структура"));
//	Если ПроверитьПринадлежностьРегистраКВидамУчета Тогда
//		// Получим список регистров с информацией: к какому виду учета они принадлежат
//		//	Далее используется при вызове функции РегистрПринадлежитВидамУчета
//		РегистрыПоВидамУчета = ПолучитьРегистрыПоВидамУчета();
//	КонецЕсли;
//	
//	//Обойдем список регистров, по которым существуют движения, и выполним очистку необходимых регистров
//	Для Каждого ПолноеИмяРегистра ИЗ МассивРегистров Цикл
//		
//		// Имя регистра передается как значение, полученное с помощью функции ПолноеИмя() метаданных регистра
//		ПозицияТочки = Найти(ПолноеИмяРегистра, ".");
//		ТипРегистра = Лев(ПолноеИмяРегистра, ПозицияТочки - 1);
//		ИмяРегистра = СокрП(Сред(ПолноеИмяРегистра, ПозицияТочки + 1));
//		
//		// Очищать будем только движения по регистрам, относящимся к тем видам учета, по которым перепроводится документ
//		//	Используется при проведении по партиям
//		Если ПроверитьПринадлежностьРегистраКВидамУчета И
//			НЕ РегистрПринадлежитВидамУчета(ИмяРегистра, СтруктураВидовУчета, РегистрыПоВидамУчета) Тогда
//			Продолжить;
//		КонецЕсли;
//		// Выполним удаление движений (без контроля прав доступа)
//		ПолныеПрава.ЗаписатьНаборЗаписейНаСервере(ИмяРегистра, ДокументОбъект.Ссылка,, ТипРегистра);
//	КонецЦикла;	

//КонецПроцедуры //УдалитьЗаписанныеДвиженияДокументаПринятиеКУчетуОС

//// Процедура удаления движений документа ПринятиеКУчетуОС при перепроведении
////	Отличается от универсальной процедуры УдалитьДвиженияРегистратора:
////	- содержит специфичную для данного документа логику раздельного удаления движений по видам учета
////	- не учитывает отложенное проведение (т.к. документ в отложенном проведении не участвует)
////
//// Параметры
////	ДокументОбъект 			- документ ПринятиеКУчетуОС, движения которого необходимо удалить
////	Отказ 					- булево, признак отказа
////	СтруктураВидовУчета 	- Структура, содержащая перечень видов учета
////								Для видов учета, по которым необходимо удалить движения, установлено значение Истина
////								Движения документа удаляются выборочно - по выбранным видам учета
////								Это необходимо при проведении по партиям (раздельное проведение документа по УУ, БУ + НУ)
//Процедура УдалитьДвиженияПринятиеКУчетуОС(ДокументОбъект, Отказ, СтруктураВидовУчета) Экспорт
//	
//	// Удалим те движения, которые уже записаны
//	УдалитьЗаписанныеДвиженияДокументаПринятиеКУчетуОС(ДокументОбъект, СтруктураВидовУчета);

//	// Очистим непустые коллекции движений документа
//	ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект);
//	
//	// Удалим записи регистрации из всех последовательностей  - после удаления движений по регистрам
//	УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, Истина);
//	
//КонецПроцедуры //УдалитьДвиженияПринятиеКУчетуОС

//// Процедура очищает коллекцию движений документа
////
//Процедура ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект)
//		
//	Если ДокументОбъект.Движения.Количество() = 0 Тогда
//		Возврат;
//	КонецЕсли;
//	
//	Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
//		// Очистим не пустые коллекции движений
//		Если Движение.Количество() > 0 Тогда
//			Движение.Очистить();
//		КонецЕсли;
//	КонецЦикла;
//	
//КонецПроцедуры

//// Добавляет в таблицу значений строки из другой таблицы значений и 
//// в них значения колонок с совпадающими наименованиями.
////
//// Параметры:
////  ТаблицаИсточник - таблица значений или массив строк таблицы значений, откуда берутся значения.
////  ТаблицаПриемник - таблица значений, куда добавляются строки.
////  ЗаполнятьНомераСтрокПоИсточнику - Булево - определяет необходимость сохранения информации
////		об индексах строк таблицы-источника в таблице-приемнике.
////		Используется в тех случаях, когда необходимо выполнить сопоставление строк приемника и источника.
////
//Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник, ЗаполнятьНомераСтрокПоИсточнику = Ложь) Экспорт
//	
//	// Заполним значения в совпадающих колонках.
//	Для Каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл
//		
//		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
//		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);
//		
//		Если ЗаполнятьНомераСтрокПоИсточнику Тогда
//			СтрокаТаблицыПриемника.НомерСтроки = СтрокаТаблицыИсточника.Владелец().Индекс(СтрокаТаблицыИсточника);
//		КонецЕсли;
//		
//	КонецЦикла;
//	
//КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

//// Проверяет наличие требуемых данных в источнике и Формирует таблицу значений
////
//// Параметры
////  Источник  – ТаблицаЗначений или ТабличнаяЧасть или КоллекцияСтрокДереваЗначений с исходными данными
////
////  Реквизиты – структура – Структура реквизитов. 
////							Ключ 		- Наименование колонки в источнике
////							Значение    - Наименование колонки в получаемой ТЗ
////							Если значение опущено - приравнивается ключу.
////	ПолучитьНомерСтрокиДокумента - булево
////	                        Используется только при выгрузке из табличной части документа.
////							В формируемой таблице создает новую колонку "НомерСтрокиДокумента"
////								и заполняет её реальными номерами строк
////
////  КоллекцияКолонокДереваЗначений - только для коллекции строк дерева значений.
//// Возвращаемое значение:
////  Таблица значений или Неопределено (если не хватает реквизитов)
////
//Функция СформироватьТаблицуЗначений(Источник,Реквизиты=Неопределено,ПолучитьНомерСтрокиДокумента = ложь,ФормироватьОтстутствующиеКолонки=Ложь,КоллекцияКолонокДереваЗначений=Неопределено) экспорт

//	ЭтоТаблицаЗначений=(ТипЗнч(Источник)= тип("ТаблицаЗначений"));
//	ЭтоСтрокиДереваЗначений=(ТипЗнч(Источник)= тип("КоллекцияСтрокДереваЗначений"));
//	Если ЭтоСтрокиДереваЗначений и КоллекцияКолонокДереваЗначений = Неопределено тогда
//		Возврат Неопределено;
//	Конецесли;
//	
//	Если НЕ ЗначениеЗаполнено(Реквизиты) тогда
//		Если ЭтоТаблицаЗначений тогда
//			НоваяТЗ = Источник.Скопировать();
//	  		Возврат НоваяТЗ;
//		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
//			Реквизиты = Новый Структура();
//			Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
//				Реквизиты.Вставить(Колонка.Имя);
//			КонецЦикла;
//		Иначе
//			НоваяТЗ = Источник.Выгрузить();
//	  		Возврат НоваяТЗ;
//		КонецЕслИ;
//	Конецесли;
//	
//	Если не ЭтоТаблицаЗначений  и не ЭтоСтрокиДереваЗначений тогда
//		РеквизитыТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(Источник)).Реквизиты;
//	Конецесли;
//	
//	НоваяТЗ= Новый ТаблицаЗначений();
//	
//	Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
// 		НоваяТЗ.Колонки.Добавить("НомерСтрокиДокумента",Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5,0)));
//	КонецЕсли;

//	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл
//		Строка = НоваяТЗ.Добавить();
//		Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
//			Строка.НомерСтрокиДокумента = НоваяТЗ.Количество();
//		КонецЕсли;
//	КонецЦикла;
//	
//	Для каждого ТекРеквизит из Реквизиты Цикл
//		ИскомыйРеквизит = ТекРеквизит.Ключ;
//		НовыйРеквизит 	= ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);
//		Если ЭтоТаблицаЗначений тогда
//			ИсточникКолонка = Источник.Колонки.Найти(ИскомыйРеквизит);
//		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
//			ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);
//		Иначе
//			ИсточникКолонка = РеквизитыТабличнойЧасти.Найти(ИскомыйРеквизит);
//		Конецесли;
//		Если ИсточникКолонка= неопределено тогда
//			//недостаточно реквизитов
//			Если ФормироватьОтстутствующиеКолонки тогда
//				НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
//			Иначе
//				Возврат Неопределено;
//			КонецЕсли;	
//		Иначе
//			Если ЭтоТаблицаЗначений ИЛИ ЭтоСтрокиДереваЗначений тогда
//				НоваяТЗ.Колонки.Добавить(НовыйРеквизит, ИсточникКолонка.ТипЗначения);
//			Иначе
//				НоваяТЗ.Колонки.Добавить(НовыйРеквизит, ИсточникКолонка.Тип);
//			КонецЕсли;
//			НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);
//		Конецесли;
//	КонецЦикла;
//	
//    Возврат НоваяТЗ;
//КонецФункции // СформироватьТаблицуОплаты()

//// Формирует структуру, содержащую значения реквизитов шапки документа.
////
//// Параметры: 
////  ДокументОбъект - объект документа для формирования структуры шапки. 
////
//// Возвращаемое значение:
////  Сформированная структура.
////
//Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
//	
//	СтруктураШапкиДокумента = Новый Структура;
//	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
//	СтруктураШапкиДокумента.Вставить("Дата",   ДокументОбъект.Дата);
//	
//	ТипДокумента = ТипЗнч(ДокументОбъект);
//	
//	МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипДокумента);
//	СтруктураШапкиДокумента.Вставить("ВидДокумента",  				МетаданныеДокумента.Имя);
//	СтруктураШапкиДокумента.Вставить("ПредставлениеДокумента", 		СокрЛП(ДокументОбъект));
//	СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());
//	
//	Для Каждого Реквизит Из МетаданныеДокумента.Реквизиты Цикл
//		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
//	КонецЦикла;
//	
//	// Вставим свойства в структуру и далее при необходимости установим некоторые значения в Истину.
//	СтруктураШапкиДокумента.Вставить("ОрганизацияПрименяетУСН", 		 Ложь);
//	СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСНДоходы", Ложь);
//	СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСН", 		 Ложь);
//	СтруктураШапкиДокумента.Вставить("ПоддержкаПБУ18", 					 Ложь);

//	Если СтруктураШапкиДокумента.Свойство("Организация")
//	 И ЗначениеЗаполнено(СтруктураШапкиДокумента.Организация)
//	 И СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете") 
//	 И СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете Тогда
//			
//		УчетнаяПолитика = ПолучитьПараметрыУчетнойПолитикиРегл(СтруктураШапкиДокумента.Дата, СтруктураШапкиДокумента.Организация);
//		
//		Если ЗначениеЗаполнено(УчетнаяПолитика) Тогда
//			
//			СтруктураШапкиДокумента.ОрганизацияПрименяетУСН = УчетнаяПолитика.УСН;	
//		
//			Если СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете") 
//			 И СтруктураШапкиДокумента.ОтражатьВНалоговомУчете Тогда
//				
//				Если УчетнаяПолитика.УСН Тогда
//					СтруктураШапкиДокумента.ОтражатьВНалоговомУчете = Ложь;
//					Если УчетнаяПолитика.ОбъектНалогообложенияУСН = Перечисления.ОбъектыНалогообложенияПоУСН.Доходы Тогда 
//						СтруктураШапкиДокумента.ОтражатьВНалоговомУчетеУСНДоходы = Истина;
//					Иначе 
//						СтруктураШапкиДокумента.ОтражатьВНалоговомУчетеУСН = Истина;
//					КонецЕсли;
//				Иначе  
//					СтруктураШапкиДокумента.ПоддержкаПБУ18 = УчетнаяПолитика.ПоддержкаПБУ18; 			
//				КонецЕсли;
//				
//			КонецЕсли;	
//			
//		КонецЕсли;
//		
//	КонецЕсли;	
//	
//	Возврат СтруктураШапкиДокумента;
//	
//КонецФункции

////Формирует структуру, содержащую значения реквизитов шапки документа.
////Проверяет признаки отражения в учете
////При необходимости корректирует признаки отражения в учете в связи с отложенным проведением или допроведением документа
//// Параметры: 
////  ДокументОбъект - объект документа для формирования структуры шапки, 
////	Отказ - признак отказа от проведения документа
////	Заголовок - строка, заголовок для формирования сообщений об ошибках
////	МожетБытьТолькоНалоговый - булево, признак того что флаг отражения в НУ может быть установлен независимо от флага отражения в БУ
//// Возвращаемое значение:
////  Сформированная структура.
////
//Функция СформироватьСтруктуруШапкиДокументаИПроверитьОтражениеВУчете(ДокументОбъект, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь) Экспорт
//	СтруктураШапкиДокумента = СформироватьСтруктуруШапкиДокумента(ДокументОбъект);
//	
//	ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок);
//	Если Отказ Тогда
//		Возврат СтруктураШапкиДокумента;
//	КонецЕсли;
//	
//	//Проверяем - возможно, документ должен проводиться отложенно
//	Если ОтложенноеПроведениеДокументов.ДокументПодерживаетОтложенноеПроведение(ДокументОбъект,СтруктураШапкиДокумента) Тогда
//		ОтложенноеПроведениеДокументов.ПодготовитьКПроведениюПоВидамУчета(ДокументОбъект.ДополнительныеСвойства, СтруктураШапкиДокумента);
//	КонецЕсли;
//	Возврат СтруктураШапкиДокумента;
//КонецФункции


//// Выполняет движение по регистру.
////
//// Параметры:
////  НаборДвижений               - набор движений регистра,
////  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
////  реквизитов составного типа, которые могут содержать пустые ссылки.
////
//Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
//	                                  ПустыеКолонкиСоставногоТипа = Неопределено) Экспорт

//	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
//	Если ТаблицаДвижений.Количество() = 0 Тогда
//		Возврат;
//	КонецЕсли;
//	
//	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
//		ПустыеКолонкиСоставногоТипа = Новый Структура;
//	КонецЕсли;
//	
//	//
//	КолонкиТаблицы = ТаблицаДвижений.Колонки;
//	
//	//
//	МетаРег = НаборДвижений.Метаданные();
//	ИзмеренияСостТипа = Новый Структура;
//	ИзмеренияСостТипаСтр = "";
//	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
//		Если (МетаИзм.Тип.Типы().Количество() > 1)
//		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
//			Если не КолонкиТаблицы.Найти(МетаИзм.Имя)=Неопределено Тогда
//				ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
//				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаИзм.Имя;
//			КонецЕсли; 
//		КонецЕсли;
//	КонецЦикла;
//	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
//		Если (МетаРек.Тип.Типы().Количество() > 1)
//		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
//			Если не КолонкиТаблицы.Найти(МетаРек.Имя)=Неопределено Тогда
//				ИзмеренияСостТипа.Вставить(МетаРек.Имя);
//				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРек.Имя;
//			КонецЕсли; 
//			
//		КонецЕсли;
//	КонецЦикла;
//	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
//		Если (МетаРес.Тип.Типы().Количество() > 1)
//		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
//			Если не КолонкиТаблицы.Найти(МетаРес.Имя)=Неопределено Тогда
//				ИзмеренияСостТипа.Вставить(МетаРес.Имя);
//				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРес.Имя;
//			КонецЕсли; 
//		КонецЕсли;
//	КонецЦикла;
//	
//	Если ИзмеренияСостТипаСтр <> "" Тогда
//		ИзмеренияСостТипаСтр = Сред(ИзмеренияСостТипаСтр, 3);
//	КонецЕсли;
//	
//	ТипЧисло = Тип("Число");
//	ТипСтрока = Тип("Строка");
//	ТипДата = Тип("Дата");
//	
//	ЕстьПериод = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;

//	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
//		Движение = НаборДвижений.Добавить();
//		ЗаполнитьЗначенияСвойств(Движение, СтрокаДвижения, ,ИзмеренияСостТипаСтр);
//		
//		Если ВидДвижения <> Неопределено Тогда
//			Движение.ВидДвижения = ВидДвижения;
//		КонецЕсли;
//		
//		Если ЕстьПериод И НЕ СтрокаДвижения.Период = '00010101000000' Тогда
//			Движение.Период = СтрокаДвижения.Период;
//		ИначеЕсли НаборДвижений.мПериод <> Неопределено Тогда
//			Движение.Период = НаборДвижений.мПериод;
//		КонецЕсли; 
//		Движение.Активность = Истина;
//		
//		Для Каждого КлючИЗначение ИЗ ИзмеренияСостТипа Цикл
//			ЗначениеВКолонке = СтрокаДвижения[КлючИЗначение.Ключ];
//			
//			Если ЗначениеВКолонке = Неопределено Тогда
//				Продолжить;
//			КонецЕсли;
//			
//			ТипЗначенияВКолонке = ТипЗнч(ЗначениеВКолонке);
//			
//			Если ТипЗначенияВКолонке = ТипЧисло Тогда
//				Если ЗначениеВКолонке = 0 Тогда
//					Продолжить;
//				КонецЕсли;
//			ИначеЕсли ТипЗначенияВКолонке = ТипСтрока Тогда
//				Если ЗначениеВКолонке = "" Тогда
//					Продолжить;
//				КонецЕсли;
//			ИначеЕсли ТипЗначенияВКолонке = ТипДата Тогда
//				Если ЗначениеВКолонке = '00010101000000' Тогда
//					Продолжить;
//				КонецЕсли;
//			ИначеЕсли ЗначениеВКолонке.Пустая() Тогда
//				Продолжить;
//			КонецЕсли;
//			
//			Движение[КлючИЗначение.Ключ] = ЗначениеВКолонке;
//			
//		КонецЦикла;
//		
//	КонецЦикла;

//КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

//// Заполняет набор записей регистра СвободныеОстатки по данным базового регистра
////
//// Параметры:
////  НаборСвободныеОстатки	- таблица движений регистра СвободныеОстатки, которую нужно заполнить
////  НаборБазовыйРегистр		- таблица движений регистра (базовый регистр) на основании которого необходимо заполнить регистр СвободныеОстатки
////  ВидРегистраОснования	- перечисление <ВидыРегистровОснованийРегистраСвободныеОстатки>
////
//Процедура ЗаполнитьСвободныеОстаткиПоДаннымБазовогоРегистра(НаборСвободныеОстатки, НаборБазовыйРегистр, ВидРегистраОснования) Экспорт

//	Если НаборБазовыйРегистр.Количество() = 0 Тогда
//		Возврат;
//	КонецЕсли;
//		
//	ДатаНачалаИспользованияРегистраСвободныеОстатки = глЗначениеПеременной("ДатаНачалаИспользованияРегистраСвободныеОстатки");
//	
//	// Сначала проверим период записей, потом выполним заполнение
//	// Считаем, что период всех записей одинаковый
//	Если НаборБазовыйРегистр[0].Период < ДатаНачалаИспользованияРегистраСвободныеОстатки Тогда
//		Возврат;
//	КонецЕсли;
//	
//	ОбратныйВидДвижения = (ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыВРезервеНаСкладах
//							ИЛИ ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыКПередачеСоСкладов);
//			
//	Для каждого ЭлДвижение Из НаборБазовыйРегистр Цикл
//		
//		ЭлЗапись = НаборСвободныеОстатки.Добавить();
//		ЭлЗапись.РегистрОснование = ВидРегистраОснования;
//		ЗаполнитьЗначенияСвойств(ЭлЗапись, ЭлДвижение);
//		
//		Если ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыВРезервеНаСкладах Тогда
//			ЭлЗапись.Качество = Справочники.Качество.Новый;
//		КонецЕсли;
//		
//		Если ОбратныйВидДвижения Тогда
//			Если ЭлЗапись.ВидДвижения = ВидДвиженияНакопления.Приход Тогда
//				ЭлЗапись.ВидДвижения = ВидДвиженияНакопления.Расход;
//			Иначе
//				ЭлЗапись.ВидДвижения = ВидДвиженияНакопления.Приход;
//			КонецЕсли; 
//		КонецЕсли;
//		
//		Если ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыВРезервеНаСкладах Тогда
//			// Резервирование зависит от обособленного учета (ОУ)
//			// если ведется ОУ, то резервирование влияет на количество с учетом серии
//			// если ОУ не ведется, количество с учетом серии не изменяется
//			Если глЗначениеПеременной("ИспользоватьУказаниеСерийНоменклатурыПриРезервировании") Тогда
//				ТипДокументСсылкаЗаказПокупателя = Тип("ДокументСсылка.ЗаказПокупателя");
//				Если ТипЗнч(ЭлДвижение.ДокументРезерва) = ТипДокументСсылкаЗаказПокупателя 
//					И ЭлДвижение.ДокументРезерва.ДоговорКонтрагента.ОбособленныйУчетТоваровПоЗаказамПокупателей Тогда
//					
//					ЭлЗапись.КоличествоСУчетомСерии = ЭлЗапись.Количество;
//				КонецЕсли; 
//			КонецЕсли; 
//		Иначе
//			ЭлЗапись.КоличествоСУчетомСерии = ЭлЗапись.Количество;
//		КонецЕсли; 
//	КонецЦикла; 
//	
//КонецПроцедуры //
// 
//// Выполняет движения по регистру СвободныеОстатки.
////
//// Параметры:
////  НаборДвижений			- таблица движений регистра (базовый регистр) на основании которого необходимо заполнить регистр СвободныеОстатки
////  Регистратор				- документ, регистратор движений
////  Замещение				- булево, замещать записи регистра	
////  ВидРегистраОснования	- перечисление <ВидыРегистровОснованийРегистраСвободныеОстатки>
////
//Процедура ВыполнитьДвиженияПоРегиструСвободныеОстатки(НаборДвижений, Регистратор, Замещение, ВидРегистраОснования, Отказ = Ложь) Экспорт
//	
//	Если НЕ глЗначениеПеременной("ИспользоватьРегистрСвободныеОстатки") Тогда
//		Возврат;
//	КонецЕсли;
//	
//	Если ТипЗнч(Регистратор) = Тип("ДокументСсылка.КорректировкаЗаписейРегистров") Тогда
//		// При изменении базовых регистров документом "Корректировка записей регистров"
//		// не выполняется автоматическое формирование движений по регистру
//		Возврат;
//	КонецЕсли; 
//	
//	НаборСвободныеОстатки = РегистрыНакопления.СвободныеОстатки.СоздатьНаборЗаписей();
//	НаборСвободныеОстатки.Отбор.Регистратор.Установить(Регистратор);
//	
//	ЗаполнитьСвободныеОстаткиПоДаннымБазовогоРегистра(НаборСвободныеОстатки, НаборДвижений, ВидРегистраОснования);
//	
//	Попытка
//		
//		// Набор может не измениться
//		Если НаборСвободныеОстатки.Модифицированность() Тогда
//			НаборСвободныеОстатки.Записать(Ложь);
//		КонецЕсли; 
//	
//	Исключение
//		СообщитьОбОшибке(ОписаниеОшибки(), Отказ); 
//		ВызватьИсключение "Операция не выполнена";
//	КонецПопытки;	
//	
//КонецПроцедуры // ВыполнитьДвиженияПоРегиструСвободныеОстатки
// 
//// Процедура сворачивает движения по регистру накопления
////
//Процедура СвернутьТаблицуДвиженийРегистраНакопления(НаборДвижений, ТабДвижений = Неопределено, УдалятьПустыеДвижения = Ложь) Экспорт
//	
//	Если ТипЗнч(НаборДвижений) = Тип("Строка") Тогда
//		МетаРег = Метаданные.РегистрыНакопления[НаборДвижений];
//		ТаблицаДвижений = ТабДвижений;
//	Иначе
//		МетаРег = НаборДвижений.Метаданные();
//		Если ТабДвижений = Неопределено Тогда
//			ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
//		Иначе
//			ТаблицаДвижений = ТабДвижений;
//		КонецЕсли;
//	КонецЕсли;
//	
//	
//	Если ТаблицаДвижений = Неопределено ИЛИ ТаблицаДвижений.Количество() = 0 Тогда
//		Возврат;
//	КонецЕсли;
//	
//	Измерения = "Период,Регистратор,Активность";
//	Если МетаРег.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
//		Измерения = Измерения + ",ВидДвижения";
//	КонецЕсли;
//	
//	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
//		Измерения = Измерения + "," + МетаИзм.Имя;
//	КонецЦикла;
//	Для Каждого МетаИзм Из МетаРег.Реквизиты Цикл
//		Измерения = Измерения + "," + МетаИзм.Имя;
//	КонецЦикла;
//	
//	Ресурсы = "";
//	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
//		Ресурсы = Ресурсы + МетаРес.Имя + ",";
//	КонецЦикла;
//	
//	ТаблицаДвижений.Свернуть(Измерения, Ресурсы);
//	
//	Если УдалятьПустыеДвижения Тогда
//		
//		СтруктРесурсы   = Новый Структура(Ресурсы);
//		МассивПустСтрок = Новый Массив;
//		СтруктПоиска    = Новый Структура;
//		
//		Для Каждого РесурсКлюч Из СтруктРесурсы Цикл
//			СтруктПоиска.Вставить( РесурсКлюч.Ключ, 0);
//		КонецЦикла;
//		
//		МассивПустСтрок = ТаблицаДвижений.НайтиСтроки(СтруктПоиска);
//		Для К = 0 По МассивПустСтрок.ВГраница() Цикл
//			ТаблицаДвижений.Удалить(МассивПустСтрок[К]);
//		КонецЦикла;
//		
//	КонецЕсли;
//	
//КонецПроцедуры // СвернутьТаблицуДвиженийРегистраНакопления()

//// Получить движение(набор записей) для документа-объекта
////
//// Параметры
////  Объект  – 	ДокументОбъект – Документ. для которого производится поиск движения
////  ТипДвижения  – Регистр<...>Менеджер – менеджер регистра, движение по которому пытаемся сформировать
////             или <Строка> - имя регистра, движение по которому пытаемся сформировать
////                 
//// Возвращаемое значение:
////   Регистр<...>НаборЗаписей   – набор записей для объекта
////   или Неопределено - если такого регистра не существует или документ не является регистратором регистра
////
//Функция ПолучитьДвижение(Объект, ТипДвижения, Сообщать=Ложь) Экспорт
//	
//	Если ТипЗнч(ТипДвижения) = Тип("Строка") Тогда
//		Движение = Объект.Движения.Найти(ТипДвижения);
//		ДвижениеНевозможно = Движение = Неопределено;
//	Иначе
//		ТипТипаДвижения = ТипЗнч(ТипДвижения.СоздатьНаборЗаписей());
//		ДвижениеНевозможно = Истина;
//		Для каждого Движение Из Объект.Движения Цикл
//			Если ТипЗнч(Движение) = ТипТипаДвижения Тогда
//				ДвижениеНевозможно = Ложь;
//				Прервать;
//			КонецЕсли;
//		КонецЦикла;
//		Если ДвижениеНевозможно Тогда
//			Движение = Неопределено;
//		КонецЕсли; 
//	КонецЕсли;
//	
//	Если Сообщать И ДвижениеНевозможно Тогда
//		Если ТипЗнч(ТипДвижения) = Тип("Строка") Тогда
//			ПредставлениеТипаДвижения = ТипДвижения;
//		Иначе
//			ПредставлениеТипаДвижения = Строка(ТипЗнч(ТипДвижения));
//		КонецЕсли;
//		СообщитьОбОшибке("Требуется подключение """ + ТипЗнч(Объект) + """ к формированиям движения по регистру """ + ПредставлениеТипаДвижения + """!");
//	КонецЕсли;
//	
//	Возврат Движение;
//	
//КонецФункции // ПолучитьДвижение()

//// Получить набор записей по регистру по ссылке на документ
////
//// Параметры
////  Ссылка  		– ДокументСсылка		– Ссылка на документ, для которого производится поиск движений по регистру (набора записей)
////  РегистрДвижения – Регистр<...>Менеджер	– менеджер регистра, движение по которому пытаемся обнаружить
////  ПрочитатьЗаписи - Булево 				- Прочитать существующий набор записей для документа (если документ может формировать движения по указанному регистру).
////                 
//// Возвращаемое значение:
////   Регистр<...>НаборЗаписей – Набор записей по регистру с отбором по документу,
////	 Неопределено 				в случае если документ не может формировать движений по регистру.
////
//Функция ПолучитьНаборЗаписейПоСсылке(Ссылка, РегистрДвижения, ПрочитатьЗаписи = Ложь, Сообщать=Ложь) Экспорт
//	Движения = неопределено;
//	Если Ссылка.Метаданные().Движения.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(РегистрДвижения))) тогда
//        Движения = РегистрДвижения.СоздатьНаборЗаписей();
//		Движения.Отбор.Регистратор.Установить(Ссылка);
//		Если ПрочитатьЗаписи тогда
//			Движения.Прочитать();
//		КонецЕсли;
//	ИначеЕсли Сообщать тогда
//			СообщитьОбОшибке("Требуется подключение документа """+Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).Представление()+""" к формированию движений по регистру """+
//			СтрЗаменить(Лев(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":"))," менеджер","")+Сред(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":")+1)+
//			"""!");
//	КонецЕсли;
//	
//	Возврат Движения;
//КонецФункции // ПолучитьНаборЗаписейПоСсылке()

//// Процедура сворачивает переданный набор записей регистра бухгалтерии по измерениям и реквизитам
//// Параметры: НаборЗаписейРегистраБухгалтерии, тип - набор записей регистров бухгалтерии Налоговый или Хозрасчетный
////            СтрокаГруппировка, тип - строка - список колонок таблицы значений по которым будет выполняться группировка
////            СтрокаСуммирование, тип - строка - список колонок таблицы значений которые будут суммироваться
////            ВестиРеглУчетРасчетовСПерсоналомСводно, тип - булево - признак ведения сводного учета расчетов с персоналом
////            МассивСчетовРасчетовСПерсоналом, тип - массив - список счетов учета расчетов с персоналом
//Процедура СвернутьНаборЗаписейРегистраБухгалтерии(НаборЗаписейРегистраБухгалтерии,
//							СтрокаГруппировка, СтрокаСуммирование,
//							ВестиРеглУчетРасчетовСПерсоналомСводно = Ложь, МассивСчетовРасчетовСПерсоналом = Неопределено) Экспорт
//	Перем ТаблицаЗаписейРегистраБухгалтерии;
//	
//	КоличествоЗаписейНабораЗаписей = НаборЗаписейРегистраБухгалтерии.Количество();
//	// Если количество записей равно 0 - не требуется выполнять сворачивание
//	Если КоличествоЗаписейНабораЗаписей = 0 Тогда
//		Возврат;
//	КонецЕсли;
//	
//	ТаблицаЗаписейРегистраБухгалтерии = НаборЗаписейРегистраБухгалтерии.Выгрузить();
//	// Данная колонка в таблице не нужна
//	ТаблицаЗаписейРегистраБухгалтерии.Колонки.Удалить("НомерСтроки");
//	
//	// Признак наличия проводок по счетам учета расчетов с персоналом
//	ЕстьСчетаУчетаРасчетовСПерсоналом = Ложь;
//	// Признак произведенной очистки субконто
//	ЕстьОчищенныеСубконто = Ложь;
//	
//	// Если способ ведения расчетов с персоналом - сводно,
//	// то перед сворачиванием могут потребоваться дополнительные действия по очистке аналитики в проводках
//	Если ВестиРеглУчетРасчетовСПерсоналомСводно Тогда
//		
//		ТаблицаЗаписейРегистраБухгалтерии.Индексы.Добавить("СчетДт");
//		ТаблицаЗаписейРегистраБухгалтерии.Индексы.Добавить("СчетКт");
//		// Определим, есть ли проводки со счетами учета расчетов с персоналом
//		// Для таких проводок потребуется выполнить очистку значений субконто
//		Для Каждого Счет Из МассивСчетовРасчетовСПерсоналом Цикл
//			Если ТаблицаЗаписейРегистраБухгалтерии.Найти(Счет, "СчетДт,СчетКт") <> Неопределено Тогда
//				ЕстьСчетаУчетаРасчетовСПерсоналом = Истина;
//				Прервать;
//			КонецЕсли;
//		КонецЦикла;
//		
//		// Обнаружены проводки, у которых указаны счета расчетов с персоналом
//		Если ЕстьСчетаУчетаРасчетовСПерсоналом Тогда
//			
//			// Создаем массив префиксов имен колонок таблицы записей регистра
//			// С его помощью будем обращатся к именам колонок счетов и субконто Дт и Кт в цикле
//			// чтобы не дублировать код, различающийся только именами колонок таблицы записей регистра
//			ПрефиксыКолонок = Новый Массив;
//			ПрефиксыКолонок.Добавить("Дт");
//			ПрефиксыКолонок.Добавить("Кт");
//			
//			// Готовим соответствие счета расчетов и количества субконто счета
//			СоответствиеКоличествоСубконтоСчета = Новый Соответствие;
//			Для Каждого СчетРасчетов Из МассивСчетовРасчетовСПерсоналом Цикл
//				СоответствиеКоличествоСубконтоСчета.Вставить(СчетРасчетов, СчетРасчетов.ВидыСубконто.Количество());
//			КонецЦикла;
//			
//			// Готовим соответствие видов очищаемых субконто и пустых значений субконто
//			СоответствиеПустыхЗначенийСубконто = Новый Соответствие;
//			ВидСубконто = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.РаботникиОрганизации;
//			СоответствиеПустыхЗначенийСубконто.Вставить(ВидСубконто,
//				Новый Структура("ПустоеЗначениеСубконто", ВидСубконто.ТипЗначения.ПривестиЗначение()));
//			ВидСубконто = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.ВидНачисленийОплатыТрудаПоСтатье255НК;
//			СоответствиеПустыхЗначенийСубконто.Вставить(ВидСубконто,
//				Новый Структура("ПустоеЗначениеСубконто", ВидСубконто.ТипЗначения.ПривестиЗначение()));
//			
//			Для Каждого СтрокаТаблицы Из ТаблицаЗаписейРегистраБухгалтерии Цикл
//				// Проверка счетов дебета и кредита
//				Для Каждого ПрефиксКолонки Из ПрефиксыКолонок Цикл
//					
//					КоличествоСубконто = СоответствиеКоличествоСубконтоСчета[СтрокаТаблицы["Счет" + ПрефиксКолонки]];
//					Если КоличествоСубконто <> Неопределено Тогда
//						
//						// Если в дебете или кредите стоит счет расчетов с персоналом - очистим некоторые аналитики
//						Для НомерСубконто = 1 По КоличествоСубконто Цикл
//							
//							ВидСубконто = СтрокаТаблицы["ВидСубконто" + ПрефиксКолонки + НомерСубконто];
//							СтруктураПустоеСубконто = СоответствиеПустыхЗначенийСубконто[ВидСубконто];
//							Если СтруктураПустоеСубконто <> Неопределено Тогда
//								ТекущееЗначениеСубконто = СтрокаТаблицы["Субконто" + ПрефиксКолонки + НомерСубконто];
//								Если ТекущееЗначениеСубконто <> СтруктураПустоеСубконто.ПустоеЗначениеСубконто Тогда
//									СтрокаТаблицы["Субконто" + ПрефиксКолонки + НомерСубконто] = СтруктураПустоеСубконто.ПустоеЗначениеСубконто;
//									ЕстьОчищенныеСубконто = Истина;
//								КонецЕсли;
//							КонецЕсли;
//							
//						КонецЦикла;
//						
//					КонецЕсли;
//					
//				КонецЦикла;
//			КонецЦикла;
//			
//		КонецЕсли;
//		
//	КонецЕсли;
//	
//	ТаблицаЗаписейРегистраБухгалтерии.Свернуть(СтрокаГруппировка,СтрокаСуммирование);
//	// Если аналитика не очищалась и количество записей осталось без изменений 
//	//	- не требуется загружать свернутую таблицу в набор записей 
//	Если НЕ ЕстьОчищенныеСубконто
//	 И ТаблицаЗаписейРегистраБухгалтерии.Количество() = КоличествоЗаписейНабораЗаписей Тогда
//		Возврат;
//	КонецЕсли;
//	
//	// Поиск и удаление проводок с пустым  количеством и суммой
//	
//	// Готовим структуру поиска - нулевые значения колонок, которые входят в список суммируемых колонок
//	СтруктураПоиска = Новый Структура(СтрокаСуммирование);
//	Для Каждого ЭлементСтруктуры Из СтруктураПоиска Цикл
//		СтруктураПоиска[ЭлементСтруктуры.Ключ] = 0;
//	КонецЦикла;
//	
//	// Удаление строк с пустыми значениями суммируемых колонок
//	МассивСтрокКУдалению = ТаблицаЗаписейРегистраБухгалтерии.НайтиСтроки(СтруктураПоиска);
//	Для Каждого ЭлементМассива Из МассивСтрокКУдалению Цикл
//		 ТаблицаЗаписейРегистраБухгалтерии.Удалить(ЭлементМассива);
//	КонецЦикла;
//	
//	НаборЗаписейРегистраБухгалтерии.Загрузить(ТаблицаЗаписейРегистраБухгалтерии);
//	
//КонецПроцедуры

//// Возвращает рабочую дату
////
//// Возвращаемое значение:
////   Дата - рабочая дата
////
//Функция ПолучитьРабочуюДату() Экспорт

//#Если Клиент Тогда
//	Дата = РабочаяДата;
//#Иначе
//	Дата = ТекущаяДата();
//#КонецЕсли

//	Возврат Дата;

//КонецФункции // ПолучитьРабочуюДату()

//// Функция проверяет наличие в строке только цифр
////
//// Параметры
////  СтрокаПроверки - Строка для проверки только цифр
////
//// Возвращаемое значение:
////   Булево
////
//Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
//	
//	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
//		Возврат Ложь;
//	КонецЕсли;
//	
//	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
//		Возврат Истина;
//	КонецЕсли; 
//	
//	Если НЕ УчитыватьПробелы Тогда
//		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
//	КонецЕсли;
//	
//	Если НЕ УчитыватьЛидирующиеНули Тогда
//		НомерПервойЦифры = 0;
//		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
//			НомерПервойЦифры = НомерПервойЦифры + 1;
//			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
//			Если КодСимвола <> 48 Тогда
//				Прервать;
//			КонецЕсли;
//		КонецЦикла;
//		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
//	КонецЕсли;
//	
//	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
//		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
//		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
//			Возврат Ложь;
//		КонецЕсли; 
//	КонецЦикла; 

//	Возврат Истина;
//	
//КонецФункции

//// Функция возвращает структуру, содержащую виды учета (УУ, БУ, НУ) и принадлежащие им регистры
////
//Функция ПолучитьРегистрыПоВидамУчета()

//	РегистрыПоВидамУчета = Новый Структура;
//	
//	РегистрыПоВидамУчета.Вставить("ОтражатьВУправленческомУчете", "ГрафикиАмортизацииОС,
//				|МестонахождениеОС,
//				|НачислениеАмортизацииОС,
//				|НоменклатураОсновныхСредств,
//				|ПараметрыАмортизацииОС,
//				|ПервоначальныеСведенияОС,
//				|СобытияОС,
//				|СоставОС,
//				|СостоянияОС,
//				|СписанныеТовары,
//				|СпособыОтраженияРасходовПоАмортизацииОС,
//				|БракВПроизводстве,
//				|Затраты,
//				|ЗатратыНаСтроительствоОбъектовОсновныхСредств,
//				|НезавершенноеПроизводство,
//				|ОССписанныеНаЗатраты,
//				|ПартииТоваровНаСкладах,
//				|СтоимостьОС,
//				|СтроительствоОбъектовОсновныхСредств,
//				|ТоварыНаСкладах,
//				|СвободныеОстатки,
//				|ТоварыОрганизаций,
//				|ДопРасходыНаПриобретениеТоваров,
//				|НезавершенноеПроизводство,
//				|ПартииМатериаловВЭксплуатации,
//				|ПартииТоваровПереданные,
//				|ПродажиСебестоимость,
//				|РеализованныеТовары,");
//				
//	РегистрыПоВидамУчета.Вставить("ОтражатьВБухгалтерскомУчете", "ГрафикиАмортизацииОСБухгалтерскийУчет,
//				|МестонахождениеОСБухгалтерскийУчет,
//				|НачислениеАмортизацииОСБухгалтерскийУчет,
//				|ПараметрыАмортизацииОСБухгалтерскийУчет,
//				|ПервоначальныеСведенияОСБухгалтерскийУчет,
//				|МестонахождениеОСБухгалтерскийУчет,
//				|МестонахождениеОСБухгалтерскийУчет,
//				|СобытияОСОрганизаций,
//				|СостоянияОСОрганизаций,
//				|СписанныеТовары,
//				|СпособыОтраженияРасходовПоАмортизацииОСБухгалтерскийУчет,
//				|СчетаБухгалтерскогоУчетаОС,
//				|БракВПроизводствеБухгалтерскийУчет,
//				|ЗатратыБухгалтерскийУчет,
//				|НДСНачисленный,
//				|НДСПартииТоваров,
//				|НДСпоОСиНМА,
//				|НДСПредъявленный,
//				|НезавершенноеПроизводствоБухгалтерскийУчет,
//				|ОССписанныеНаЗатратыОрганизаций,
//				|ПартииТоваровНаСкладахБухгалтерскийУчет,
//				|СтоимостьОСБухгалтерскийУчет,
//				|ТоварыОрганизаций,
//				|Хозрасчетный,
//				|НДСКосвенныеРасходы,
//				|НДСНезавершенноеПроизводство,
//				|НДСПродукция,
//				|ПартииМатериаловВЭксплуатацииБухгалтерскийУчет,
//				|ПартииТоваровПереданныеБухгалтерскийУчет,
//				|УчетЗатратРегл,");
//				
//	РегистрыПоВидамУчета.Вставить("ОтражатьВНалоговомУчете", "НачислениеАмортизацииОСНалоговыйУчет,
//				|НачислениеАмортизацииОССпециальныйКоэффициентНалоговыйУчет,
//				|ПараметрыАмортизацииОСНалоговыйУчет,
//				|ПервоначальныеСведенияОСНалоговыйУчет,
//				|ПервоначальныеСведенияОСНалоговыйУчетУСН,
//				|СписанныеТовары,
//				|СпособыОтраженияРасходовПоАмортизацииОСНалоговыйУчет,
//				|СчетаНалоговогоУчетаОС,
//				|БракВПроизводствеНалоговыйУчет,
//				|ЗатратыНалоговыйУчет,
//				|НезавершенноеПроизводствоНалоговыйУчет,
//				|ОплатыОСДляУСН,
//				|ПартииТоваровНаСкладахНалоговыйУчет,
//				|СтоимостьОСНалоговыйУчет,
//				|Налоговый,
//				|ПартииМатериаловВЭксплуатацииНалоговыйУчет,
//				|ПартииТоваровПереданныеНалоговыйУчет,");				
//				
//	РегистрыПоВидамУчета.Вставить("ОтражатьВМеждународномУчете", "БракВПроизводствеМеждународныйУчет,
//				|НезавершенноеПроизводствоМеждународныйУчет,
//				|ПартииТоваровНаСкладахМеждународныйУчет,
//				|ПартииТоваровПереданныеМеждународныйУчет,");
//	
//				
//	Возврат РегистрыПоВидамУчета;
//	
//КонецФункции // РегистрыПоВидамУчета

//// Функция проверяет принадлежность указанного регистра всем требуемым видам учета
////
//// Параметры:
////  ИмяРегистра				- Строка, содержащая имя проверяемого регистра
////  СтруктураВидовУчета		- Структура, содержащая перечень видов учета со значением Истина, для которых нужно производить проверку
////  РегистрыПоВидамУчета	- структура, содержащая принадлежность регистров к видам учета
////
//// Возвращаемое значение:
////   Булево
////
//Функция РегистрПринадлежитВидамУчета(ИмяРегистра, СтруктураВидовУчета, РегистрыПоВидамУчета = Неопределено)
//	
//	Если РегистрыПоВидамУчета = Неопределено Тогда
//		РегистрыПоВидамУчета = ПолучитьРегистрыПоВидамУчета();
//	КонецЕсли;
//				
//	Для Каждого Элемент ИЗ СтруктураВидовУчета Цикл
//		Если 
//			Элемент.Значение													//Необходимо проверять этот вид учета
//			И РегистрыПоВидамУчета.Свойство(Элемент.Ключ)						//Структура содержит регистры принадлежащие к виду учета
//			И Найти(РегистрыПоВидамУчета[Элемент.Ключ],ИмяРегистра + ",") > 0	//Регистр найден в списке регистров, принадлежащих к виду учета
//			Тогда
//			Возврат Истина
//		КонецЕсли;
//	КонецЦикла;	
//	
//	//Регистр не принадлежит к проверяемым видам учета
//	Возврат Ложь;			
//	
//КонецФункции //РегистрПринадлежитВидамУчета	

//// Процедура заполняет субконто в строке набора записей
//// Параметры 
//// Запись - Строка набора записей регистра бухгалтерии
//// Строка - Структура, содержащая значения субконто
////
//Процедура ЗаполнитьСубконтоВНабореЗаписей(Запись,Строка)
//	
//	Для НомерСчета = 1 по 2 Цикл
//		
//		Если НомерСчета = 1 тогда 
//			СчетДтКТ = "Дт"
//		Иначе
//			СчетДтКТ = "Кт"
//		КонецЕсли;
//		
//		Для НомерСубконто = 1 по 3 цикл
//			
//			ЗначениеСубконто = Строка["Субконто"+СчетДтКТ+НомерСубконто];

//			ВидСубконто = Строка["ВидСубконто"+СчетДтКТ+НомерСубконто];
//			Если ВидСубконто.ТипЗначения <> Неопределено Тогда
//				Запись["Субконто"+СчетДтКТ].Вставить(ВидСубконто, ЗначениеСубконто);
//			КонецЕсли;
//			
//		КонецЦикла;
//		
//	КонецЦикла;

//КонецПроцедуры // ЗаполнитьСубконтоВНабореЗаписей

//// Добавляет записи из таблицы движений в набор записей
//// Параметры 
//// НаборЗаписей - Набор записей регистра накопления или регистра бухгалтерии
//// Таблица - таблица значений содержащая движения соответствующего регистра (таблица движений)
////
//Процедура ДобавитьСтрокиВНаборЗаписей(НаборЗаписей, Таблица) Экспорт
//	
//	НаборМетаданные = НаборЗаписей.Метаданные();
//		
//	ЭтоРегистрБухгалтерии = (Метаданные.РегистрыБухгалтерии.Найти(НаборМетаданные.Имя)<>Неопределено);
//	
//	Регистратор = НаборЗаписей.Отбор.Регистратор.Значение;
//	
//	Период = Неопределено;
//	
//	Для Каждого Строка Из Таблица Цикл
//		
//		Запись = НаборЗаписей.Добавить();
//			
//		ЗаполнитьЗначенияСвойств(Запись,Строка);
//			
//		Запись.Активность = Истина;

//		Если Запись.Период = '00010101' Тогда
//			
//			Если Период = Неопределено Тогда
//				
//				Период = Регистратор.Дата;
//			
//			КонецЕсли;
//			
//			Запись.Период = Период;
//			
//		КонецЕсли;
//			
//		Если ЭтоРегистрБухгалтерии тогда
//			ЗаполнитьСубконтоВНабореЗаписей(Запись,Строка)
//		КонецЕсли;
//		
//	КонецЦикла;

//КонецПроцедуры // ДобавитьСтрокиВНаборЗаписей

//////////////////////////////////////////////////////////////////////////////////
//// МАТЕМАТИКА

//// возвращает "количество полных и неполных рублей"
//// Параметры:
////	Сумма - число
//// Возвращаемое значение:
////  число, равное ближайшему целому "сверху"
//Функция ЦелМаксимальное(Сумма) Экспорт
//	Возврат ?(Цел(Сумма) = Сумма, Сумма, Цел(Сумма) + 1);
//	
//КонецФункции // ЦелМаксимальное()

//Функция ДесятичноеВШестнадцатиричное(Источник) Экспорт
//	
//	ШеснадцатиричныеСимволы = "0123456789ABCDEF";
//	
//	Если Источник < 0 Тогда
//		Возврат "00";
//	КонецЕсли;
//	Если Источник > 255 Тогда
//		Возврат "FF";
//	КонецЕсли;
//	
//	ПервыйСимвол	= Цел(Источник / 16) + 1;
//	ВтройСимвол		= Источник % 16 + 1;
//	
//	Возврат Сред(ШеснадцатиричныеСимволы, ПервыйСимвол, 1) + Сред(ШеснадцатиричныеСимволы, ВтройСимвол, 1);
//	
//КонецФункции


//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УЧЕТНОЙ ПОЛИТИКОЙ

//// Функция возвращает структуру с параметрами учетной политики (Упр) на заданную дату.
////
//// Параметры:
////	Период					- дата на которую необходимо получить учетную политику
////	СообщатьОбОшибке		- булево, если Истина, то вывести сообщение,
////							когда на дату нет учетной политики
//// Возвращаемое значение:
//// <Структура>				- если на дату нет учетной политики, то Неопределено
////
//Функция ПолучитьПараметрыУчетнойПолитикиУпр(Период, СообщатьОбОшибке = Истина) Экспорт

//	Если НЕ ЗначениеЗаполнено(Период) Тогда
//		Возврат Неопределено;	
//	КонецЕсли;
//	
//	УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаУпр");
//	
//	Для каждого СтрокаУчетнойПолитики Из УчетнаяПолитика Цикл
//		// Строки таблицы УчетнаяПолитика упорядочены по убыванию,
//		// поэтому необходимо найти строку с периодом раньше даты, 
//		// на которую необходимо получить УП
//		Если СтрокаУчетнойПолитики.Период <= Период Тогда
//			Результат = Новый Структура;
//			
//			Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
//				Результат.Вставить(Колонка.Имя, СтрокаУчетнойПолитики[Колонка.Имя]);
//			КонецЦикла;
//			
//			Возврат Результат;	
//		КонецЕсли; 
//	КонецЦикла;
//	
//	Если СообщатьОбОшибке Тогда
//		ТекстОшибки = "Не указаны параметры учетной политики (управленческий учет) на " + Формат(Период, "ДЛФ=DD");
//		СообщитьОбОшибке(ТекстОшибки);
//	КонецЕсли; 
//	
//	Возврат Неопределено;	
//	
//КонецФункции // ПолучитьПараметрыУчетнойПолитикиУпр

//// Функция возвращает структуру с параметрами учетной политики (регл учета)
//// на заданную дату по указанной организации.
////
//// Параметры:
////	Период					- дата на которую необходимо получить учетную политику
////	Организация				- Организация по которой необходимо получить учетную политику
////	СообщатьОбОшибке		- булево, если Истина, то вывести сообщение,
////
//// Возвращаемое значение:
//// <Структура>				- если на дату нет учетной политики, то Неопределено
////
//Функция ПолучитьПараметрыУчетнойПолитикиРегл(Период, Организация, СообщатьОбОшибке = Истина) Экспорт

//	Если НЕ ЗначениеЗаполнено(Период) 
//		ИЛИ НЕ ЗначениеЗаполнено(Организация)  Тогда
//		
//		Возврат Неопределено;	
//	КонецЕсли;
//	
//	Запрос = Новый Запрос;
//	ТекстЗапроса = "ВЫБРАТЬ
//	               |	Организации.ОтражатьВРегламентированномУчете КАК ОтражатьВРегламентированномУчете
//	               |ИЗ
//	               |	Справочник.Организации КАК Организации
//	               |ГДЕ
//	               |	Организации.Ссылка = &Ссылка";
//	Запрос.Текст = ТекстЗапроса;
//	Запрос.УстановитьПараметр("Ссылка", Организация);
//	Выборка = Запрос.Выполнить().Выбрать();
//	Если Выборка.Следующий() Тогда
//		Если НЕ Выборка.ОтражатьВРегламентированномУчете Тогда
//			Возврат Неопределено;	
//		КонецЕсли;
//	КонецЕсли;
//	
//	УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаРегл");
//	
//	Для каждого СтрокаУчетнойПолитики Из УчетнаяПолитика Цикл
//		// Строки таблицы УчетнаяПолитика упорядочены по убыванию,
//		// поэтому необходимо найти строку с периодом раньше даты, 
//		// на которую необходимо получить УП
//		Если СтрокаУчетнойПолитики.Организация = Организация
//			И СтрокаУчетнойПолитики.Период <= Период Тогда
//			
//			Результат = Новый Структура;
//			
//			Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
//				Результат.Вставить(Колонка.Имя, СтрокаУчетнойПолитики[Колонка.Имя]);
//			КонецЦикла;
//			
//			// Для сохранения совместимости со старой версией хранения параметра УСН
//			Результат.Вставить("УСН", СтрокаУчетнойПолитики.СистемаНалогообложения = Перечисления.СистемыНалогообложения.Упрощенная);
//			
//			// Начиная с 01.01.2006 "Момент определения налоговой базы НДС" всегда "По отгрузке"
//			Если Период>= '20060101' 
//				И Результат.Свойство("МоментОпределенияНалоговойБазыНДС") 
//				И Результат.МоментОпределенияНалоговойБазыНДС = Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОплате Тогда			
//				
//				Результат.Вставить("МоментОпределенияНалоговойБазыНДС", Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОтгрузке);
//			КонецЕсли; 
//			
//			// Начиная с 01.01.2008 "Налоговый период" всегда "Квартал"
//			Если Период>= '20080101' 
//				И Результат.Свойство("НДСНалоговыйПериод") 
//				И Результат.НДСНалоговыйПериод = Перечисления.Периодичность.Месяц Тогда
//				
//				Результат.Вставить("НДСНалоговыйПериод", Перечисления.Периодичность.Квартал);
//			КонецЕсли; 
//			
//			Возврат Результат;	
//		КонецЕсли; 
//	КонецЦикла;
//	
//	Если СообщатьОбОшибке Тогда
//		ТекстОшибки = "Не указаны параметры учетной политики (бухгалтерский и налоговый учет) на " + Формат(Период, "ДЛФ=DD") + " для организации " + Организация;
//		СообщитьОбОшибке(ТекстОшибки);
//	КонецЕсли; 
//	
//	Возврат Неопределено;	

//КонецФункции // ПолучитьПараметрыУчетнойПолитикиРегл

//// Временная функция. Необходимо использовать функции ПолучитьПараметрыУчетнойПолитикиУпр и ПолучитьПараметрыУчетнойПолитикиРегл
////
//Функция ПолучитьПараметрыУчетнойПолитики(КонДата, УчетнаяПолитикаНеЗадана, Организация = Неопределено, Учет = "упр", СообщатьОбОшибке = Истина) Экспорт
//	
//	Если НРег(Учет) = "упр" Тогда
//		ПараметрыУчетнойПолитки = ПолучитьПараметрыУчетнойПолитикиУпр(КонДата, СообщатьОбОшибке);
//	Иначе
//		ПараметрыУчетнойПолитки = ПолучитьПараметрыУчетнойПолитикиРегл(КонДата, Организация, СообщатьОбОшибке);
//	КонецЕсли;
//	
//	Если НЕ ЗначениеЗаполнено(ПараметрыУчетнойПолитки) Тогда
//		УчетнаяПолитикаНеЗадана = Истина;
//	КонецЕсли; 
//	
//	Возврат ПараметрыУчетнойПолитки;
//	
//КонецФункции // ПолучитьПараметрыУчетнойПолитики

//// Процедура выводить сообщение о необходимости перезапуска программы при изменении учетной политики
//// если в ИБ работают другие пользователи.
////
//Процедура СообщитьОбИзмененииУчетнойПолитики() Экспорт
//	
//	МассивСоединений = ПолучитьСоединенияИнформационнойБазы() ;
//	Для Каждого ТекСоединение Из МассивСоединений Цикл
//		Если (ТекСоединение.ИмяПриложения = "1CV8") 
//		   И (НЕ ТекСоединение.НомерСоединения = НомерСоединенияИнформационнойБазы())
//		   И (НЕ ТекСоединение.Пользователь = неопределено) Тогда
//			  
//				Сообщить("Внимание! Вы изменили настройки учетной политики.
//						 |В настоящий момент в базе работают пользователи. 
//						 |Для того чтобы новые настройки начали действовать у других пользователей
//						 |им необходимо перезапустить программу. 
//						 |Для Вас новые настройки уже вступили в силу, перезапускать программу не требуется.", СтатусСообщения.Важное);
//						 
//				Возврат;
//							
//		КонецЕсли;
//	КонецЦикла;			
//	
//КонецПроцедуры

//// Функция дополняет структуру шапки документа положениями учетной политики.
////
//Процедура ДополнитьПоложениямиУчетнойПолитики(СтруктураШапкиДокумента, КонДата, Отказ, Организация, Учет = "Нал", СтруктураПолейУчетнойПолитикиНУ = неопределено) Экспорт
//	
//	Если Учет = "Упр" Тогда
//		СтруктураУП = ПолучитьПараметрыУчетнойПолитикиУпр(КонДата);
//	Иначе
//		СтруктураУП = ПолучитьПараметрыУчетнойПолитикиРегл(КонДата, Организация);
//	КонецЕсли; 
//	Если НЕ ЗначениеЗаполнено(СтруктураУП) Тогда
//		Отказ = Истина;
//		Возврат;
//	КонецЕсли;
//	
//	Для каждого ПараметрУП Из СтруктураУП Цикл
//		Если (ТипЗнч(СтруктураПолейУчетнойПолитикиНУ) = Тип("Структура"))
//		   И НЕ (СтруктураПолейУчетнойПолитикиНУ.Количество() = 0) Тогда
//		   
//		   // Заполнение определенными параметрами учетной политики
//			Если СтруктураПолейУчетнойПолитикиНУ.Свойство(ПараметрУП.Ключ) Тогда
//				Если НЕ ЗначениеЗаполнено(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ]) Тогда
//					СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);
//				Иначе
//					СтруктураШапкиДокумента.Вставить(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ],ПараметрУП.Значение);
//				КонецЕсли; 
//			КонецЕсли; 
//			
//		Иначе	
//			
//			// Заполнение всеми параметрами учетной политики
//			СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);  
//			
//		КонецЕсли; 
//	КонецЦикла; 
//	
//КонецПроцедуры // ДополнитьПоложениямиУчетнойПолитики()


//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

//#Если Клиент Тогда

//// Процедура выполняет открытие HTML-страницы 
//// по указанному URL
//Процедура Интерфейс1Действие() Экспорт
//	Форма = Обработки.Обозреватель.ПолучитьФорму("Форма",,"Опрос");
//	Форма.Заголовок = "Отзыв о программе";
//	Форма.СтартоваяСтраница = "www.1c.ru/usability/inquirer/upp.jsp";
//	Форма.Открыть();
//КонецПроцедуры

//#КонецЕсли

//////////////////////////////////////////////////////////////////////////////////
//// РАБОТА С ПЕРЕМЕННЫМИ

//// Меняет местами значения двух доступных для записи переменных
////
//// Параметры
////  Источник - первая переменная
////  Приемник – вторая переменная
////
//Процедура ПоменятьПеременныеМестами(Источник, Приемник) Экспорт

//	тмп = Источник;
//	Источник = Приемник;
//	Приемник = Тмп;

//КонецПроцедуры // ПоменятьПеременныеМестами()

//// Функция "расщепляет" строку на подстроки, используя заданный 
////		разделитель. Разделитель может иметь любую длину. 
////		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
////		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
////		игнорируются.
////		Например, 
////		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
////		три из которых - пустые строки, а 
////		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
////
////	Параметры: 
////		Стр - 			строка, которую необходимо разложить на подстроки. 
////						Параметр передается по значению.
////		Разделитель - 	строка-разделитель, по умолчанию - запятая.
////
////
////	Возвращаемое значение:
////		массив значений, элементы которого - подстроки
////
//Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
//	
//	Возврат СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Стр, Разделитель);
//	
//КонецФункции // глРазложить

//// Возвращает строку, полученную из массива элементов, разделенных символом разделителя
////
//// Параметры:
////  Массив - Массив - массив элементов из которых необходимо получить строку
////  Разделитель - Строка - любой набор символов, который будет использован как разделитель между элементами в строке
////
//// Возвращаемое значение:
////  Результат - Строка - строка, полученная из массива элементов, разделенных символом разделителя
//// 
//Функция ПолучитьСтрокуИзМассиваПодстрок(Массив, Разделитель = ",") Экспорт
//	
//	// возвращаемое значение функции
//	Результат = "";
//	
//	Для Каждого Элемент ИЗ Массив Цикл
//		
//		Подстрока = ?(ТипЗнч(Элемент) = Тип("Строка"), Элемент, Строка(Элемент));
//		
//		РазделительПодстрок = ?(ПустаяСтрока(Результат), "", Разделитель);
//		
//		Результат = Результат + РазделительПодстрок + Подстрока;
//		
//	КонецЦикла;
//	
//	Возврат Результат;
//	
//КонецФункции

//// Функция раскладывает Наименование в массив из трех элементов
////
//// Параметры
////  ФИО  - строка - наименование
////
//// Возвращаемое значение:
////   Массив   - массив из трех элементов, Фамилия, Имя, Отчество
////
//Функция ПолучитьМассивФИО(ФИО) Экспорт

//	МассивФИО = Новый Массив;
//	МассивФИО.Добавить("");
//	МассивФИО.Добавить("");
//	МассивФИО.Добавить("");
//	
//	МассивПодсток = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(ФИО, " ");
//	Для Индекс = 0 По МассивПодсток.ВГраница() Цикл
//		Если Индекс < 3 Тогда
//			МассивФИО[Индекс] = МассивПодсток[Индекс];
//		Иначе
//			МассивФИО[2] = МассивФИО[2] + " " + МассивПодсток[Индекс];
//		КонецЕсли;
//	КонецЦикла;

//	Возврат МассивФИО;
//	
//КонецФункции // ПолучитьМассивФИО()

//// Отбирает из переданной таблицы строки по заданным критериям.
////
//// Параметры:
////  Источник - ТаблицаЗначений, РезультатЗапроса, ОбластьЯчеекТабличногоДокумента. Таблица-источник.
////  СтруктураКритериев - Структура. Названия отборов и значения, по которым нужно отобрать строки.
////  СтруктураСложныхКритериев - Структура. Если свойство передано, то значение содержит вид сравнения.
////
//// Возвращаемое значение:
////  РезультатЗапроса - таблица с нужными строками.
////
//Функция ОтобратьСтрокиПоКритериям(Источник, СтруктураКритериев, СтруктураСложныхКритериев = Неопределено) Экспорт

//	Перем ВидСравненияСложный;

//	Если СтруктураСложныхКритериев = Неопределено Тогда
//		СтруктураСложныхКритериев = Новый Структура;
//	КонецЕсли;

//	ПостроительЗапроса = Новый ПостроительЗапроса;
//	ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(Источник);

//	Для Каждого Критерий Из СтруктураКритериев Цикл
//		НовыйОтбор = ПостроительЗапроса.Отбор.Добавить(Критерий.Ключ);

//		СтруктураСложныхКритериев.Свойство(Критерий.Ключ, ВидСравненияСложный);

//		Если ВидСравненияСложный = Неопределено Тогда
//			НовыйОтбор.Установить(Критерий.Значение);
//		Иначе
//			НовыйОтбор.Использование = Истина;
//			НовыйОтбор.ВидСравнения = ВидСравненияСложный;
//			НовыйОтбор.Значение = Критерий.Значение;
//		КонецЕсли;
//	КонецЦикла;

//	Возврат ПостроительЗапроса.Результат;

//КонецФункции // ОтобратьСтрокиПоКритериям()

//// Возвращает дату начала периода по имеющимся данным о:
//// дате окончании периода, значении перечисления Период, количестве периодов
//// 
//Функция ПолучитьДатуНачалаПериодаПоДатеОкончанияКоличествуПериодов(ДатаОкончания, ПериодСсылка, КоличествоПериодов) Экспорт
//	
//	Если КоличествоПериодов = 0 Тогда
//		КоличествоПериодов = 1;
//	КонецЕсли;
//	
//	Если ДатаОкончания = Неопределено Тогда
//		
//		Если КоличествоПериодов > 0 Тогда
//			ДатаОкончания = КонецДня(ТекущаяДата());
//		ИначеЕсли КоличествоПериодов < 0 Тогда
//			ДатаОкончания = НачалоДня(ТекущаяДата());
//		КонецЕсли;
//		
//	КонецЕсли;
//	
//	Если (ПериодСсылка = Перечисления.Периодичность.День) Тогда
//		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24 * КоличествоПериодов);
//	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Неделя) Тогда
//		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24*7 * КоличествоПериодов);
//	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Декада) Тогда
//		ДеньМесяца = День(ДатаОкончания);
//		НачМесяца = НачалоМесяца(ДатаОкончания);
//		Если ДеньМесяца <= 10 Тогда
//			НомерДекады = 1;
//		ИначеЕсли ДеньМесяца <= 20 Тогда
//			НомерДекады = 2;
//		Иначе
//			НомерДекады = 3;
//		КонецЕсли;
//		
//		НомерДекады = НомерДекады - КоличествоПериодов + ?(КоличествоПериодов > 0, 1 , -1);
//		Если НомерДекады > 0 Тогда
//			Месяцев = Цел((НомерДекады-1)/3);
//		Иначе
//			Месяцев = -1 - Цел((-НомерДекады)/3);
//		КонецЕсли;
//		
//		НомерДекады = НомерДекады - 3*Месяцев;
//		Дт = ДобавитьМесяц(НачМесяца, Месяцев) + (НомерДекады-1) * 10 * 24 * 60 * 60;
//		
//		Возврат ?(КоличествоПериодов>0, Дт, ПолучитьКонецДекады(Дт));
//		
//	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Месяц) Тогда
//		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(КоличествоПериодов)));
//	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Квартал) Тогда
//		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(3 * КоличествоПериодов)));
//	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Полугодие) Тогда
//		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(6 * КоличествоПериодов)));
//	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Год) Тогда
//		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(12 * КоличествоПериодов)));
//	КонецЕсли;
//	
//	Если КоличествоПериодов > 0 Тогда
//		Возврат ДатаНачала + 60*60*24;
//	ИначеЕсли КоличествоПериодов < 0 Тогда
//		Возврат КонецДня(ДатаНачала - 60*60*24);
//	КонецЕсли;
//	
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// ФОРМИРОВАНИЕ КПП НА БАЗЕ ИНН

//#Если Клиент Тогда
//// Процедура заполняет КПП на базе ИНН
//Процедура ЗаполнитьКППпоИНН(Знач ИНН, КПП, БезусловноеЗаполнениеКПП = Истина) Экспорт
//	
//	//	Если КПП формируется стандартным образом по ИНН, то для КПП берутся 
//	//первые 4 цифры ИНН + 01001, например:
//	//ИНН 7712563009
//	//КПП 771201001
//		
//	// если не указано ИНН или заполнено КПП то прерываем выполнение операции
//	Если (СтрДлина(ИНН) < 4) Тогда
//		Возврат;
//	КонецЕсли;
//	
//	ПревыеСимволыИНН = Лев(ИНН, 4);
//	НовоеЗначениеКПП = ПревыеСимволыИНН + "01001";
//	
//	// если новое значение КПП и старое значение КПП совпадают, то прерываем выполнение операции
//	Если (НовоеЗначениеКПП = КПП) Тогда
//		Возврат;
//	КонецЕсли;
//	
//	// если безусловно нужно поменять - меняем
//	Если БезусловноеЗаполнениеКПП ИЛИ НЕ ЗначениеЗаполнено(КПП) Тогда
//		КПП = НовоеЗначениеКПП;
//		Возврат;
//	КонецЕсли;
//	
//	ОтветНужноМенятьКПП = (Вопрос("Изменить КПП автоматически на """ + НовоеЗначениеКПП + """?", РежимДиалогаВопрос.ДаНет) = КодВозвратаДиалога.Да);
//	Если ОтветНужноМенятьКПП Тогда
//		КПП = НовоеЗначениеКПП;
//	КонецЕсли;
//	
//КонецПроцедуры

//#КонецЕсли


//Функция ПолучитьОсновнойДоговорКонтрагента(Контрагент) Экспорт
//	
//	Запрос = Новый Запрос;
//	Запрос.Текст = "
//	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
//	|	ДоговорыКонтрагентов.Ссылка КАК ДоступныйДоговорКонтрагента
//	|ИЗ
//	|	Справочник.ДоговорыКонтрагентов КАК ДоговорыКонтрагентов
//	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
//	|		ПО (Контрагенты.Ссылка = &Контрагент)
//	|			И Контрагенты.ОсновнойДоговорКонтрагента = ДоговорыКонтрагентов.Ссылка
//	|ГДЕ
//	|	ДоговорыКонтрагентов.Владелец = &Контрагент
//	|
//	|УПОРЯДОЧИТЬ ПО
//	|	ВЫБОР
//	|		КОГДА Контрагенты.ОсновнойДоговорКонтрагента ЕСТЬ NULL 
//	|			ТОГДА 1
//	|		ИНАЧЕ 0
//	|	КОНЕЦ";
//	
//	Запрос.УстановитьПараметр("Контрагент", Контрагент);
//	
//	Выборка = Запрос.Выполнить().Выбрать();
//	Если Выборка.Следующий() Тогда
//		Возврат Выборка.ДоступныйДоговорКонтрагента;		
//	Иначе
//		Возврат Справочники.ДоговорыКонтрагентов.ПустаяСсылка();		
//	КонецЕсли;	
//		
//КонецФункции

//Функция ПолучитьОсновноеКонтактноеЛицоКонтрагента(Контрагент) Экспорт
//	
//	Запрос = Новый Запрос;
//	Запрос.Текст = "
//	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
//	|	КонтактныеЛицаКонтрагентов.Ссылка КАК ДоступноеКонтактноеЛицоКонтрагента
//	|ИЗ
//	|	Справочник.КонтактныеЛицаКонтрагентов КАК КонтактныеЛицаКонтрагентов
//	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
//	|		ПО (Контрагенты.Ссылка = &Контрагент)
//	|			И Контрагенты.ОсновноеКонтактноеЛицо = КонтактныеЛицаКонтрагентов.Ссылка
//	|ГДЕ
//	|	КонтактныеЛицаКонтрагентов.Владелец = &Контрагент
//	|
//	|УПОРЯДОЧИТЬ ПО
//	|	ВЫБОР
//	|		КОГДА Контрагенты.ОсновноеКонтактноеЛицо ЕСТЬ NULL 
//	|			ТОГДА 1
//	|		ИНАЧЕ 0
//	|	КОНЕЦ";
//	
//	Запрос.УстановитьПараметр("Контрагент", Контрагент);
//	
//	Выборка = Запрос.Выполнить().Выбрать();
//	Если Выборка.Следующий() Тогда
//		Возврат Выборка.ДоступноеКонтактноеЛицоКонтрагента;		
//	Иначе
//		Возврат Справочники.КонтактныеЛицаКонтрагентов.ПустаяСсылка();		
//	КонецЕсли;	
//		
//КонецФункции


//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

//Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
//	
//	// Префикс узла распределенной информационной базы добавляется к префиксу-параметру процедуры
//	// если есть хоть один периферийный узел в любом из планов обмена:
//	// Полный, ОбменУППУПП, ОбменУправлениеПредприятиемУправлениеТорговлей, 
//	// ОбменУправлениеПредприятиемРозничнаяТорговля
//	//
//	// Установка значений параметров сеанса ИспользованиеРИБ, НаличиеОбменаУТУПП, 
//	// выполняется в процедуре ПолныеПрава.ОпределитьФактИспользованияРИБ()
//	Если ПараметрыСеанса.ИспользованиеРИБ
//	 ИЛИ ПараметрыСеанса.НаличиеОбменаУТУПП 
//	 ИЛИ ПараметрыСеанса.НаличиеОбменаСРозничнойТорговлей Тогда
//		Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
//	КонецЕсли;
//	
//КонецПроцедуры

//Функция ОпределитьТекущийРежимРаботыМонопольный() Экспорт
//	
//	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
//	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
//	
//	Для каждого Соединение ИЗ МассивСоединений Цикл
//		
//		Если Соединение.ИмяПриложения <> "Designer" 
//			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда
//			
//			Возврат Ложь;
//			
//		КонецЕсли;
//		
//	КонецЦикла;
//	
//	Возврат Истина;
//	
//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ

//Процедура ПредупреждениеОбОшибке(ТекстСообщения) Экспорт
//	 
//	#Если Клиент Тогда
//		
//		Предупреждение(ТекстСообщения);
//	
//	#Иначе
//		
//		ВызватьИсключение(ТекстСообщения);
//		
//	#КонецЕсли
//	 
//КонецПроцедуры // ПредупреждениеОбОшибке()

//Процедура ЗапуститьПрограмму(ПутьКПрограмме, РабочийКаталог = Неопределено) Экспорт
//	
//	#Если Клиент Тогда
//		
//		ЗапуститьПриложение(ПутьКПрограмме, РабочийКаталог);
//	
//	#КонецЕсли
//	
//КонецПроцедуры // ЗапуститьПрограмму()

/////////////////////////////////////////////////////////////////////////////////
////// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С XML

//// Функция осуществляет построение дерева XML.
////
//// Параметры
////  XML             - <ЧтениеXML>
////                  - Объект, при помощи которого осуществляется чтение
////                    файла отчета.
////
////  Дерево          - <Структура>
////                  - Дерево XML.
////
////  ПервыйВызов     - <Булево>
////                  - Служебный параметр.
////
//// Возвращаемое значение:
////  <Булево>        - Результат выполнения.
////
//Функция ПостроитьДеревоXML(XML, Дерево, ПервыйВызов = Истина)

//	Результат = Истина;
//	Имя       = "";
//	Врем      = Неопределено;
//	Врем2     = Неопределено;
//	Врем3     = Неопределено;

//	Если ПервыйВызов Тогда
//		Дерево = Новый Структура();
//	КонецЕсли;

//	Если XML.Прочитать() Тогда
//		Если XML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
//			Имя  = XML.ЛокальноеИмя;
//			Врем = Новый Структура();
//			Пока ПостроитьДеревоXML(XML, Врем, Ложь) Цикл
//			КонецЦикла;
//			Пока XML.Имя <> Имя Цикл
//				Если XML.ТипУзла = ТипУзлаXML.Текст Тогда
//					Врем = XML.Значение;
//				КонецЕсли;
//				Если Не XML.Прочитать() Тогда
//					Результат = Ложь;
//					Возврат Результат;
//				КонецЕсли;
//			КонецЦикла;
//			Дерево.Свойство(Имя, Врем2);
//			Если Врем2 = Неопределено Тогда
//				Врем2 = Врем;
//			Иначе
//				Если ТипЗнч(Врем2) = Тип("Массив") Тогда
//					Врем2.Добавить(Врем);
//				Иначе
//					Врем3 = Новый Массив();
//					Врем3.Добавить(Врем2);
//					Врем3.Добавить(Врем);
//					Врем2 = Врем3;
//				КонецЕсли;
//			КонецЕсли;
//			Дерево.Вставить(Имя, Врем2);
//		Иначе
//			Результат = Ложь;
//		КонецЕсли;
//	Иначе
//		Результат = Ложь;
//	КонецЕсли;

//	Возврат Результат;

//КонецФункции // ПостроитьДеревоXML()

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ

//Процедура УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, ПроверятьДвижения=ложь)
//	//Очистим коллекцию движений документа
//	ТаблицаСтаройРегистрацииВПоследовательности = Новый ТаблицаЗначений();
//	ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("ИмяПоследовательности");
//	ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("Организация");
//	ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("Период");
//	
//	КоллекцияПоследовательностей = ДокументОбъект.ПринадлежностьПоследовательностям;
//	Для Каждого НаборЗаписейРегистрацииВПоследовательности ИЗ КоллекцияПоследовательностей Цикл
//		Если (НаборЗаписейРегистрацииВПоследовательности.Количество() > 0) Тогда
//			Если НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя = "ПартионныйУчет"  
//			  ИЛИ НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя = "ПартионныйУчетБУ" Тогда
//			    НаборЗаписейРегистрацииВПоследовательности.Прочитать();
//				Для Каждого ЗаписьВПоследовательности Из НаборЗаписейРегистрацииВПоследовательности Цикл
//					НоваяЗаписьРегистрации = ТаблицаСтаройРегистрацииВПоследовательности.Добавить();
//					НоваяЗаписьРегистрации.ИмяПоследовательности = НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя;
//					НоваяЗаписьРегистрации.Организация = ЗаписьВПоследовательности.Организация;
//					НоваяЗаписьРегистрации.Период = ЗаписьВПоследовательности.Период;
//				КонецЦикла;	
//				НаборЗаписейРегистрацииВПоследовательности.Очистить();
//			КонецЕсли;	
//		   	НаборЗаписейРегистрацииВПоследовательности.Записать();
//		КонецЕсли;
//	КонецЦикла;
//	
//	//Если коллекция пуста, то привилегированно очистим набор записей
//	УправлениеЗапасамиПартионныйУчет.УдалитьРегистрациюДокументаВПоследовательностяхНаСервере(ДокументОбъект.Ссылка, ПроверятьДвижения, ТаблицаСтаройРегистрацииВПоследовательности);
//	ТаблицаСтаройРегистрацииВПоследовательности.Свернуть("ИмяПоследовательности,Организация,Период"); 
//	ДокументОбъект.ДополнительныеСвойства.Вставить("ТаблицаСтаройРегистрацииВПоследовательности",ТаблицаСтаройРегистрацииВПоследовательности);
//	
//КонецПроцедуры//УдалитьРегистрациюДокументаВПоследовательностях

//// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ФОРМИРОВАНИЯ ДВИЖЕНИЙ ДОКУМЕНТОВ

//// Функция загружает таблицы документа в таблицы соответствующие структуре регистров
////	Параметры:
////		- Движение - движение документа (т.е. регистр)
////		- СтруктТаблицДокумента - структура содержашая таблицы документа. ключ - имя таблицы, значение - таблица значений с данными документа.
////
////	Возврат:
////		- Структура, в которой ключ - это имя таблицы документа, соответствующий параметру СтруктТаблицДокумента,
////		  значение - таблица значений, со структурой соответствующей структуре параметра (т.е. регистра) Движение
////		  В таблицы значений данные загружаются по соответствию с имен полей.
////
//Функция ЗагрузитьТаблицыДокументаВСтруктуру(Движение, СтруктТаблицДокумента) Экспорт
//	
//	ПустаяТабРегистра = Движение.Выгрузить();
//	ПустаяТабРегистра.Очистить();
//	
//	СтруктДанных = Новый Структура;
//	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
//	
//		ТабРегистра = ПустаяТабРегистра.Скопировать();
//		
//		Если ТабЧасть.Значение <> Неопределено И ТабЧасть.Значение.Количество() > 0 Тогда
//			ЗагрузитьВТаблицуЗначений( ТабЧасть.Значение, ТабРегистра);
//		КонецЕсли;
//		
//		СтруктДанных.Вставить( ТабЧасть.Ключ, ТабРегистра);
//		
//	КонецЦикла;
//	
//	Возврат СтруктДанных;

//КонецФункции // ЗагрузитьТаблицыДокументаВСтруктуру()

//// Процедура заполняет структуру таблиц документа, значением которое будет одинаковым для всех таблиц (например значением шапки документа)
////	Параметры:
////		- СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
////		- ИмяПоля - имя колонки в таблицах локумента, в которую будет установлено новое значение
////		- УстанавливаемоеЗначение - значение, которое надо установить в таблицы документа
////		- СтрТабЧасти - имена таб. частей документа в которые необходимо установить новое значение. строка, в которой
////						имена таб. частей разделены запятыми. необязательный параметр, по умолчанию - все таблицы.
////
//Процедура УстановитьЗначениеВТаблицыДокумента(СтруктТаблицДокумента, ИмяПоля, УстанавливаемоеЗначение, СтрТабЧасти = "") Экспорт
//	
//	СтруктТабЧасти = ?( ПустаяСтрока(СтрТабЧасти), СтруктТаблицДокумента, Новый Структура(СтрТабЧасти));
//	Для Каждого ТабЧасть Из СтруктТабЧасти Цикл
//	
//		Если СтруктТаблицДокумента[ТабЧасть.Ключ].Количество() > 0 Тогда
//		    СтруктТаблицДокумента[ТабЧасть.Ключ].ЗаполнитьЗначения( УстанавливаемоеЗначение, ИмяПоля);
//		КонецЕсли;
//	
//	КонецЦикла;
//	
//КонецПроцедуры // УстановитьЗначениеВТаблицыДокумента()

//// Процедура формирует движение в регистр на основании данных в таблицах документов
////	Параметры:
////		- Движение - движение документа, в которое необходимо произвести добавление записей (т.е. регистр)
////		- ВидДвижения - вид движения накопления (приход/расход)
////		- СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
////		- ДатаДвижения - дата на которую будут формироваться записи
////
//Процедура ЗаписатьТаблицыДокументаВРегистр(Движение, ВидДвижения, СтруктТаблицДокумента, ДатаДвижения) Экспорт
//	
//	Движение.мПериод = ДатаДвижения;
//	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
//	
//		Если ТабЧасть.Значение.Количество() = 0 Тогда
//			Продолжить; // Пропускаем пустые табличные части
//		КонецЕсли;
//		
//		Движение.мТаблицаДвижений = ТабЧасть.Значение;
//		Если ВидДвижения = Неопределено Тогда // Регистр сведений
//			ВыполнитьДвижениеПоРегистру(Движение);
//		Иначе // Регистр накопления
//			ВыполнитьДвижениеПоРегистру(Движение, ВидДвижения);
//		КонецЕсли;
//	
//	КонецЦикла;

//КонецПроцедуры // ЗаписатьТаблицыДокументаВРегистр()

//// Процедура удаляет строки с пустыми значениями из структуры таблиц документа
////	Параметры:
////		- ТаблицыДляДвиженийПоЗаказам - структура таблиц документа
////		- ИмяПоля - имя поля, значение которого проверяет на пустое значение.
////
//Процедура УдалитьСтрокиИзТаблицДокумента(ТаблицыДляДвиженийПоЗаказам, ИмяПоля) Экспорт

//	Для Каждого ТабЧасть Из ТаблицыДляДвиженийПоЗаказам Цикл
//		КолвоСтрок = ТабЧасть.Значение.Количество(); 
//		Для Инд = 1 По КолвоСтрок Цикл 
//		     ТекСтрока = ТабЧасть.Значение[КолвоСтрок - Инд]; 

//		     Если НЕ ЗначениеЗаполнено(ТекСтрока[ИмяПоля]) Тогда 
//		          ТабЧасть.Значение.Удалить(ТекСтрока); 
//		     КонецЕсли; 
//		КонецЦикла; 
//	КонецЦикла;
//	
//КонецПроцедуры // УдалитьСтрокиИзТаблицДокумента()

//// Процедура переименовывает колонку таблицы значений, с сохранением истории переименований для возможности последующего "отката"
////
////	Параметры:
////		- ТабЗначений - таблица значений в которой производится переименование колонок
////		- ТабИмен - таблица с историей переименований. Новые сведения о переименованных колонках добавляются сюда и возвращаются в вызвавшую процедуру
////		- ТекИмяКолонки - имя колонки которую надо переименовать
////		- НовоеИмяКолонки - новое имя колонки. Если параметр не задан, новое имя присваивается автоматически
////
//Процедура ПереименоватьКолонкуТаблицыЗначений(ТабЗначений, ТабИмен, Знач ТекИмяКолонки, Знач НовоеИмяКолонки = "") Экспорт

//	Если ТабИмен = Неопределено Тогда
//		ТабИмен = Новый ТаблицаЗначений;
//		ТабИмен.Колонки.Добавить("НовИмя", Новый ОписаниеТипов("Строка"));
//		ТабИмен.Колонки.Добавить("ТекИмя",   Новый ОписаниеТипов("Строка"));
//	КонецЕсли;
//	
//	ТекКолонка = ТабЗначений.Колонки.Найти(ТекИмяКолонки);
//	Если ПустаяСтрока(НовоеИмяКолонки) Тогда
//		// Генерируем новое имя для старой колонки, гарантируя что оно будет уникальным
//		Индекс = 1;
//		Пока Истина Цикл
//			НовоеИмяКолонки = "_" + Строка(Индекс) + "_" + ТекИмяКолонки;
//			Если ТабЗначений.Колонки.Найти(НовоеИмяКолонки) = Неопределено Тогда
//				Прервать;
//			КонецЕсли;
//			Индекс = Индекс + 1;
//		КонецЦикла;
//		// После выхода из цикла в переменной НовоеИмяКолонки должны получить новое имя колонки,
//	КонецЕсли;
//	
//	// Переименуем колонку
//	ТабЗначений.Колонки[ТекИмяКолонки].Имя = НовоеИмяКолонки;
//	
//	// Сохраним имя колонки в таб. имен
//	НоваяСтрока = ТабИмен.Добавить();
//	НоваяСтрока.НовИмя = НовоеИмяКолонки;
//	НоваяСтрока.ТекИмя = ТекИмяКолонки;

//КонецПроцедуры // ПереименоватьКолонкуТаблицыЗначений()

//// Процедура восстанавливает имена колонок таблицы значений, сохраненные в процедуре ПереименоватьКолонкуТаблицыЗначений()
////
////	Параметры:
////		- ТабЗначений - таблица значений в которой производится переименование колонок
////		- ТабИмен - таблица с историей переименований, таблица создается и заполняется в процедуре ПереименоватьКолонкуТаблицыЗначений()
////
//Процедура ВосстановитьИменаКолонокТаблицыЗначений(ТабЗначений, ТабИмен) Экспорт
//	
//	К = ТабИмен.Количество() - 1;
//	Пока К >= 0 Цикл
//		ТекСтрока = ТабИмен[К];
//		ТабЗначений.Колонки[ТекСтрока.НовИмя].Имя = ТекСтрока.ТекИмя;
//		К = К - 1;
//	КонецЦикла;
//	
//	ТабИмен.Очистить();

//КонецПроцедуры // ВосстановитьИменаКолонокТаблицыЗначений()

//// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ФОРМИРОВАНИЯ ДВИЖЕНИЙ ДОКУМЕНТОВ
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ

//// Устанавливает управляемую блокировку таблицы
////
//// Параметры:
////  СтруктураПараметров 		- <Структура>. Структура параметров блокировки. Обязательный параметр.
////								Обязательно должна содержать свойства:
////								"ИмяТаблицы" - <Строка> - имя таблицы, на которую накладывается блокировка.
////									Например: "АвансовыйОтчет"
////								Необязательные свойства:
////								"ТипТаблицы" - <Строка> - тип таблицы, на которую накладывается блокировка.
////									Пространство блокировки состоит из типа таблицы и имени таблицы.
////									Например: "Документ"
////									Значение по умолчанию: "РегистрНакопления"
////								"РежимБлокировки" - <РежимБлокировкиДанных> - режим накладываемой блокировки.
////									Значение по умолчанию: РежимБлокировкиДанных.Исключительный
////								"ИсточникДанных" - источник данных для блокировки.
////									Может передаваться значение любого типа, поддерживаемого свойством ИсточникДанных элемента блокировки,
////									а также типа "Менеджер временных таблиц".
////									Если в структуре нет этого свойства - блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
////								"ИмяВременнойТаблицы" - <Строка> - имя временной таблицы менеджера временных таблиц, которая служит источником данных для блокировки.
////									Обязательно должно указываться, если в качестве источника данных процедуре передан менеджер временных таблиц.
////  СтруктураЗначенийБлокировки	- <Структура> - описывает значения блокировки, накладываемые с помощью УстановитьЗначение().
////									Ключ - поле блокировки, значение - блокируемое значение.
////									Если передано Неопределено или если структура не содержит ни одного элемента -
////									блокировки через УстановитьЗначение() не накладываются.
////  СтруктураИсточникаДанных	- <Структура> - описывает значения блокировки, накладываемые с помощью ИспользоватьИзИсточникаДанных().
////									Ключ - поле блокировки, значение - поле источника данных.
////									Если передано Неопределено или если структура не содержит ни одного элемента -
////									блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
////  Отказ 						- <Булево> - при ошибке в процессе установки блокировки в этот параметр процедура возвращает значение Истина
////  Заголовок 					- <Строка> - заголовок сообщения об ошибке при установке блокировки
////
//Процедура УстановитьУправляемуюБлокировку(СтруктураПараметров, СтруктураЗначенийБлокировки = Неопределено, СтруктураИсточникаДанных = Неопределено, Отказ, Заголовок) Экспорт
//	
//	Если НЕ ТипЗнч(СтруктураПараметров) = Тип("Структура") Тогда
//		Возврат;
//	КонецЕсли;
//	
//	ИспользоватьЗначенияБлокировки = СтруктураЗначенийБлокировки <> Неопределено 
//		И ТипЗнч(СтруктураЗначенийБлокировки) = Тип("Структура") 
//		И СтруктураЗначенийБлокировки.Количество() > 0;
//		
//	ИспользоватьИсточникДанных     = СтруктураИсточникаДанных <> Неопределено 
//		И ТипЗнч(СтруктураИсточникаДанных) = Тип("Структура") 
//		И СтруктураИсточникаДанных.Количество() > 0
//		И СтруктураПараметров.Свойство("ИсточникДанных");
//	
//	Если НЕ ИспользоватьЗначенияБлокировки И НЕ ИспользоватьИсточникДанных Тогда
//		Возврат;
//	КонецЕсли;
//	
//	Блокировка = Новый БлокировкаДанных;
//	
//	ТипТаблицы = ?(СтруктураПараметров.Свойство("ТипТаблицы"), СтруктураПараметров.ТипТаблицы, "РегистрНакопления") + ".";
//	ИмяТаблицы = СтруктураПараметров.ИмяТаблицы;
//	ПространствоБлокировки = ТипТаблицы + ИмяТаблицы;
//	ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
//	
//	РежимБлокировки = ?(СтруктураПараметров.Свойство("РежимБлокировки"), СтруктураПараметров.РежимБлокировки, РежимБлокировкиДанных.Исключительный);
//	ЭлементБлокировки.Режим = РежимБлокировки;
//	
//	Если ИспользоватьЗначенияБлокировки Тогда
//	
//		Для каждого ЭлементСтруктуры Из СтруктураЗначенийБлокировки Цикл
//			ЭлементБлокировки.УстановитьЗначение(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
//		КонецЦикла;
//	
//	КонецЕсли;
//	
//	Если ИспользоватьИсточникДанных Тогда
//		
//		ИсточникДанных = СтруктураПараметров.ИсточникДанных; 
//		
//		Если ТипЗнч(ИсточникДанных) = Тип("МенеджерВременныхТаблиц") Тогда
//		
//			Запрос = Новый Запрос;
//			Запрос.МенеджерВременныхТаблиц = ИсточникДанных;
//			ТекстЗапроса = "";
//			Для каждого ЭлементСтруктуры Из СтруктураИсточникаДанных Цикл
//				ТекстЗапроса = ТекстЗапроса + ",
//				|	Таб." + ЭлементСтруктуры.Значение;
//			КонецЦикла;
//			ТекстЗапроса = Сред(ТекстЗапроса, 2);
//			ТекстЗапроса = 			
//			"ВЫБРАТЬ РАЗЛИЧНЫЕ"
//			+ ТекстЗапроса + "
//			|ИЗ
//			|	" + СтруктураПараметров.ИмяВременнойТаблицы + " КАК Таб";
//			Запрос.Текст = ТекстЗапроса;
//			Результат    = Запрос.Выполнить();
//			
//			ЭлементБлокировки.ИсточникДанных = Результат;
//			
//		Иначе
//			
//			ЭлементБлокировки.ИсточникДанных = ИсточникДанных;
//			
//		КонецЕсли;
//	
//		Для каждого ЭлементСтруктуры Из СтруктураИсточникаДанных Цикл
//			ЭлементБлокировки.ИспользоватьИзИсточникаДанных(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
//		КонецЦикла;
//	
//	КонецЕсли;
//	
//	Попытка
//	
//		Блокировка.Заблокировать();
//	
//	Исключение
//		
//		ОбщегоНазначения.СообщитьОбОшибке(ОписаниеОшибки(), Отказ, Заголовок);
//	    ВызватьИсключение "Операция не выполнена";
//	КонецПопытки;

//КонецПроцедуры

//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА

//// Функция разбирает строку вида
//// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
//// ТипОбъектаМетаданных должен быть Справочник или Документ.
////
//// Параметры:
////  ПутьКДанным - строка.
////  МетаданныеОбъекта - Объект метаданных
////
//// Возвращаемое значение:
////  Структура - путь к объекту метаданных
////
//Функция РазобратьПутьКОбъектуМетаданных(ПутьКДанным, МетаданныеОбъекта = Неопределено) Экспорт
//	
//	Структура = Новый Структура;
//	
//	СоответствиеИмен = Новый Массив();
//	СоответствиеИмен.Добавить("ТипОбъекта");
//	СоответствиеИмен.Добавить("ВидОбъекта");
//	СоответствиеИмен.Добавить("ПутьКДанным");
//	СоответствиеИмен.Добавить("ИмяТаблЧасти");
//	СоответствиеИмен.Добавить("ИмяРеквизита");
//	
//	Для индекс = 1 по 3 Цикл
//		
//		Точка = Найти(ПутьКДанным, ".");
//		ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
//		Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
//		ПутьКДанным = Сред(ПутьКДанным, Точка+1);
//		
//	КонецЦикла;
//	
//	ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
//	
//	Если Структура.ПутьКДанным = "ТабличнаяЧасть" Тогда
//		
//		Для индекс = 4 по 5  Цикл 
//			
//			Точка = Найти(ПутьКДанным, ".");
//			Если Точка = 0 Тогда
//				ТекущееЗначение = ПутьКДанным;
//			Иначе
//				ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
//			КонецЕсли;
//			
//			Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
//			ПутьКДанным = Сред(ПутьКДанным,  Точка+1);
//			
//		КонецЦикла;
//		
//	Иначе
//		
//		Структура.Вставить(СоответствиеИмен[3], "");
//		Структура.Вставить(СоответствиеИмен[4], ПутьКДанным);
//		
//	КонецЕсли;
//	
//	Если МетаданныеОбъекта <> Неопределено Тогда
//		Структура.Вставить("Метаданные", МетаданныеОбъекта);
//	Иначе
//		Если Структура.ТипОбъекта = "Документ" Тогда
//			Структура.Вставить("Метаданные", Метаданные.Документы[Структура.ВидОбъекта]);
//		Иначе
//			Структура.Вставить("Метаданные", Метаданные.Справочники[Структура.ВидОбъекта]);
//		КонецЕсли;
//	КонецЕсли;
//	
//	Возврат Структура;
//	
//КонецФункции // РазобратьПутьКОбъектуМетаданных()

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА, ПЕРЕМЕННЫХ МОДУЛЯ ПРИЛОЖЕНИЯ

//// Функция определяет наличие клиентских подключений к базе других пользователей
//Функция ЕстьДругиеПользователиВБазе() Экспорт
//	
//	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
//	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
//	
//	Для каждого Соединение ИЗ МассивСоединений Цикл		
//		Если Соединение.ИмяПриложения <> "Designer" 
//			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда			
//			Возврат Истина;						
//		КонецЕсли;		
//	КонецЦикла;
//	
//	Возврат Ложь;
//	
//КонецФункции

//// Функция собирает паспортные данные физ. лица на указанную дату
////
//// Параметры: 
////  ФизЛицо.    - физ. лицо, для которго необходимо получить паспортные данные
////  ДатаПериода - дата получения сведений
////
//// Возвращаемое значение:
////  Структура с паспортными данными.
////
//Функция ПаспортныеДанные(ФизЛицо, ДатаПериода) Экспорт

//	Запрос = Новый Запрос;
//	Запрос.УстановитьПараметр("ПарФизЛицо",     ФизЛицо);
//	Запрос.УстановитьПараметр("ПарДатаПериода", ДатаПериода);

//	Запрос.Текст = 
//	"ВЫБРАТЬ
//	|	ДокументВид        КАК Вид,
//	|	ДокументСерия      КАК Серия,
//	|	ДокументНомер      КАК Номер,
//	|	ДокументДатаВыдачи КАК ДатаВыдачи,
//	|	ДокументКемВыдан   КАК Выдан
//	|ИЗ
//	|	РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ПарДатаПериода, ФизЛицо = &ПарФизЛицо)
//	|";

//	Шапка = Запрос.Выполнить().Выбрать();
//	Шапка.Следующий();

//	Результат = Новый Структура("Вид, Серия, Номер, ДатаВыдачи, Выдан");

//	Результат.Вид        = Шапка.Вид;
//	Результат.Серия      = Шапка.Серия;
//	Результат.Номер      = Шапка.Номер;
//	Результат.ДатаВыдачи = Шапка.ДатаВыдачи;
//	Результат.Выдан      = Шапка.Выдан;

//	Возврат Результат;

//КонецФункции // ПаспортныеДанные()

//// Получает параметр учетной политики (налоговый учет) для заданной организации на заданную дату
////
//// Параметры:
////	ИмяПараметра        - строка, имя запрашиваемого параметра учетной политики,
////	Организация         - ссылка на элемент справочника "Организации", для которого надо получить параметры,
////	Дата                - дата, на которую надо получить параметры, если не заполнено, то берется рабочая дата,
////	СтруктураПараметров - структура, содержащая все параметры учетной политики.
////
//// Возвращаемое значение:
////	Значение учетной политики
////
//Функция ВыгрузитьСтруктуруВСтроку(Структура,ПоЗначениям=Ложь,СтруктураПроверки = Неопределено) Экспорт
//	
//	НеПроверять = (СтруктураПроверки=Неопределено);
//	
//	НоваяСтрока = "";
//	Для каждого Колонка из Структура Цикл
//		Если НеПроверять тогда
//			НоваяСтрока = НоваяСтрока + ?(НЕ ЗначениеЗаполнено(Колонка.Значение)или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)+",";
//		ИначеЕсли СтруктураПроверки.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение) или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)) тогда
//			НоваяСтрока = НоваяСтрока + ?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+",";
//		Иначе
//			//Нет в проверке!
//			возврат Ложь;
//		КонецЕсли;
//	КонецЦикла;
//	Если ЗначениеЗаполнено(НоваяСтрока) Тогда
//		НоваяСтрока = Лев(НоваяСтрока,СтрДлина(НоваяСтрока)-1);
//	КонецЕсли;
//	Возврат НоваяСтрока;
//КонецФункции

////Процедура для распределения записей из одной таблицы значений по базису (таблица значений или  набору записей)
////Источник 		: ТаблицаЗначений
////Базис 		: ТаблицаЗначений или НаборЗаписей
////Распределение : ключ - поля базиса, значение - поля источника
////Фильтр 		: ключ - поля базиса, значение - поля источника (если не укзан - по совпадающим колонкам)
////Игнорировать  : ключ - поля базиса, значение - поля источника
////Дополнить		: ключ - имя нового поля базиса, значение - значение для заполнения
//Функция СформироватьКорректирующиеЗаписи(Источник,Базис,Распределение,Фильтр=неопределено,Игнорировать=Неопределено,Дополнить=Неопределено, НераспределенныеЗаписи_AsIs = ложь) Экспорт
//	
//	Если ТипЗнч(Базис) = Тип("ТаблицаЗначений") тогда
//		Временный_Базис	   = Базис.Скопировать();
//	иначе
//		Временный_Базис	   = Базис.Выгрузить();
//	Конецесли;
//	
//	КолонкиИсточника = Новый Структура();
//	Для Каждого Колонка Из источник.Колонки Цикл
//		КолонкиИсточника.Вставить(Колонка.Имя);
//	КонецЦикла;
//	КолонкиБазиса = Новый Структура();
//	Для Каждого Колонка Из Временный_Базис.Колонки Цикл
//		Если Не(НЕ ЗначениеЗаполнено(Колонка.Имя)) тогда
//			КолонкиБазиса.Вставить(Колонка.Имя);
//		КонецЕсли;
//	КонецЦикла;
//	
//	Если НЕ ЗначениеЗаполнено(Игнорировать) тогда
//		 Игнорировать = новый Структура();
//	Иначе
//		//Зачистим колонки источника и базиса на игнорируемые колонки
//		Для Каждого Колонка Из Игнорировать Цикл
//			Если КолонкиИсточника.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
//				 КолонкиИсточника.Удалить(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
//			Конецесли;
//			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
//				 КолонкиБазиса.Удалить(Колонка.Ключ);
//			Конецесли;
//		КонецЦикла;
// 	КонецЕсли;
//	
//	//Зачистим колонки источника на распределяемые колонки. Они учитываются отдельно.
//	Для Каждого Колонка Из Распределение Цикл
//		Если КолонкиИсточника.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
//			 КолонкиИсточника.Удалить(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
//		Иначе
//			 Если Источник.Колонки.Найти(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено тогда
//				 //Не хватает колонок к распределению
//				 //Но одну и ту же колонку можно распределить дважды
//				 Возврат ложь;
//			 КонецЕсли;
//		Конецесли;
//		Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
//			 КолонкиБазиса.Удалить(Колонка.Ключ);
//		Иначе
//			  //Не хватает колонок базиса распределения
//			 Возврат ложь;
//		Конецесли;
//	КонецЦикла;
//	
//	Если ЗначениеЗаполнено(Дополнить) тогда
//		//Проверим на отсутствие дополняемых колонок!
//		Для Каждого Колонка Из Дополнить Цикл
//			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
//				//Такая колонка уже есть, нельзя добавить новую
//				Возврат Ложь;
//			Конецесли;
//		КонецЦикла;
// 	КонецЕсли;
//	
//	//Если фильтр не задан - по всем совпадающим колонкам
//	Если Фильтр=Неопределено тогда
//		Фильтр = Новый Структура();
//		Для каждого Колонка из КолонкиБазиса цикл
//			Если КолонкиИсточника.Свойство(Колонка.Ключ)  и не(Игнорировать.Свойство(Колонка.Ключ)) тогда
//				Фильтр.Вставить(Колонка.Ключ);
//			КонецЕсли;
//		КонецЦикла;
//	КонецЕсли;
//	
//	Если НЕ ЗначениеЗаполнено(Фильтр) тогда
//		//Должно быть хоть одно объединяющее поле!
//		Возврат Ложь;
//	КонецЕсли;
//	
//	Для Каждого Колонка Из Фильтр Цикл
//		Если не КолонкиБазиса.Свойство(Колонка.Ключ) тогда
//			  //Не хватает колонок базиса распределения
//			 Возврат ложь;
//		Конецесли;
//	КонецЦикла;
//	
//	
//	//Подготовить сворачивание для источника
//	СтрокаСверткиИсточник = ВыгрузитьСтруктуруВСтроку(Фильтр,Истина,КолонкиИсточника);
//	Если СтрокаСверткиИсточник = ложь Тогда
//		//попытка фильтровать по полю, отсутствующему в источнике!
//		Возврат ложь;
//	КонецЕсли;
//	КолонкиКРаспределениюИсточник = ВыгрузитьСтруктуруВСтроку(Распределение,Истина);
//	Если КолонкиКРаспределениюИсточник = ложь Тогда
//		//попытка распределить поле, отсутствующее в источнике!
//		Возврат ложь;
//	КонецЕсли;
//	
//	//Подготовить сворачивание для базиса
//	СтрокаСверткиБазис = ВыгрузитьСтруктуруВСтроку(КолонкиБазиса,Ложь);
//	Если СтрокаСверткиБазис = ложь Тогда
//		//попытка фильтровать по полю, отсутствующему в базисе!
//		Возврат ложь;
//	КонецЕсли;
//	КолонкиКРаспределениюБазис = ВыгрузитьСтруктуруВСтроку(Распределение,Ложь);
//	Если КолонкиКРаспределениюБазис = ложь Тогда
//		//попытка распределить поле, отсутствующее в базисе!
//		Возврат ложь;
//	КонецЕсли;
//	
//	Временный_Источник = Источник.Скопировать();
//	
//	Временный_Базис.Свернуть(СтрокаСверткиБазис,КолонкиКРаспределениюБазис);
//	Временный_Источник.Свернуть(СтрокаСверткиИсточник,КолонкиКРаспределениюИсточник);
//	
//	НоваяТаблица = новый ТаблицаЗначений();
//	Для каждого Колонка из Временный_Базис.Колонки Цикл
//		Если Колонка.ТипЗначения.СодержитТип(Тип("Число")) Тогда
//			Разрядность = Колонка.ТипЗначения.КвалификаторыЧисла.Разрядность;
//			РазрядностьДробнойЧасти = Колонка.ТипЗначения.КвалификаторыЧисла.РазрядностьДробнойЧасти;
//			КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
//			
//			ТипЗначения = Новый ОписаниеТипов(Колонка.ТипЗначения,,,КвалификаторЧисла);
//		Иначе
//			ТипЗначения = Колонка.ТипЗначения;
//		КонецЕсли;
//		
//		НоваяТаблица.Колонки.Добавить(Колонка.Имя, ТипЗначения,,10);
//	КонецЦикла;
//	
//	ТаблицаБазисовРаспределения = Новый ТаблицаЗначений();
//	Для каждого Колонка из Распределение Цикл
//		ТаблицаБазисовРаспределения.Колонки.Добавить(Колонка.Ключ);
//	КонецЦикла;
//	
//	Для каждого СтрокаИсточника из Временный_Источник цикл
//		Отбор = новый структура();
//		Для каждого Колонка из Фильтр цикл
//			Отбор.Вставить(Колонка.Ключ,СтрокаИсточника[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)]);
//		КонецЦикла;
//		СтрокиБазиса = Временный_Базис.НайтиСтроки(Отбор);
//		Временный_Базис_СтрокаНераспределеннойЗаписи = Неопределено;
//		Если СтрокиБазиса.Количество() = 0 и НераспределенныеЗаписи_AsIs Тогда
//			Временный_Базис_СтрокаНераспределеннойЗаписи = Временный_Базис.Добавить();
//			ЗаполнитьЗначенияСвойств(Временный_Базис_СтрокаНераспределеннойЗаписи, СтрокаИсточника);
//			СтрокиБазиса.Добавить(Временный_Базис_СтрокаНераспределеннойЗаписи);
//		КонецЕсли;		
//			
//		ТаблицаБазисовРаспределения.Очистить();
//		Для каждого Строка из СтрокиБазиса Цикл
//			СтрокаТБР = ТаблицаБазисовРаспределения.Добавить();
//			ЗаполнитьЗначенияСвойств(СтрокаТБР, Строка);
//		КонецЦикла;
//		Для каждого Колонка из Распределение цикл
//			РаспределяемаяСумма =  СтрокаИсточника[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)];
//			МассивДляРаспределения = ТаблицаБазисовРаспределения.ВыгрузитьКолонку(Колонка.Ключ);
//			РазрядностьДробнойЧасти = Временный_Источник.Колонки[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)].ТипЗначения.КвалификаторыЧисла.РазрядностьДробнойЧасти;
//			МассивРезультата = РаспределитьПропорционально(РаспределяемаяСумма, МассивДляРаспределения,?(РазрядностьДробнойЧасти = 0, 3, РазрядностьДробнойЧасти));
//			Если МассивРезультата = неопределено тогда
//				ТаблицаБазисовРаспределения.ЗаполнитьЗначения(0,Колонка.Ключ);
//			иначе
//				ТаблицаБазисовРаспределения.ЗагрузитьКолонку(МассивРезультата,Колонка.Ключ);
//			КонецЕсли;
//		КонецЦикла;
//		
//		СтрокаРезультата = 0;
//		Для каждого Строка из СтрокиБазиса Цикл
//			СтрокаНовая = НоваяТаблица.Добавить();
//			СрокаРекультатаРаспределения = ТаблицаБазисовРаспределения[СтрокаРезультата];
//			СтрокаРезультата = СтрокаРезультата +1;
//			Для каждого Колонка из Временный_Базис.Колонки цикл
//				Если Распределение.Свойство(Колонка.Имя) тогда
//					СтрокаНовая[Колонка.Имя] = СрокаРекультатаРаспределения[Колонка.Имя];
//				Иначе
//					СтрокаНовая[Колонка.Имя] = Строка[Колонка.Имя];
//				КонецЕсли;
//			КонецЦикла;
//		КонецЦикла;
//		
//		Если не Временный_Базис_СтрокаНераспределеннойЗаписи = Неопределено Тогда
//		    Временный_Базис.удалить(Временный_Базис_СтрокаНераспределеннойЗаписи);
//		КонецЕсли; 
//	КонецЦикла;
//	Если ЗначениеЗаполнено(Дополнить) тогда
//		Для каждого Колонка из Дополнить Цикл
//			НоваяТаблица.Колонки.Добавить(Колонка.Ключ,,,10);
//			НоваяТаблица.ЗаполнитьЗначения(Колонка.Значение,Колонка.Ключ);
//		КонецЦикла;
//	КонецЕсли;
//	СтрокиС0Распределением = Новый Массив();
//	Для каждого Строка из НоваяТаблица цикл
//		СуммаРаспределений0=Истина;
//		Для каждого Колонка из распределение цикл
//			Если ЗначениеЗаполнено(Строка[Колонка.Ключ]) тогда
//				СуммаРаспределений0=Ложь;
//				Прервать;
//			КонецЕсли;
//		КонецЦикла;
//		Если СуммаРаспределений0 тогда
//			СтрокиС0Распределением.Добавить(Строка);
//		Конецесли;
//	КонецЦикла;
//	Для каждого ПустаяСтрока из СтрокиС0Распределением Цикл 
//		НоваяТаблица.Удалить(ПустаяСтрока);
//	КонецЦикла;
//	//Если ЗначениеЗаполнено(ИсключитьПослеРаспределения) тогда
//	//	КолонкиРезультата = Новый Структура();
//	//	Для каждого Колонка из НоваяТаблица.Колонки Цикл
//	//		Если ИсключитьПослеРаспределения.Свойство(Колонка.Имя) = Истина  или Распределение.Свойство(Колонка.Имя) = Истина Тогда
//	//			Продолжить;
//	//		Иначе
//	//			КолонкиРезультата.Вставить(Колонка.Имя);
//	//		КонецЕсли;
//	//	КонецЦикла;
//	//	КолонкиКСворачиванию = ВыгрузитьСтруктуруВСтроку(КолонкиРезультата,Ложь);
//	//	НоваяТаблица.Свернуть(КолонкиКСворачиванию,КолонкиКРаспределениюБазис);
//	//КонецЕсли;
//	
//	Возврат НоваяТаблица;
//КонецФункции

//Функция ВыгрузитьСтрокиДереваВТаблицуЗначений(Источник,КоллекцияКолонокДереваЗначений) Экспорт

//	Реквизиты = Новый Структура();
//	Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
//		Реквизиты.Вставить(Колонка.Имя);
//	КонецЦикла;
//	
//	НоваяТЗ= Новый ТаблицаЗначений();
//	
//	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл
//		Строка = НоваяТЗ.Добавить();
//	КонецЦикла;
//	
//	Для каждого ТекРеквизит из Реквизиты Цикл
//		ИскомыйРеквизит = ТекРеквизит.Ключ;
//		НовыйРеквизит 	= ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);
//		ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);
//		НоваяТЗ.Колонки.Добавить(НовыйРеквизит, ИсточникКолонка.ТипЗначения);
//		НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);
//	КонецЦикла;
//	
//    Возврат НоваяТЗ;
//КонецФункции // СформироватьТаблицуОплаты()

//// Возвращает строку, описывающую период, определяемый переданными
//// датой и периодичностью.
////
//// Параметры
////  ДатаВПериоде:Дата - дата из периода
////  Периодичность: Строка - строка, определяющая периодичность
////
//// Возвращаемое значение:
////   СтрокаПериод: строка   – представление периода для вывода в отчетах
////
//Функция ПолучитьПериодСтрокой(ДатаВПериоде, Периодичность) Экспорт
//	
//	Если Периодичность = "Год" Тогда
//		ФорматДаты = "ДФ='гггг ""г.""'";
//		
//	ИначеЕсли Периодичность = "Квартал" Тогда
//		ФорматДаты = "ДФ='к"" квартал"" гггг ""г.""'";
//		
//	ИначеЕсли Периодичность = "Месяц" Тогда
//		ФорматДаты = "ДФ='ММММ гггг ""г.""'";
//		
//	ИначеЕсли Периодичность = "Неделя" Тогда
//		ФорматДаты = "ДФ='""Неделя (""дд.ММ.гггг'";
//		
//	ИначеЕсли Периодичность = "День" Тогда
//		ФорматДаты = "ДФ='дд.ММ.гггг ""г.""'";
//		
//	Иначе
//		ФорматДаты = "";
//		
//	КонецЕсли;
//	
//	СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты);
//	Если Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата") Тогда
//		СтрокаПериод = "" + НеделяГода(ДатаВПериоде) + "-ая " + СтрокаПериод + Формат(КонецНедели(ДатаВПериоде), "ДФ='"" - ""дд.ММ.гггг)'");
//	КонецЕсли;
//	
//	Возврат СтрокаПериод;
//	
//КонецФункции // ПолучитьПериодСтрокой()

//// Процедура предназначена для получения момента определения остатков для заполнения документа.
////
//// Параметры:
////  ДокОбъект - (ДокументОбъект), документ, для которого надо определить лату получения остатков.
////
//// Возвращаемое значение.
////  Дата (момент времени) - дата остатков
////
//Функция ПолучитьДатуОстатков(ДокОбъект) Экспорт
//	
//	ДатаОстатков = '00010101';
//	Если НачалоДня(ДокОбъект.Дата) <> НачалоДня(ТекущаяДата()) 
//	   И ДокОбъект.Дата <> '00010101' Тогда
//	   
//		Если НЕ ЗначениеЗаполнено(ДокОбъект.Ссылка) Тогда
//			ДатаОстатков = КонецДня(ДокОбъект.Дата);
//		Иначе
//			ДатаОстатков = ДокОбъект.МоментВремени();
//		КонецЕсли;
//		
//	КонецЕсли;
//	
//	Возврат ДатаОстатков;
//	
//КонецФункции

//// Стандартная для данной конфигурации функция форматирования сумм
////
//// Параметры: 
////  Сумма  - число, которое мы хотим форматировать, 
////  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
////           будет добавлено представление валюты
////  ЧН     - строка, представляющая нулевое значение числа,
////  ЧРГ    - символ-разделитель групп целой части числа.
////
//// Возвращаемое значение:
////  Отформатированная должным образом строковое представление суммы.
////
//Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт

//	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
//					?(ПустаяСтрока(ЧН), "", ";" + "ЧН=" + ЧН) +
//					?(ПустаяСтрока(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
//	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
//	
//	Если Валюта <> Неопределено Тогда
//		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
//	КонецЕсли;

//	Возврат РезультирующаяСтрока;

//КонецФункции // ФорматСумм()

//// Удаляет повторяющиеся значения из массива
////
//// Параметры:
////	Массив
////
//Процедура УдалитьПовторяющиесяЭлементы(Массив) Экспорт
//	
//	Если ТипЗнч(Массив) = Тип("Массив") Тогда
//		
//		// Удалим повторы
//		Инд=0;
//		КолВо = Массив.Количество();
//		
//		Пока Инд<КолВо Цикл
//			
//			Инд2 = Инд+1;
//			Пока Инд2<КолВо Цикл
//				
//				Если Массив[Инд2] = Массив[Инд] Тогда
//					Массив.Удалить(Инд2);
//					КолВо = КолВо-1;
//				Иначе
//					Инд2 = Инд2+1;
//				КонецЕсли;
//				
//			КонецЦикла; 
//			
//			//Установим для не заполненных значений тип "Неопределено"
//			Если НЕ ЗначениеЗаполнено(Массив[Инд]) Тогда
//				Массив[Инд] = Неопределено;
//			КонецЕсли;

//			Инд = Инд+1;
//			
//		КонецЦикла; 
//		
//	КонецЕсли;
//	
//КонецПроцедуры

//// Функция выполняет пропорциональное распределение суммы в соответствии
//// с заданными коэффициентами распределения
////
//// Параметры:
////		ИсхСумма - распределяемая сумма
////		МассивКоэф - массив коэффициентов распределения
////		Точность - точность округления при распределении. Необязателен.
////
////	Возврат:
////		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
////			суммы в соответствии с весом коэффициента (из массива коэффициентов)
////          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
////          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
////
//Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина) Экспорт

//	Если МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null Тогда
//		Возврат Неопределено;
//	КонецЕсли;

//	// Массив коэффициентов необходимо упорядочить, поэтому создадим таблицу для распределения
//    УпорядоченнаяТаблица = Новый ТаблицаЗначений;
//	УпорядоченнаяТаблица.Колонки.Добавить("Коэф", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(17,4)));
//	УпорядоченнаяТаблица.Колонки.Добавить("ИсходныйИндекс", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,0)));
//	
//	СуммаКоэф  = 0;

//	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
//		СуммаКоэф = СуммаКоэф + МассивКоэф[К];
//		
//		СтрокаТаблицы = УпорядоченнаяТаблица.Добавить();
//		СтрокаТаблицы.Коэф = МассивКоэф[К];
//		СтрокаТаблицы.ИсходныйИндекс = К;
//	КонецЦикла;
//	
//	Если СуммаКоэф = 0 Тогда
//		Возврат Неопределено;
//	КонецЕсли;
//	
//	УпорядоченнаяТаблица.Сортировать("Коэф Убыв");
//	
//	МассивСумм = Новый Массив(УпорядоченнаяТаблица.Количество());
//	
//	Для каждого СтрокаТаблицы Из УпорядоченнаяТаблица Цикл
//		// Возвращаемый результат должен быть в том же порядке
//		МассивСумм[СтрокаТаблицы.ИсходныйИндекс] = ?(СуммаКоэф <> 0, Окр(ИсхСумма * МассивКоэф[СтрокаТаблицы.ИсходныйИндекс] / СуммаКоэф, Точность, 1), 0);
//		
//		ИсхСумма = ИсхСумма - МассивСумм[СтрокаТаблицы.ИсходныйИндекс]; 
//		СуммаКоэф = СуммаКоэф - МассивКоэф[СтрокаТаблицы.ИсходныйИндекс]; 
//	КонецЦикла;

//	Возврат МассивСумм;

//КонецФункции // РаспределитьПропорционально()

//// Процедура копирует значения одной строки таблицы значеницй в другую
//// структура колонок должна совпадать
////
//// Параметры:
////		СтрокаПриемник - строка в которую копируем
////		СтрокаИсточник - строка из которой копируем
////      ИменаКол - имена колонок, разделенные запятыми, которые надо скопировать
////                 необязателен. По умолчанию - все колонки
////
//Процедура КопироватьСтрокуТаблицыЗначений(СтрокаПриемник, СтрокаИсточник, ИменаКол) Экспорт

//	Если ТипЗнч( ИменаКол) = Тип("ТаблицаЗначений") Тогда
//		СписокСвойств = "";
//		Для Каждого Кол Из ИменаКол.Колонки Цикл
//			Если Не Кол.Имя = "НомерСтроки" Тогда
//				Если Не ПустаяСтрока(СписокСвойств) Тогда
//					СписокСвойств = СписокСвойств + ",";	
//				КонецЕсли;
//				СписокСвойств = СписокСвойств + Кол.Имя;
//			КонецЕсли;
//		КонецЦикла;
//		ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, СписокСвойств,);
//	Иначе // Строка с именами колонок
//        ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, ИменаКол,);
//	КонецЕсли;

//КонецПроцедуры // КопироватьСтрокуТаблицыЗначений()

//#Если Клиент Тогда

//// Процедура возвращает паспортные данные физлица в виде строки
////
//// Параметры: 
////  ФизЛицо - ссылка на элемент справочника "Физические лица",по которму необходимо
////            получить паспортные данные.
////
//// Возвращаемое значение:
////  Строка с данными об удостоверении личности физичского лица
////
//Функция ПолучитьПаспортныеДанныеСтрокой(ФизЛицо) Экспорт

//	СтруктураПаспортныхДанных	= РегистрыСведений.ПаспортныеДанныеФизЛиц.ПолучитьПоследнее(РабочаяДата, Новый Структура("ФизЛицо",ФизЛицо));
//	ВидДокумента				= СтруктураПаспортныхДанных.ДокументВид;
//	Серия						= СтруктураПаспортныхДанных.ДокументСерия;
//	Номер						= СтруктураПаспортныхДанных.ДокументНомер;
//	ДатаВыдачи					= СтруктураПаспортныхДанных.ДокументДатаВыдачи;
//	КемВыдан					= СтруктураПаспортныхДанных.ДокументКемВыдан;
//	НомерПодразделения			= СтруктураПаспортныхДанных.ДокументКодПодразделения;

//	Если НЕ (НЕ ЗначениеЗаполнено(ДатаВыдачи)
//		   И НЕ ЗначениеЗаполнено(ВидДокумента)
//		   И НЕ ЗначениеЗаполнено(Серия + Номер + КемВыдан + НомерПодразделения)) Тогда

//		Возврат ?(ВидДокумента.Пустая(),"","" + ВидДокумента + ", ") 
//				+ "Серия: " + Серия + ", № " + Номер 
//				+ ", Выдан: " + Формат(ДатаВыдачи,"ДФ='дд ММММ гггг'") + " года, " 
//				+ КемВыдан + "; № подр. " + НомерПодразделения;

//	Иначе
//		Возврат "Отсутствуют данные об удостоверении личности."
//	КонецЕсли;

//КонецФункции // ПолучитьПаспортныеДанныеСтрокой()

//#КонецЕсли

//// Процедура предназначена для преобразования номера документа.
////
//// Параметры:
////  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
////
//// Возвращаемое значение.
////  Строка - номер документа для печати
////
//Функция ПолучитьНомерНаПечать(Документ, МассивПрефиксов = Неопределено) Экспорт

//	Если Документ = Неопределено Тогда 
//		Возврат 0;
//	КонецЕсли;

//	Номер   = СокрЛП(Документ.Номер);
//	Префикс = "";
//	Если МассивПрефиксов = Неопределено Тогда
//		
//		Организация = Неопределено;
//		
//		Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса")
//			ИЛИ ТипЗнч(Документ) = Тип("Структура") Тогда

//			Организация = Документ.Организация;
//			
//		Иначе

//			МетаданныеДокумента = Документ.Метаданные();

//			Если МетаданныеДокумента.Реквизиты.Найти("Организация") <> Неопределено Тогда

//				Организация = Документ.Организация;

//			КонецЕсли;

//		КонецЕсли;
//		
//		МассивПрефиксовДляОбхода = СформироватьМассивПрефиксовДляРИБИОрганизации(Организация)
//		
//	Иначе
//		
//		МассивПрефиксовДляОбхода = МассивПрефиксов;
//		
//	КонецЕсли;
//	
//	Для Каждого ТекущийПрефикс ИЗ МассивПрефиксовДляОбхода Цикл
//		
//		// удаление префикса из номера документа
//		Если Найти(Номер, ТекущийПрефикс)=1 Тогда 
//			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
//		КонецЕсли;
//		
//		// так же, может остаться "минус" впереди
//		Если Лев(Номер, 1) = "-" Тогда
//			Номер = Сред(Номер, 2);
//		КонецЕсли;
//		
//		// удаление ведущих нулей
//		Пока Лев(Номер, 1)="0" Цикл
//			Номер = Сред(Номер, 2);
//		КонецЦикла;
//	КонецЦикла;

//	Возврат Номер;

//КонецФункции // ПолучитьНомерНаПечать()

//// Заменяет одни термины, которые используются в коде, другими - уместными в интерфейсе.
//// Позволяет иметь один тот же код при разных названиях объектов.
////
//// Параметры
////  СтрокаИзИнтерфейса - строка - заголовок колонки, надпись и т.п.
////
//// Возвращаемое значение:
////  Строка - новый заголовок колонки, надпись и т.п. 
////
//Функция ПреобразоватьСтрокуИнтерфейса(СтрокаИзИнтерфейса) Экспорт 

//	Возврат СтрокаИзИнтерфейса

//КонецФункции // ПреобразоватьСтрокуИнтерфейса()

//// Возвращает головную организацию для заданной организации
//// Если для организации реквизит ГоловнаяОрганизация не заполнен 
//// это значит, что сама организация является голвной
////
//// Параметры
////  Организация – СправочникСсылка.Организации
////                 <продолжение описания параметра>
////
//// Возвращаемое значение:
////   СправочникСсылка.Организации
////
//Функция ГоловнаяОрганизация(Организация) Экспорт
//	
//	Запрос = Новый Запрос;
//	Запрос.УстановитьПараметр("Организация",Организация);
//	Запрос.Текст =
//	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
//	|	Организации.ГоловнаяОрганизация
//	|ИЗ
//	|	Справочник.Организации КАК Организации
//	|ГДЕ
//	|	Организации.Ссылка = &Организация";
//	Выборка = Запрос.Выполнить().Выбрать();
//	Если Не Выборка.Следующий() Тогда
//		Возврат Справочники.Организации.ПустаяСсылка()
//	КонецЕсли;
//	Если Организация.Пустая() или Выборка.ГоловнаяОрганизация.Пустая() Тогда
//		Возврат Организация;
//	Иначе
//		Возврат Выборка.ГоловнаяОрганизация;
//	КонецЕсли;
//КонецФункции // ГоловнаяОрганизация()

//Функция ЭтоЮрЛицо(Организация) Экспорт
//	
//	Запрос = Новый Запрос;
//	Запрос.УстановитьПараметр("Организация",Организация);
//	Запрос.Текст =
//	"ВЫБРАТЬ
//	|	Организации.ПравовойСтатус
//	|ИЗ
//	|	Справочник.Организации КАК Организации
//	|ГДЕ
//	|	Организации.Ссылка = &Организация";
//	Выборка = Запрос.Выполнить().Выбрать();
//	Возврат Не Выборка.Следующий() Или Выборка.ПравовойСтатус <> Перечисления.ПравовойСтатус.ФизЛицо;
//	
//КонецФункции // ЭтоЮрЛицо()

//Функция ЭтоДоступнаяОрганизация(Организация) Экспорт
//	
//	Запрос = Новый Запрос;
//	Запрос.УстановитьПараметр("Организация",Организация);
//	Запрос.Текст =
//	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
//	|	Организации.ПометкаУдаления
//	|ИЗ
//	|	Справочник.Организации КАК Организации
//	|ГДЕ
//	|	Организации.Ссылка = &Организация";
//	
//	Возврат Не Запрос.Выполнить().Пустой() // если удалось прочитать закрытое поле - организация доступна
//	
//КонецФункции // ЭтоДоступнаяОрганизация()


/////////////////////////////////////////////////////////////////////////////////
//// РАБОТА С ПЕРЕЧИСЛЕНИЕМ "ПЕРИОДИЧНОСТЬ"
//// Функции не обрабатывают значения "Декада" и "Полугодие"

//// Функция возвращает ближайшую дату начала периода планирования
////
//// Параметры
////	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
////	ДатаВПериоде (Дата)							- произвольная дата
////
//// Возвращаемое значение:
////	ДатаНачалаПериода		– ближайшая дата начала периода планирования
////
//Функция ДатаНачалаПериода(ДатаВПериоде,Периодичность) Экспорт
//	
//	Если НЕ ТипЗнч(ДатаВПериоде)=Тип("Дата") Тогда
//		Возврат '00010101';
//	КонецЕсли;
//	
//	Если Периодичность=Перечисления.Периодичность.День Тогда
//		Возврат НачалоДня(ДатаВПериоде);
//	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
//		Возврат НачалоНедели (ДатаВПериоде);
//	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
//		Возврат НачалоМесяца (ДатаВПериоде);
//	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
//		Возврат НачалоКвартала (ДатаВПериоде);
//	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
//		Возврат НачалоГода (ДатаВПериоде);
//	Иначе
//		Возврат НачалоДня(ДатаВПериоде);
//	КонецЕсли;
//		
//КонецФункции // ДатаНачалаПериода()

//// Функция возвращает ближайшую дату окончания периода планирования
////
//// Параметры
////	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
////	ДатаВПериоде (Дата)							- произвольная дата
////
//// Возвращаемое значение:
////	ДатаКонцаПериода	– ближайшая дата окончания периода планирования
////
//Функция ДатаКонцаПериода(ДатаВПериоде,Периодичность) Экспорт
//							
//	Если Периодичность=Перечисления.Периодичность.День Тогда
//		Возврат КонецДня(ДатаВПериоде);
//	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
//		Возврат КонецНедели (ДатаВПериоде);
//	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
//		Возврат КонецМесяца (ДатаВПериоде);
//	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
//		Возврат КонецКвартала (ДатаВПериоде);
//	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
//		Возврат КонецГода (ДатаВПериоде);
//	Иначе
//		Возврат КонецДня(ДатаВПериоде);
//	КонецЕсли;
//		
//КонецФункции // ДатаКонцаПериода()

//// Функция добавляет интервал к дате
////
//// Параметры:
////	Периодичность (Перечисления.Периодичность)	- пнриодичность планирования по сценарию.
////	ДатаВПериоде (Дата)							- произвольная дата
////	Смещение (число)							- определяет направление и количество периодов, в котором сдвигается дата
////
//// Возвращаемое значение:
////	Дата, отстоящая от исходной на заданное количество периодов 
////
//Функция ДобавитьИнтервал(ДатаПериода,Периодичность,Смещение) Экспорт

//	Если Смещение = 0 Тогда
//		НоваяДатаПериода = ДатаПериода;
//		
//	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
//		НоваяДатаПериода = НачалоДня(ДатаПериода + Смещение*24*3600);
//		
//	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
//		НоваяДатаПериода = ДатаПериода + Смещение*7*24*3600;
//		
//	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
//		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение);
//		
//	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
//		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*3);
//		
//	ИначеЕсли Периодичность = Перечисления.Периодичность.Год Тогда
//		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*12);
//		
//	Иначе
//		НоваяДатаПериода=НачалоДня(ДатаПериода) + Смещение*24*3600;
//		
//	КонецЕсли;

//	Возврат НоваяДатаПериода;

//КонецФункции // ДобавитьИнтервал()

//// Возвращает число дней в переданном периоде
////
//// Параметры
////  Периодичность – Перечисление.Периодичность элемент перечисления, 
////		для которого вычисляется количество дней
////
//// Возвращаемое значение:
////   ЧислоДнейВПериоде (число)  – число дней в переданном периоде
////
//Функция ЧислоДнейВПериоде(Периодичность) Экспорт
//		
//	Если Периодичность=Перечисления.Периодичность.День Тогда
//		ЧислоДнейВПериоде=1;
//	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
//		ЧислоДнейВПериоде=7;
//	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
//		ЧислоДнейВПериоде=30;
//	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
//		ЧислоДнейВПериоде=90;
//	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
//		ЧислоДнейВПериоде=365;
//	Иначе
//		ЧислоДнейВПериоде=0;
//	КонецЕсли;
//	
//	Возврат ЧислоДнейВПериоде;	

//КонецФункции // ЧислоДнейВПериоде()

/////////////////////////////////////////////////////////////////////////////////

//Функция ВопросПерезаполнитьКУДиР() Экспорт
//	
//	Ответ = Ложь;
//	
//	#Если Клиент Тогда
//		ТекстВопроса = 
//		"Отражение платежа в Книге учета доходов и расходов настроено вручную.
//		|Перезаполнить показатели Книги учета доходов и расходов?";
//		
//		Ответ = (Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Да) = КодВозвратаДиалога.Да);
//	#КонецЕсли
//	
//	Возврат Ответ;
//	
//КонецФункции

//// Формирует список обособленных структурных подразделений организации
//Функция ПолучитьСписокОбособленныхПодразделенийОрганизации(Организация) Экспорт

//	Запрос = Новый Запрос(
//	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
//	|	Организации.Ссылка,
//	|	Организации.Наименование
//	|ИЗ
//	|	Справочник.Организации КАК Организации
//	|ГДЕ
//	|	Организации.ГоловнаяОрганизация = &Организация");

//	Запрос.УстановитьПараметр("Организация", Организация);

//	СписокОрганизаций = Новый СписокЗначений;
//	
//	Выборка = Запрос.Выполнить().Выбрать(); 

//	Пока Выборка.Следующий() Цикл
//		СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);
//	КонецЦикла;

//	Возврат СписокОрганизаций;
//КонецФункции // ПолучитьСписокОбособленныхПодразделенийОрганизации()

////Удалает повторяющиеся элементы массива.
//Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь, УдалитьПустыеЭлементыСсылочногоТипа = Ложь) Экспорт
//	
//	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
//	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
//	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
//	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
//	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
//	
//	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
//		
//		УжеВМасссиве = Новый Соответствие; 
//		БылоНеопределено = Ложь;
//		
//		КолвоЭлементовВМассиве = Массив.Количество(); 
//		
//		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
//			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
//			ТипЭлемента = ТипЗнч(ЭлементМассива); 
//			Если ЭлементМассива = Неопределено Тогда
//				Если БылоНеопределено или НеИспользоватьНеопределено Тогда
//					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
//				Иначе
//					БылоНеопределено = Истина;
//				КонецЕсли;
//				Продолжить;
//			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
//				ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
//				ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
//				ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
//				ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
//				
//				Если УдалитьПустыеЭлементыСсылочногоТипа
//					И НЕ ЗначениеЗаполнено(ЭлементМассива)
//					Тогда
//					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
//					Продолжить;
//				КонецЕсли;
//				
//				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
//				
//			Иначе 
//				
//				ИДЭлемента = ЭлементМассива; 
//				
//			КонецЕсли; 
//			
//			Если УжеВМасссиве[ИДЭлемента] = Истина Тогда 
//				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
//			Иначе 
//				УжеВМасссиве[ИДЭлемента] = Истина; 
//			КонецЕсли; 
//		КонецЦикла;      
//		
//	КонецЕсли;
//	
//	Возврат Массив;
//	
//КонецФункции

////Функция возвращает информацию об уполномоченных лицах организации и сведения о приказе назначения 
//Функция ПолучитьДанныеУполномоченногоЛица(Организация, Пользователь = Неопределено) Экспорт 
//	
//	Запрос = Новый Запрос;
//	
//	МассивПользователей = Новый Массив;
//	МассивПользователей.Добавить(Справочники.Пользователи.ПустаяСсылка());
//	Если Пользователь <> Неопределено Тогда
//		МассивПользователей.Добавить(Пользователь);
//	КонецЕсли;
//	
//	Запрос.УстановитьПараметр("Организация",Организация);
//	Запрос.УстановитьПараметр("Пользователи",МассивПользователей);
//	Запрос.Текст = "
//		|ВЫБРАТЬ
//		|	УполномоченныеЛица.УполномоченноеЛицо,
//		|	УполномоченныеЛица.ЗаКогоПодписывает,
//		|	УполномоченныеЛица.НомерДатаПриказа,
//		|	ВЫБОР
//		|		КОГДА УполномоченныеЛица.Пользователь = ЗНАЧЕНИЕ(Справочник.ФизическиеЛица.ПустаяСсылка) ТОГДА
//		|			0
//		|		ИНАЧЕ 1
//		|	КОНЕЦ КАК ТипПользователя
//		|ИЗ
//		|	РегистрСведений.УполномоченныеЛицаОрганизаций КАК УполномоченныеЛица
//		|ГДЕ
//		|	УполномоченныеЛица.Организация = &Организация И
//		|	УполномоченныеЛица.Пользователь В (&Пользователи)
//		|УПОРЯДОЧИТЬ ПО
//		|	ТипПользователя";
//		
//	УстановитьПривилегированныйРежим(Истина);
//	Результат = Запрос.Выполнить();
//	УстановитьПривилегированныйРежим(Ложь);
//	Если Результат.Пустой() Тогда
//		Возврат Неопределено;
//	Иначе 
//		ВозвращаемыйРезультат = Новый Структура("Руководитель,ПриказРуководитель,ГлавныйБухгалтер,ПриказГлавныйБухгалтер");
//		
//		Таблица = Результат.Выгрузить();
//		Для Каждого Строка Из Таблица Цикл
//			Если Строка.ЗаКогоПодписывает = Перечисления.ОтветственныеЛицаОрганизаций.Руководитель Тогда 
//				ВозвращаемыйРезультат.Руководитель = Строка.УполномоченноеЛицо;
//				ВозвращаемыйРезультат.ПриказРуководитель = Строка.НомерДатаПриказа;
//			ИначеЕсли Строка.ЗаКогоПодписывает = Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер Тогда 
//				ВозвращаемыйРезультат.ГлавныйБухгалтер = Строка.УполномоченноеЛицо;
//				ВозвращаемыйРезультат.ПриказГлавныйБухгалтер = Строка.НомерДатаПриказа;
//			КонецЕсли;
//		КонецЦикла;
//		Возврат ВозвращаемыйРезультат;
//	КонецЕсли;
//	
//КонецФункции

//// Функция собирает сведения об ответственных лицах организации 
////
//// Параметры:
////  Организация - организация, для которой нужно определить руководящих лиц.
////
//Функция ОтветственныеЛица(Организация, ДатаСреза, Подразделение = Неопределено) Экспорт
//	
//	СобиратьПоОрганизации = Истина;
//	Результат = Новый Структура("Руководитель, РуководительДолжность, РуководительФИО, РуководительПредставление, 
//								|ГлавныйБухгалтер, ГлавныйБухгалтерДолжность, ГлавныйБухгалтерФИО, ГлавныйБухгалтерПредставление, 
//								|Кассир, КассирДолжность, КассирФИО, КассирПредставление,  
//								|ОтветственныйЗаРегистры, ОтветственныйЗаРегистрыДолжность, ОтветственныйЗаРегистрыФИО, ОтветственныйЗаРегистрыПредставление");

//	Если Организация <> Неопределено тогда

//		ЗапросПоЛицам = Новый Запрос();
//		ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
//		ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
//		ЗапросПоЛицам.УстановитьПараметр("ПризнакФизЛица",   Перечисления.ПравовойСтатус.ФизЛицо);
//		
//		ЗапросПоЛицам.Текст = "ВЫБРАТЬ
//		                      |	ФИОФизЛицСрезПоследних.Фамилия,
//		                      |	ФИОФизЛицСрезПоследних.Имя,
//		                      |	ФИОФизЛицСрезПоследних.Отчество,
//		                      |	ФИОФизЛицСрезПоследних.ФизЛицо КАК ФизическоеЛицо
//		                      |ИЗ
//		                      |	РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ) КАК ФИОФизЛицСрезПоследних
//		                      |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Организации КАК Организации
//		                      |		ПО ФИОФизЛицСрезПоследних.ФизЛицо = Организации.ИндивидуальныйПредприниматель
//		                      |			И (Организации.Ссылка = &Организация)
//		                      |			И (Организации.ПравовойСтатус = &ПризнакФизЛица)";
//		
//		Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
//		
//		Пока Руководители.Следующий() Цикл
//			
//			ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");
//			Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
//				ФИО.Фамилия = Руководители.Фамилия;
//			КонецЕсли;
//			Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
//				ФИО.Имя = Руководители.Имя;
//			КонецЕсли;
//			Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
//				ФИО.Отчество = Руководители.Отчество;
//			КонецЕсли;
//			Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
//			
//			Результат.Руководитель               = Руководители.ФизическоеЛицо;
//			Результат.РуководительДолжность      = "";
//			Результат.РуководительФИО            = ФИО;
//			Результат.РуководительПредставление  = Представление;
//			
//		КонецЦикла;
//		
//		Если СобиратьПоОрганизации Тогда
//			
//			ЗапросПоЛицам.Текст = 
//			"ВЫБРАТЬ
//			|	ОтветственныеЛицаОрганизацийСрезПоследних.ОтветственноеЛицо,
//			|	ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо,
//			|	ОтветственныеЛицаОрганизацийСрезПоследних.Должность,
//			|	ФИОФизЛицСрезПоследних.Фамилия,
//			|	ФИОФизЛицСрезПоследних.Имя,
//			|	ФИОФизЛицСрезПоследних.Отчество
//			|ИЗ
//			|	РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(&ДатаСреза, СтруктурнаяЕдиница = &Организация) КАК ОтветственныеЛицаОрганизацийСрезПоследних
//			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо ССЫЛКА Справочник.ФизическиеЛица) КАК ФИОФизЛицСрезПоследних
//			|		ПО ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо = ФИОФизЛицСрезПоследних.ФизЛицо";
//			Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
//		КонецЕсли;

//		Пока Руководители.Следующий() Цикл

//			ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");
//			Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
//				ФИО.Фамилия = Руководители.Фамилия;
//			КонецЕсли;
//			Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
//				ФИО.Имя = Руководители.Имя;
//			КонецЕсли;
//			Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
//				ФИО.Отчество = Руководители.Отчество;
//			КонецЕсли;
//			Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
//			
//			Если Руководители.ОтветственноеЛицо      = Перечисления.ОтветственныеЛицаОрганизаций.Руководитель Тогда
//				Результат.Руководитель               = Руководители.ФизическоеЛицо;
//				Результат.РуководительДолжность      = Руководители.Должность;
//				Результат.РуководительФИО            = ФИО;
//				Результат.РуководительПредставление  = Представление;

//			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер Тогда
//				Результат.ГлавныйБухгалтер           = Руководители.ФизическоеЛицо;
//				Результат.ГлавныйБухгалтерДолжность  = Руководители.Должность;
//                Результат.ГлавныйБухгалтерФИО        = ФИО;
//				Результат.ГлавныйБухгалтерПредставление  = Представление;
//				
//			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.Кассир Тогда
//				Результат.Кассир                     = Руководители.ФизическоеЛицо;
//				Результат.КассирДолжность      		 = Руководители.Должность;
//                Результат.КассирФИО            		 = ФИО;
//				Результат.КассирПредставление  = Представление;
//				
//			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ОтветственныйЗаНалоговыеРегистры Тогда
//				Результат.ОтветственныйЗаРегистры    = Руководители.ФизическоеЛицо;
//				Результат.ОтветственныйЗаРегистрыДолжность      = Руководители.Должность;
//				Результат.ОтветственныйЗаРегистрыФИО = ФИО;
//				Результат.ОтветственныйЗаРегистрыПредставление  = Представление;

//			КонецЕсли;

//		КонецЦикла;

//	КонецЕсли;

//	Возврат Результат;

//КонецФункции

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ

//// Получает первичную информацию об ошибке
//// Параметры:
////	ИнформацияОбОшибке - информация об ошибке
//// Возвращает:
////	Информацию об ошибке, которая является первопричиной возникновения переданной ИнформацияОбОшибке
////  Если ошибка первичная, то возвращается сама ошибка, переданная в качестве параметра
//Функция ПолучитьПричинуОшибки(ИнформацияОбОшибке) Экспорт
//	ПричинаОшибки = ИнформацияОбОшибке.Причина;
//	Если ПричинаОшибки = НеОпределено Тогда
//		Возврат ИнформацияОбОшибке;
//	КонецЕсли;
//	Пока ПричинаОшибки.Причина <> НеОпределено Цикл
//		ПричинаОшибки = ПричинаОшибки.Причина;
//	КонецЦикла;
//	Возврат ПричинаОшибки;
//	
//КонецФункции

//// Считываем последнее состояние регистра сведений о физлице и заполняем переданный набор записей
////
//// Параметры
////  Физлицо - 
////  НаборЗаписей  - 
////
//Процедура ПолучитьСвязанныеДанныеФизлица(Физлицо, НаборЗаписей) Экспорт

//	НаборЗаписей.Очистить();
//	
//	Если Физлицо.Пустая() Тогда
//		Возврат;
//	КонецЕсли;	
//	
//	ИмяТаблицы = НаборЗаписей.Метаданные().Имя;
//	
//	Запрос = Новый Запрос;
//	Запрос.УстановитьПараметр("ПарамФизЛицо",Физлицо);
//	Запрос.УстановитьПараметр("парамДатаСреза", ОбщегоНазначения.ПолучитьРабочуюДату());
//	
//	Запрос.Текст = 
//	"ВЫБРАТЬ
//	|	СвязанныеДанные.*
//	|ИЗ
//	|	РегистрСведений." + ИмяТаблицы + ".СрезПоследних(&парамДатаСреза, ФизЛицо = &ПарамФизЛицо) КАК СвязанныеДанные";
//	
//	Выборка = Запрос.Выполнить().Выбрать();
//	Если Выборка.Следующий() Тогда
//		ЗаполнитьЗначенияСвойств(НаборЗаписей.Добавить(), Выборка);
//	КонецЕсли;
//	
//КонецПроцедуры // ПолучитьСвязанныеДанныеФизлица()

//////////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ ОБСЛУЖИВАНИЯ ОБЪЕКТОВ, НЕ ПОДДЕРЖИВАЕМЫХ В КОНФИГУРАЦИИ
////

//// Выводит сообщение о том, что объект не используется в конфигурации
////
//Процедура СообщитьОбъектНеИспользуется(МетаданныеОбъекта = Неопределено, Отказ = Истина, СтандартнаяОбработка = Ложь) Экспорт
//	
//	Перем ТипОбъекта;
//	
//	ТипОбъекта = "Объект";
//	Если МетаданныеОбъекта <> Неопределено Тогда
//		ПолноеИмяОбъекта = МетаданныеОбъекта.ПолноеИмя();
//		ПозицияТочки = Найти(ПолноеИмяОбъекта, ".");
//		Если ПозицияТочки <> 0 Тогда
//			ТипОбъекта = Лев(ПолноеИмяОбъекта, ПозицияТочки-1);
//		КонецЕсли;
//	КонецЕсли;
//	
//	ОбщегоНазначения.СообщитьОбОшибке(ТипОбъекта+" не используется в конфигурации """ + Метаданные.Синоним + """", Отказ);
//	СтандартнаяОбработка = Ложь;
//	
//КонецПроцедуры

//// Заполняет указанную колонку таблицы значений числами по порядку, начиная с указанного номера
////
//Процедура ПронумероватьСтрокиТаблицыЗначений(Таблица, ИмяКолонки = "НомерСтроки", ПервыйНомер = 1) Экспорт
//	
//	НомерСтроки = ПервыйНомер;
//	
//	Для Каждого Строка Из Таблица Цикл
//		Строка[ИмяКолонки] = НомерСтроки;
//		НомерСтроки = НомерСтроки + 1;
//	КонецЦикла;
//	
//КонецПроцедуры


// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура.
//              Если в качестве объекта передана пустая ссылка, то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		Реквизиты = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Реквизиты, ",", ИСТИНА);
	КонецЕсли;
	
	СтруктураРеквизитов = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура") Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		СтруктураРеквизитов = Реквизиты;
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Для Каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(СтрЗаменить(Реквизит, ".", ""), Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ОбщийМодульПовтор.ПолучитьТекстНаЯзыке("Неверный тип второго параметра Реквизиты") + ": %1",
			Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Выполняет действия перед продолжением выполнения обработчика регламентного задания.
//
// Например, проверяет возможность выполнения обработчика регламентного задания.
// Если администратор не заблокировал выполнение регламентных заданий до
// окончания обновления ИБ, тогда требуется прекратить выполнение обработчика.
// 
Процедура ПриНачалеВыполненияРегламентногоЗадания() Экспорт
	
	УстановитьПривилегированныйРежим(ИСТИНА);
		
КонецПроцедуры

//ОБМЕН С САЙТОМ+
////////////////////////////////////////////////////////////////////////////////
// Имена типов.

// Возвращает значение для идентификации общего типа "Регистры сведений".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыСведений() Экспорт
	
	Возврат "РегистрыСведений";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры накопления".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыНакопления() Экспорт
	
	Возврат "РегистрыНакопления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры бухгалтерии".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыБухгалтерии() Экспорт
	
	Возврат "РегистрыБухгалтерии";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры расчета".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыРасчета() Экспорт
	
	Возврат "РегистрыРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Документы".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаДокументы() Экспорт
	
	Возврат "Документы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Справочники".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаСправочники() Экспорт
	
	Возврат "Справочники";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Перечисления".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПеречисления() Экспорт
	
	Возврат "Перечисления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Отчеты".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаОтчеты() Экспорт
	
	Возврат "Отчеты";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Обработки".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаОбработки() Экспорт
	
	Возврат "Обработки";
	
КонецФункции

// Возвращает значение для идентификации общего типа "ПланыОбмена".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыОбмена() Экспорт
	
	Возврат "ПланыОбмена";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов характеристик".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыВидовХарактеристик() Экспорт
	
	Возврат "ПланыВидовХарактеристик";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Бизнес-процессы".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаБизнесПроцессы() Экспорт
	
	Возврат "БизнесПроцессы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Задачи".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаЗадачи() Экспорт
	
	Возврат "Задачи";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы счетов".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыСчетов() Экспорт
	
	Возврат "ПланыСчетов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов расчета".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыВидовРасчета() Экспорт
	
	Возврат "ПланыВидовРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Константы".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаКонстанты() Экспорт
	
	Возврат "Константы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Журналы документов".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаЖурналыДокументов() Экспорт
	
	Возврат "ЖурналыДокументов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Последовательности".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПоследовательности() Экспорт
	
	Возврат "Последовательности";
	
КонецФункции

// Возвращает значение для идентификации общего типа "РегламентныеЗадания".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегламентныеЗадания() Экспорт
	
	Возврат "РегламентныеЗадания";
	
КонецФункции

// Возвращает имя базового типа по переданному значению объекта метаданных.
//
// Параметры:
//  ОбъектМетаданных - объект метаданных, по которому необходимо определить базовый тип.
// 
// Возвращаемое значение:
//  Строка - имя базового типа по переданному значению объекта метаданных.
//
Функция ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) Экспорт
	
	Если Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаДокументы();
		
	ИначеЕсли Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаСправочники();
		
	ИначеЕсли Метаданные.Перечисления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПеречисления();
		
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыСведений();
		
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыНакопления();
		
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыБухгалтерии();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыРасчета();
		
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыОбмена();
		
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовХарактеристик();
		
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаБизнесПроцессы();
		
	ИначеЕсли Метаданные.Задачи.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЗадачи();
		
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыСчетов();
		
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовРасчета();
		
	ИначеЕсли Метаданные.Константы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаКонстанты();
		
	ИначеЕсли Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЖурналыДокументов();
		
	ИначеЕсли Метаданные.Последовательности.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПоследовательности();
		
	ИначеЕсли Метаданные.РегламентныеЗадания.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегламентныеЗадания();
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции 

// Возвращает значения реквизитов, прочитанные из информационной базы
// для нескольких объектов.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИменаРеквизитов - Строка, имена реквизитов перечисленные через запятую,
//				в формате требований к свойствам структуры.
//				Например, "Код, Наименование, Родитель".
// 
// Возвращаемое значение:
//  Соответствие - где ключ - ссылка на объект, а Значение - структура, которая 
//		   		содержит список свойств, как список имен в строке
//				ИменаРеквизитов, со значениям реквизитов, прочитанными из информационной базы.
// 
Функция ЗначенияРеквизитовОбъектов(МассивСсылок, ИменаРеквизитов) Экспорт
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если МассивСсылок.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Ссылка КАК Ссылка, " + ИменаРеквизитов + "
		|ИЗ
		|	" + МассивСсылок[0].Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&МассивСсылок)";
	Запрос.УстановитьПараметр("МассивСсылок", МассивСсылок);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(ИменаРеквизитов);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Соответствие - Ключ - ссылка на объект, Значение - значение прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита) Экспорт
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита);
	Для Каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;
		
	Возврат ЗначенияРеквизитов;
	
КонецФункции

////ОБМЕН С САЙТОМ-
